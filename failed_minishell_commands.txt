----------------------------            

----------------------------
üßæ Heredoc Edge Cases
----------------------------


----------------------------
üì¶ Export & Command Substitution
----------------------------
export T="echo segfault | grep segfault"
$T                          # Running command from exported variable

----------------------------
üß© Quoting Hell
----------------------------
p""''''w''''''''''''''''''''''''''''''''''''''d
'''''''''''''''' echo ok
''echo ok
""echo ok
""echo"" ok
""'echo'"" ok
'e'cho 42
"./"ls
"./""ls"
"./"''"ls"

----------------------------
üß® Redirection Edge Case
----------------------------
>| echo sure               # Bash supports this as 'clobber', but not POSIX

----------------------------
üö™ Exit Statement with Quoted Value
----------------------------
exit 123"123"              # Should become: exit 123123

----------------------------
‚ùì Ambiguous/Nonexistent Commands
----------------------------
env what                   # 'what' is likely not a command
./ls                       # Only works if `ls` is in current directory
"./"ls
"./""ls"
"./"''"ls"

----------------------------
üîó Pipelines and Subshells
----------------------------
((echo 1) | (echo 2) | (echo 3 | (echo 4)))

echo 1 | (echo 2 || echo 3 && echo 4) || echo 5 | echo 6

echo 1 | (grep 1) | cat | (wc -l)

(/bin/echo 1 | /bin/echo 2 && ((/bin/echo 3 | /bin/echo 3) | (/bin/echo 4 | /bin/echo 4)))

----------------------------
üßÆ Heavyweight AWK Use
----------------------------
awk 'BEGIN{for(i=1;i<=10;i++){for(j=1;j<=10;j++){printf("%4d ",i*j)} printf("\n")}}' /dev/null | tail -n 10

awk 'BEGIN{for(i=1;i<=1000000;i++)print int(i)}' | awk '{sum+=$1} END {print sum/NR}'

----------------------------
‚ùå PATH Unset Scenarios
----------------------------
unset PATH
cd /bin
ls

unset PATH
cd /bin/../bin/
ls


touch tmp_out
/bin/echo 42 >tmp_o*t*
rm -f "tmp_out*"




touch tmp_out1
touch tmp_out2
/bin/echo 42 >tmp_out*
rm -f "tmp_out*"



/usr/bin/printf "%s\n" "Mak"'e'*'*' | sort

/usr/bin/printf "%s\n" "Mak"'e'** | sort

/usr/bin/printf "%s\n" ***"Mak"'e'** | sort

/usr/bin/printf "%s\n" "."* | sort

/usr/bin/printf "%s\n" *"." | sort

/usr/bin/printf "%s\n" *"."* | sort

/usr/bin/printf "%s\n" "*" | sort

/usr/bin/printf "%s\n" '*' | sort



touch "*1"
/usr/bin/printf "%s\n" "*"* | sort
rm "*1"




echo '$='





echo $'$'




echo $'HOME'












export X="  A  B  "
/bin/echo "1"$X'2'

export X=" A  B  "
/bin/echo "1"$X'2'

export X="A  B  "
/bin/echo "1"$X'2'

export X="  A  B "
/bin/echo "1"$X'2'

export X="  A  B"
/bin/echo "1"$X'2'

export X="  A B  "
/bin/echo "1"$X'2'

export X="  AB  "
/bin/echo "1"$X'2'

export X="  A  B  "
/bin/echo $X'2'

export X="  A  B  "
/bin/echo $X"1"

export X=""
/bin/echo "1"$X'2'

export X=" "
/bin/echo "1"$X'2'

export X="   "
/bin/echo "1"$X'2'

export X="  A  B  "
/bin/echo ?$X'2'

export X="  A  B  "
/bin/echo "1"$X?

export X="  A  B  "
/bin/echo "1"$X2?






/bin/env | grep "_="




















export pipe_var=1 | echo $pipe_var
echo $pipe_var

/bin/echo '\1$42' > tmp_redir_out
ls -la | grep tmp_redir_out | awk '{print $1 $2}'
cat -e tmp_redir_out
rm tmp_redir_out

export test="arg1	arg2"
echo 'echo $1' > tmp_test_sh
bash tmp_test_sh $test
echo 'echo $2' > tmp_test_sh
bash tmp_test_sh $test
rm -f tmp_test_sh

echo "env | /usr/bin/wc -l" | env -i $MINISHELL_PATH"/"$EXECUTABLE
echo $?

echo "ls" | env -i $MINISHELL_PATH"/"$EXECUTABLE
echo $?

echo "unset PATH" | env -i $MINISHELL_PATH"/"$EXECUTABLE
echo $?
