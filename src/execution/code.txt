

### START OF FILE: ./builtins/builtins.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	builtin_echo(t_ast *data, t_ast *tree, int fd_out)
{
	if (execute_echo(tree->cmd->args, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_exit(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_exit(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static const t_builtin  g_builtins[] = {
	{"export", builtin_export},
	{"unset", builtin_unset},
	{"env", builtin_env},
	{"cd", builtin_cd},
	{"pwd", builtin_pwd},
	{"echo", builtin_echo},
	{"exit", builtin_exit},
	{NULL, NULL}
	};

int	handle_builtin(t_ast *data, t_ast *tree, int fd_out)
{
	int	i;

	i = 0;
	if (!tree->cmd->args || !tree->cmd->args[0])
		return (0);
	while (g_builtins[i].name)
	{
		if (!ft_strcmp(tree->cmd->args[0], g_builtins[i].name))
			return (g_builtins[i].func(data, tree, fd_out));
		i++;
	}
	return (0);
}

### END OF FILE: ./builtins/builtins.c ###


### START OF FILE: ./builtins/builtins_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

bool	is_valid_identifier(const char *name)
{
	if (!name || !*name || ft_isdigit(*name))
		return (false);
	while (*name)
	{
		if (!ft_isalnum(*name) && *name != '_')
			return (false);
		name++;
	}
	return (true);
}

int	execute_echo(char *args[], int fd_out)
{
	int	i;
	int	n_flag;

	i = 1;
	n_flag = 1;
	if (args[1] && !ft_strcmp(args[1], "-n"))
	{
		n_flag = 0;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], fd_out);
		if (args[i + 1])
			ft_putstr_fd(" ", fd_out);
		i++;
	}
	if (n_flag)
		ft_putendl_fd("", fd_out);
	return (0);
}

int	execute_exit(t_ast *data, t_ast *tree)
{
	int	status;

	status = 0;
	if (tree->cmd->args[1])
		status = ft_atoi(tree->cmd->args[1]);
	free_data(data);
	exit (status);
	return (0);
}

### END OF FILE: ./builtins/builtins_utils.c ###


### START OF FILE: ./builtins/utils/builtins_env_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	builtin_export(t_ast *data, t_ast *tree, int fd_out)
{
	if (!tree->cmd->args[1])
		print_env_list(data->env_list, fd_out);
	else
		execute_export(data, tree, fd_out);
	return (1);
}

int	builtin_unset(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_unset(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

int	builtin_env(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	print_env_list(data->env_list, fd_out);
	return (1);
}

### END OF FILE: ./builtins/utils/builtins_env_utils.c ###


### START OF FILE: ./builtins/utils/builtins_env_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

t_env	*get_env_node(t_env *env_list, const char *name)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (strcmp(current->key, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

void	update_env_var(t_ast *data, const char *key, const char *value)
{
	t_env	*env;
	t_env	*new_env;

	env = get_env_node(data->env_list, key);
	if (env)
	{
		free(env->value);
		env->value = ft_strdup(value);
	}
	else
	{
		new_env = malloc(sizeof(t_env));
		new_env->key = ft_strdup(key);
		new_env->value = ft_strdup(value);
		new_env->next = data->env_list;
		data->env_list = new_env;
	}
}

int	create_new_env(t_ast *d, char *n, char *eq)
{
	t_env	*env;

	env = malloc(sizeof(t_env));
	if (!env)
		return (free(n), 1);
	env->key = n;
	if (eq)
		env->value = ft_strdup(eq + 1);
	else
		env->value = ft_strdup("");
	env->next = d->env_list;
	d->env_list = env;
	return (0);
}

### END OF FILE: ./builtins/utils/builtins_env_utils_2.c ###


### START OF FILE: ./builtins/utils/builtins_path_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_oldpwd(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "OLDPWD");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: OLDPWD not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	ft_putendl_fd(path, STDOUT_FILENO);
	return (0);
}

int	builtin_cd(t_ast *data, t_ast *tree, int fd_out)
{
	char	*path;
	char	*oldpwd;

	(void)fd_out;
	path = tree->cmd->args[1];
	oldpwd = getcwd(NULL, 0);
	if (!path || !ft_strcmp(path, "~"))
	{
		execute_home(data, path, oldpwd);
	}
	else if (!ft_strcmp(path, "-"))
	{
		execute_oldpwd(data, path, oldpwd);
	}
	if (execute_cd(data, path))
	{
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	set_env_var(data, "OLDPWD", oldpwd);
	free(oldpwd);
	return (1);
}

int	builtin_pwd(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	if (execute_pwd(data, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

int	execute_pwd(t_ast *data, int fd_out)
{
	char	*cwd;

	(void)data;
	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		ft_putendl_fd("minishell: pwd: error retrieving current directory",
			STDERR_FILENO);
		return (1);
	}
	ft_putendl_fd(cwd, fd_out);
	free(cwd);
	return (0);
}

### END OF FILE: ./builtins/utils/builtins_path_utils.c ###


### START OF FILE: ./builtins/utils/builtins_path_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	handle_pwd_errors(char *old_pwd, int error_code)
{
	free(old_pwd);
	ft_putendl_fd(" error retrieving current directory", STDERR_FILENO);
	return (error_code);
}

int	update_directory(t_ast *data, char *path, char *old_pwd)
{
	char	*new_pwd;

	if (chdir(path) != 0)
	{
		ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
		ft_putendl_fd(strerror(errno), STDERR_FILENO);
		free(old_pwd);
		return (1);
	}
	new_pwd = getcwd(NULL, 0);
	if (!new_pwd)
		return (handle_pwd_errors(old_pwd, 1));
	update_env_var(data, "OLDPWD", old_pwd);
	update_env_var(data, "PWD", new_pwd);
	free(old_pwd);
	free(new_pwd);
	return (0);
}

int	execute_cd(t_ast *data, char *path)
{
	char	*old_pwd;
	t_env	*home;

	old_pwd = getcwd(NULL, 0);
	if (!old_pwd)
		return (handle_pwd_errors(NULL, 1));
	if (!path)
	{
		home = get_env_node(data->env_list, "HOME");
		if (!home || !home->value)
		{
			ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
			free(old_pwd);
			return (1);
		}
		path = home->value;
	}
	return (update_directory(data, path, old_pwd));
}

int	execute_home(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "HOME");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	return (0);
}

### END OF FILE: ./builtins/utils/builtins_path_utils_2.c ###


### START OF FILE: ./env/env_export.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static void	update_env_variable(t_env *env, char *name, char *eq)
{
	if (eq)
	{
		free(env->value);
		env->value = ft_strdup(eq + 1);
	}
	free(name);
}

static int	handle_export_error(char *arg)
{
	ft_putstr_fd("minishell: export: `", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}

static int	process_export_arg(t_ast *data, char *arg)
{
	char	*eq;
	char	*name;
	t_env	*env;

	eq = ft_strchr(arg, '=');
	if (eq)
		name = ft_substr(arg, 0, eq - arg);
	else
		name = ft_strdup(arg);
	if (!name || !is_valid_identifier(name))
		return (free(name), handle_export_error(arg));
	env = get_env_node(data->env_list, name);
	if (env)
		update_env_variable(env, name, eq);
	else if (create_new_env(data, name, eq))
		return (1);
	return (0);
}

int	execute_export(t_ast *data, t_ast *tree, int fd_out)
{
	int		i;
	int		status;

	(void)fd_out;
	i = 1;
	status = 0;
	while (tree->cmd->args[i])
	{
		if (process_export_arg(data, tree->cmd->args[i]))
			status = 1;
		i++;
	}
	return (status);
}

### END OF FILE: ./env/env_export.c ###


### START OF FILE: ./env/env_unset.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static void	remove_env_node(t_ast *data, t_env *prev, t_env *curr)
{
	if (prev)
		prev->next = curr->next;
	else
		data->env_list = curr->next;
	free(curr->key);
	free(curr->value);
	free(curr);
}

static int	handle_unset_error(char *name)
{
	ft_putstr_fd("minishell: unset: `", STDERR_FILENO);
	ft_putstr_fd(name, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}

static int	process_unset_arg(t_ast *data, char *name)
{
	t_env	*prev;
	t_env	*curr;

	if (!is_valid_identifier(name))
		return (handle_unset_error(name));
	prev = NULL;
	curr = data->env_list;
	while (curr)
	{
		if (!ft_strcmp(curr->key, name))
		{
			remove_env_node(data, prev, curr);
			break ;
		}
		prev = curr;
		curr = curr->next;
	}
	return (0);
}

int	execute_unset(t_ast *data, t_ast *tree)
{
	int	i;

	i = 1;
	while (tree->cmd->args[i])
	{
		process_unset_arg(data, tree->cmd->args[i]);
		i++;
	}
	return (0);
}

### END OF FILE: ./env/env_unset.c ###


### START OF FILE: ./env/env_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/17 12:34:56 by user              #+#    #+#             */
/*   Updated: 2025/04/12 15:09:35 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>

char	*ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
	char	*tmp;
	char	*res;

	tmp = ft_strjoin(s1, s2);
	res = ft_strjoin(tmp, s3);
	free(tmp);
	return (res);
}

void	print_env_list(t_env *env_list, int fd_out)
{
	while (env_list)
	{
		ft_putstr_fd(env_list->key, fd_out);
		ft_putstr_fd("=", fd_out);
		if (env_list->value)
			ft_putendl_fd(env_list->value, fd_out);
		else
			ft_putendl_fd("", fd_out);
		env_list = env_list->next;
	}
}

static int	count_env_nodes(t_env *lst)
{
	int	count;

	count = 0;
	while (lst)
	{
		count++;
		lst = lst->next;
	}
	return (count);
}

char	**env(t_env **lst)
{
	t_env	*tmp;
	char	**envp;
	int		i;
	int		count;

	count = count_env_nodes(*lst);
	envp = malloc((count + 1) * sizeof(char *));
	if (!envp)
		return (NULL);
	tmp = *lst;
	i = 0;
	while (tmp)
	{
		envp[i++] = ft_strjoin3(tmp->key, "=", tmp->value);
		tmp = tmp->next;
	}
	envp[i] = NULL;
	return (envp);
}

void	create_new_shlvl(t_env *data, int shlvl)
{
	t_env	*new_env;

	new_env = malloc(sizeof(t_env));
	if (!new_env)
		return ;
	new_env->key = ft_strdup("SHLVL");
	new_env->value = ft_itoa(shlvl);
	new_env->next = data;
	data = new_env;
}

### END OF FILE: ./env/env_utils.c ###


### START OF FILE: ./env/env_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils copy.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/17 12:34:56 by user              #+#    #+#             */
/*   Updated: 2025/04/10 21:18:25 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>

void	incr_shell_lvl(t_env *data)
{
	char	*shlvl_str;
	int		shlvl;
	t_env	*tmp;

	shlvl_str = get_env_value(data, "SHLVL");
	shlvl = 0;
	if (shlvl_str)
		shlvl = ft_atoi(shlvl_str);
	shlvl++;
	tmp = data;
	while (tmp)
	{
		if (!ft_strcmp(tmp->key, "SHLVL"))
		{
			free(tmp->value);
			tmp->value = ft_itoa(shlvl);
			return ;
		}
		tmp = tmp->next;
	}
	create_new_shlvl(data, shlvl);
}

void	set_env_var(t_ast *data, char *var_name, const char *var_value)
{
	t_env	*env;
	t_env	*new_env;

	env = data->env_list;
	while (env)
	{
		if (!ft_strcmp(env->key, var_name))
		{
			free(env->value);
			env->value = ft_strdup(var_value);
			return ;
		}
		env = env->next;
	}
	new_env = malloc(sizeof(t_env));
	if (!new_env)
		return ;
	new_env->key = ft_strdup(var_name);
	new_env->value = ft_strdup(var_value);
	new_env->next = data->env_list;
	data->env_list = new_env;
}

t_env	*find_envir_variable(t_ast *data, char *var_name, int len)
{
	t_env	*current;

	current = data->env_list;
	while (current)
	{
		if (current->key && ft_strncmp(current->key, var_name, len) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

static char	*checker(t_ast *data, char *cmd, char ***paths_ptr)
{
	t_env	*path_env;

	if (ft_strchr(cmd, '/'))
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_env = find_envir_variable(data, "PATH", 4);
	if (!path_env || !path_env->value)
		return (NULL);
	*paths_ptr = ft_split(path_env->value, ':');
	if (!*paths_ptr)
		return (NULL);
	return (NULL);
}

char	*find_executable_path(t_ast *data, char *cmd)
{
	char	**paths = NULL;
	char	*full_path;
	char	*result;
	int		i;

	result = checker(data, cmd, &paths);
	if (result || !paths)
		return (result);
	i = -1;
	while (paths[++i])
	{
		full_path = ft_strjoin3(paths[i], "/", cmd);
		if (!full_path)
			continue ;
		if (access(full_path, X_OK) == 0)
		{
			free_2darray(paths);
			return (full_path);
		}
		free(full_path);
	}
	free_2darray(paths);
	return (NULL);
}

### END OF FILE: ./env/env_utils_2.c ###


### START OF FILE: ./execution/execute.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/10 21:21:04 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	execute_group(t_ast *data, t_ast *tree)
{
	pid_t	pid;
	int		status;
	int		ret;

	pid = fork();
	if (pid == 0)
	{
		ret = execute_tree(data, tree->left);
		exit(ret);
	}
	else if (pid < 0)
	{
		ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
		return (data->exit_status = 1);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		data->exit_status = WEXITSTATUS(status);
	else
		data->exit_status = 1;
	return (data->exit_status);
}

int	execute_sequence(t_ast *data, t_ast *tree)
{
	execute_tree(data, tree->left);
	return (execute_tree(data, tree->right));
}

int	execute_tree(t_ast *data, t_ast *tree)
{
	if (tree->type == AST_AND || tree->type == AST_OR)
	{
		if (tree->type == AST_AND)
			return (execute_and(data, tree));
		else
			return (execute_or(data, tree));
	}
	else if (tree->type == AST_PIPELINE)
	{
		return (execute_pipe(data, tree));
	}
	else if (tree->type == AST_SUBSHELL)
	{
		return (execute_group(data, tree));
	}
	else if (tree->type == AST_REDIR_IN || tree->type == AST_REDIR_OUT
		|| tree->type == AST_REDIR_APPEND)
		return ((tree->type == AST_REDIR_IN)
			? setup_input_fd(data, tree) : setup_output_fd(data, tree));
	else if (tree->type == AST_REDIR_HERDOC)
	{
		if (create_heredoc_temp_file(data, tree))
			return (data->exit_status);
		tree->type = AST_REDIR_IN;
		return (setup_input_fd(data, tree));
	}
	else if (tree->type == AST_AND || tree->type == AST_OR)
	{
		if (tree->type == AST_AND)
			return (execute_and(data, tree));
		else
			return (execute_or(data, tree));
	}
	else if (tree->type == AST_COMMAND)
	{
		return (execute_word(data, tree));
	}
	return (0);
}

### END OF FILE: ./execution/execute.c ###


### START OF FILE: ./execution/execute_external.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_external.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 13:27:09 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <errno.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

void	cleanup_parent_fds(int fd_inp, int fd_out)
{
	if (fd_inp != STDIN_FILENO)
		close(fd_inp);
	if (fd_out != STDOUT_FILENO)
		close(fd_out);
}

void	cleanup_heredoc_files(t_ast *data)
{
	int	i;

	i = -1;
	while (++i < data->heredoc_count)
	{
		unlink(data->heredoc_files[i]);
		free(data->heredoc_files[i]);
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
}

int	parent_process_handler(t_ast *data, pid_t pid, int fd_inp, int fd_out)
{
	int	status;

	cleanup_parent_fds(fd_inp, fd_out);
	waitpid(pid, &status, 0);
	cleanup_heredoc_files(data);
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}


### END OF FILE: ./execution/execute_external.c ###


### START OF FILE: ./execution/execute_external_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_external_utils.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 15:12:30 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <errno.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

void	setup_child_signals(void)
{
	signal(SIGINT, SIG_DFL);
	signal(SIGQUIT, SIG_DFL);
}

void	handle_redirection(int fd_inp, int fd_out)
{
	if (fd_inp != STDIN_FILENO)
	{
		if (dup2(fd_inp, STDIN_FILENO) == -1)
		{
			perror("minishell: dup2 input redirection");
			exit(1);
		}
		close(fd_inp);
	}
	if (fd_out != STDOUT_FILENO)
	{
		if (dup2(fd_out, STDOUT_FILENO) == -1)
		{
			perror("minishell: dup2 output redirection");
			exit(1);
		}
		close(fd_out);
	}
}

void	display_command_not_found(char *cmd)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(cmd, STDERR_FILENO);
	ft_putendl_fd(": command not found", STDERR_FILENO);
}

void	execute_child_process(t_ast *data, t_ast *tree)
{
	char	*cmd_path;
	char	**envp;

	cmd_path = find_executable_path(data, tree->cmd->args[0]);
	if (!cmd_path)
	{
		display_command_not_found(tree->cmd->args[0]);
		exit(127);
	}
	envp = env(&(data->env_list));
	execve(cmd_path, tree->cmd->args, envp);
	perror("minishell: execve");
	free_2darray(envp);
	exit(1);
}

void	child_process_handler(t_ast *data, t_ast *tree, int fd_inp, int fd_out)
{
	setup_child_signals();
	handle_redirection(fd_inp, fd_out);
	execute_child_process(data, tree);
}

### END OF FILE: ./execution/execute_external_utils.c ###


### START OF FILE: ./execution/execute_pipe.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/10 21:44:45 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

pid_t	fork_left_process(t_ast *data, t_ast *tree, int fd[2])
{
	pid_t	left_pid;

	left_pid = fork();
	if (left_pid == 0)
	{
		close(fd[0]);
		dup2(fd[1], STDOUT_FILENO);
		close(fd[1]);
		exit(execute_tree(data, tree->left));
	}
	else if (left_pid < 0)
	{
		perror("minishell: fork");
		return (-1);
	}
	return (left_pid);
}

pid_t	fork_right_process(t_ast *data, t_ast *tree, int fd[2])
{
	pid_t	right_pid;

	right_pid = fork();
	if (right_pid == 0)
	{
		close(fd[1]);
		dup2(fd[0], STDIN_FILENO);
		close(fd[0]);
		exit(execute_tree(data, tree->right));
	}
	else if (right_pid < 0)
	{
		perror("minishell: fork");
		return (-1);
	}
	return (right_pid);
}

int	handle_fork_error(t_ast *data, int fd[2], pid_t left_pid)
{
	close_pipe(fd);
	if (left_pid > 0)
		kill(left_pid, SIGTERM);
	return (data->exit_status = 1);
}

int	wait_for_processes(t_ast *data, pid_t left_pid, pid_t right_pid)
{
	int	left_status;
	int	right_status;

	waitpid(left_pid, &left_status, 0);
	waitpid(right_pid, &right_status, 0);
	if (WIFEXITED(right_status))
		data->exit_status = WEXITSTATUS(right_status);
	else
		data->exit_status = 1;
	return (data->exit_status);
}

int	execute_pipe(t_ast *data, t_ast *tree)
{
	int		fd[2];
	pid_t	left_pid;
	pid_t	right_pid;

	if (setup_pipe(fd) != 0)
		return (data->exit_status = 1);
	left_pid = fork_left_process(data, tree, fd);
	if (left_pid < 0)
		return (handle_fork_error(data, fd, 0));
	right_pid = fork_right_process(data, tree, fd);
	if (right_pid < 0)
		return (handle_fork_error(data, fd, left_pid));
	close_pipe(fd);
	return (wait_for_processes(data, left_pid, right_pid));
}

### END OF FILE: ./execution/execute_pipe.c ###


### START OF FILE: ./execution/execute_pipe_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_pipe copy.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/10 21:44:37 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

int	setup_pipe(int fd[2])
{
	if (pipe(fd) == -1)
	{
		perror("minishell: pipe");
		return (1);
	}
	return (0);
}

void	close_pipe(int fd[2])
{
	close(fd[0]);
	close(fd[1]);
}

### END OF FILE: ./execution/execute_pipe_utils.c ###


### START OF FILE: ./execution/exec_handling.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_handling.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/10 21:21:52 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

int	execute_and(t_ast *data, t_ast *tree)
{
	int	left_status;
	int	right_status;

	left_status = execute_tree(data, tree->left);
	if (left_status != 0)
	{
		data->exit_status = left_status;
		return (left_status);
	}
	right_status = execute_tree(data, tree->right);
	data->exit_status = right_status;
	return (right_status);
}

int	execute_or(t_ast *data, t_ast *tree)
{
	int	left_status;
	int	right_status;

	left_status = execute_tree(data, tree->left);
	if (left_status == 0)
	{
		data->exit_status = 0;
		return (0);
	}
	right_status = execute_tree(data, tree->right);
	data->exit_status = right_status;
	return (right_status);
}

### END OF FILE: ./execution/exec_handling.c ###


### START OF FILE: ./execution/exec_word/execute_word.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_word.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 13:24:36 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Fork new process for external command
int	fork_external_command(t_ast *data, t_ast *tree, int fd_in, int fd_out)
{
	pid_t	pid;

	pid = fork();
	if (pid < 0)
	{
		ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
		data->exit_status = 1;
		return (1);
	}
	if (pid == 0)
		execute_command(data, tree, fd_in, fd_out);
	else
		parent_process(pid, data);
	return (0);
}

// Function to set up file descriptors and validate them
static int	setup_fds(t_ast *data, t_ast *tree, int *fd_in, int *fd_out)
{
	*fd_in = setup_input_fd(data, tree);
	*fd_out = setup_output_fd(data, tree);
	if (*fd_in < 0 || *fd_out < 0)
	{
		close_fds(*fd_in, *fd_out);
		return (0);
	}
	return (1);
}

// Main function that orchestrates the execution
int	execute_word(t_ast *data, t_ast *tree)
{
	int		fd_in;
	int		fd_out;

	if (!setup_fds(data, tree, &fd_in, &fd_out))
		return (data->exit_status);
	if (handle_builtin(data, tree, fd_out))
	{
		return (data->exit_status);
	}
	fork_external_command(data, tree, fd_in, fd_out);
	return (data->exit_status);
}

### END OF FILE: ./execution/exec_word/execute_word.c ###


### START OF FILE: ./execution/exec_word/execute_word_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_word_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 13:14:40 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"


// Close file descriptors if they're not standard
void	close_fds(int fd_in, int fd_out)
{
	if (fd_in != STDIN_FILENO)
		close(fd_in);
	if (fd_out != STDOUT_FILENO)
		close(fd_out);
}

void	cleanup_resources(int fd_in, int fd_out, char **expanded_args)
{
	free_2darray(expanded_args);
	close_fds(fd_in, fd_out);
}

// Setup child process redirections
void	setup_child_redirections(int fd_in, int fd_out)
{
	if (fd_in != STDIN_FILENO)
	{
		dup2(fd_in, STDIN_FILENO);
		close(fd_in);
	}
	if (fd_out != STDOUT_FILENO)
	{
		dup2(fd_out, STDOUT_FILENO);
		close(fd_out);
	}
}

### END OF FILE: ./execution/exec_word/execute_word_utils.c ###


### START OF FILE: ./execution/exec_word/execute_word_utils2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   execute_word_utils2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 15:12:43 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

// Find command path and handle errors
char	*get_command_path(t_ast *data, char *cmd)
{
	char	*cmd_path;

	cmd_path = find_executable_path(data, cmd);
	if (!cmd_path)
	{
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putstr_fd(cmd, STDERR_FILENO);
		ft_putendl_fd(": command not found", STDERR_FILENO);
		exit(127);
	}
	return (cmd_path);
}

// Execute command in child process
void	execute_command(t_ast *data, t_ast *tree, int fd_in, int fd_out)
{
	char	*cmd_path;
	char	**envp;

	setup_child_redirections(fd_in, fd_out);
	setup_child_signals();
	cmd_path = get_command_path(data, tree->cmd->args[0]);
	envp = env(&(data->env_list));
	execve(cmd_path, tree->cmd->args, envp);
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putendl_fd(strerror(errno), STDERR_FILENO);
	free(cmd_path);
	free_2darray(envp);
	exit(126);
}

// Handle parent process waiting for child
int	parent_process(pid_t pid, t_ast *data)
{
	int	status;

	g_child_pid = pid;
	waitpid(pid, &status, 0);
	g_child_pid = 0;
	if (WIFEXITED(status))
		data->exit_status = WEXITSTATUS(status);
	else if (WIFSIGNALED(status))
		data->exit_status = 128 + WTERMSIG(status);
	else
		data->exit_status = 1;
	return (data->exit_status);
}

### END OF FILE: ./execution/exec_word/execute_word_utils2.c ###


### START OF FILE: ./execution/wildcards/expand_wildcard.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_wildcard.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/24 19:36:52 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 13:40:23 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"
#include <dirent.h>

char	**expand_wildcard(char *pattern)
{
	char	*dir_part;
	char	*file_part;
	DIR		*dir;
	char	**matches;
	int		count;

	split_pattern(pattern, &dir_part, &file_part);
	if (!has_wildcard(file_part) && !has_wildcard(dir_part))
	{
		free(dir_part);
		free(file_part);
		return (handle_no_wildcard(pattern));
	}
	dir = opendir(dir_part);
	if (!dir)
	{
		free(dir_part);
		free(file_part);
		return (NULL);
	}
	matches = process_dir_entries(dir, file_part, dir_part, &count);
	closedir(dir);
	free(dir_part);
	free(file_part);
	return (finalize_matches(matches, count));
}

void	add_arg_to_args(char ***new_args, int *new_count, char *arg)
{
	*new_args = realloc(*new_args, (*new_count + 1) * sizeof(char *));
	(*new_args)[*new_count] = ft_strdup(arg);
	(*new_count)++;
}

void	free_matches_array(char **matches)
{
	int	j;

	j = 0;
	while (matches[j])
	{
		free(matches[j]);
		j++;
	}
	free(matches);
}

char	**expand_wildcards_in_args(char **args)
{
	char	**new_args;
	int		new_count;

	new_args = NULL;
	new_count = 0;
	process_all_arguments(args, &new_args, &new_count);
	return (finalize_args_array(new_args, new_count));
}

int	is_hidden_file(char *pattern, const char *filename)
{
	return (filename[0] == '.' && (pattern[0] != '.' || ft_strcmp(pattern,
				".") == 0));
}

### END OF FILE: ./execution/wildcards/expand_wildcard.c ###


### START OF FILE: ./execution/wildcards/expand_wildcard_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_wildcard_utils.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/24 19:36:52 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 15:11:13 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"
#include <dirent.h>

int	match_pattern1(const char *pattern, const char *text)
{
	if (!pattern || !text)
		return (0);
	while (*pattern)
	{
		if (*pattern == '*')
		{
			pattern++;
			while (*text && !match_pattern1(pattern, text))
				text++;
		}
		else if (*pattern == '?' || *pattern == *text)
		{
			pattern++;
			text++;
		}
		else
		{
			return (0);
		}
	}
	return (*text == '\0');
}

int	has_wildcard(const char *str)
{
	return (ft_strchr(str, '*') != NULL);
}

void	split_pattern(const char *pattern, char **dir_part,
		char **file_part)
{
	char	*last_slash;

	last_slash = ft_strrchr(pattern, '/');
	if (last_slash)
	{
		*dir_part = ft_strndup(pattern, last_slash - pattern + 1);
		*file_part = ft_strdup(last_slash + 1);
	}
	else
	{
		*dir_part = ft_strdup(".");
		*file_part = ft_strdup(pattern);
	}
}

### END OF FILE: ./execution/wildcards/expand_wildcard_utils.c ###


### START OF FILE: ./execution/wildcards/expand_wildcard_utils2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_wildcard_utils2.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/24 19:36:52 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/12 13:46:47 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"
#include <dirent.h>

void	process_argument(char *arg, char ***new_args, int *new_count)
{
	char	**matches;
	int		j;

	matches = expand_wildcard(arg);
	if (!matches)
	{
		add_arg_to_args(new_args, new_count, arg);
	}
	else
	{
		j = 0;
		while (matches[j])
		{
			add_arg_to_args(new_args, new_count, matches[j]);
			j++;
		}
		free_matches_array(matches);
	}
}

void	process_all_arguments(char **args, char ***new_args, int *new_count)
{
	int	i;

	i = 0;
	while (args[i])
	{
		process_argument(args[i], new_args, new_count);
		i++;
	}
}

char	**finalize_args_array(char **args, int count)
{
	args = realloc(args, (count + 1) * sizeof(char *));
	args[count] = NULL;
	return (args);
}

char    **handle_no_wildcard(char *pattern)
{
    char    **result;

    result = malloc(2 * sizeof(char *));
    if (!result)
        return (NULL);
    result[0] = ft_strdup(pattern);
    if (!result[0])
    {
        free(result);
        return (NULL);
    }
    result[1] = NULL;
    return (result);
}

int    match_pattern(const char *pattern, const char *string)
{
    if (*pattern == '\0' && *string == '\0')
        return (1);
    if (*pattern == '*')
    {
        while (*(pattern + 1) == '*')
            pattern++;
        return (match_pattern(pattern + 1, string) || 
               (*string != '\0' && match_pattern(pattern, string + 1)));
    }
    if (*pattern == '?' || *pattern == *string)
        return (*string != '\0' && match_pattern(pattern + 1, string + 1));
    return (0);
}

char    **process_dir_entries(DIR *dir, char *file_part, char *dir_part, int *count)
{
    struct dirent   *entry;
    char            **matches;
    char            *full_path;

    matches = malloc(sizeof(char *));
    if (!matches)
        return (NULL);
    matches[0] = NULL;
    *count = 0;
    while ((entry = readdir(dir)) != NULL)
    {
        if (is_hidden_file(file_part, entry->d_name))
            continue;
        if (match_pattern(file_part, entry->d_name))
        {
            if (ft_strcmp(dir_part, "") == 0 || ft_strcmp(dir_part, "./") == 0 
                || ft_strcmp(dir_part, ".") == 0)
                full_path = ft_strdup(entry->d_name);
            else
            {
                full_path = malloc(ft_strlen(dir_part) + ft_strlen(entry->d_name) + 2);
                if (!full_path)
                    continue;
                ft_strcpy(full_path, dir_part);
                if (dir_part[ft_strlen(dir_part) - 1] != '/')
                    ft_strcat(full_path, "/");
                ft_strcat(full_path, entry->d_name);
            }
            matches = realloc(matches, (*count + 2) * sizeof(char *));
            if (!matches)
            {
                free(full_path);
                return (NULL);
            }
            matches[*count] = full_path;
            (*count)++;
            matches[*count] = NULL;
        }
    }
    return (matches);
}

char    **finalize_matches(char **matches, int count)
{
    int     i;
    int     j;
    char    *temp;

    if (count == 0)
    {
        free(matches);
        return (NULL);
    }
    for (i = 0; i < count - 1; i++)
    {
        for (j = i + 1; j < count; j++)
        {
            if (ft_strcmp(matches[i], matches[j]) > 0)
            {
                temp = matches[i];
                matches[i] = matches[j];
                matches[j] = temp;
            }
        }
    }
    return (matches);
}

### END OF FILE: ./execution/wildcards/expand_wildcard_utils2.c ###


### START OF FILE: ./redirections/heredoc.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ioctl.h>


/* push `path` into data->heredoc_files (O(1) amortised) */
int	add_heredoc_file(t_ast *data, char *path)
{
	char	**new;
	int		i;

	if (data->heredoc_count + 1 > data->heredoc_cap)
	{
		data->heredoc_cap = (data->heredoc_cap == 0) ? 4 : data->heredoc_cap * 2;
		new = (char **)malloc(sizeof(char *) * data->heredoc_cap);
		if (!new)
			return (1);
		i = -1;
		while (++i < data->heredoc_count)
			new[i] = data->heredoc_files[i];
		free(data->heredoc_files);
		data->heredoc_files = new;
	}
	data->heredoc_files[data->heredoc_count++] = path;
	return (0);
}

void	free_heredoc_list(t_ast *data)
{
	int i;

	i = -1;
	while (++i < data->heredoc_count)
		free(data->heredoc_files[i]);
	free(data->heredoc_files);
}

### END OF FILE: ./redirections/heredoc.c ###


### START OF FILE: ./redirections/redirection_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: you <you@student.42.fr>                     +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/05/22 14:09:00 by you               #+#    #+#             */
/*   Updated: 2025/05/22 14:09:00 by you              ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <fcntl.h>
#include <unistd.h>
#include <readline/readline.h>

/*
** < file
*/
int	setup_input_fd(t_ast *data, t_ast *node)
{
	int	save;
	int	fd;

	if (!node || !node->right || !node->right->token)
		return (data->exit_status = 1);
	fd = open(node->right->token->value, O_RDONLY);
	if (fd < 0)
		return (perror(node->right->token->value), data->exit_status = 1);
	save = dup(STDIN_FILENO);
	if (dup2(fd, STDIN_FILENO) < 0)
		return (close(fd), data->exit_status = 1);
	close(fd);
	data->exit_status = execute_tree(data, node->left);
	dup2(save, STDIN_FILENO);
	close(save);
	return (data->exit_status);
}

/*
** > file  |  >> file
*/
int	setup_output_fd(t_ast *data, t_ast *node)
{
	int	save;
	int	fd;
	int	flags;

	if (!node || !node->right || !node->right->token)
		return (data->exit_status = 1);
	flags = O_WRONLY | O_CREAT | (node->type == AST_REDIR_APPEND ? O_APPEND
			: O_TRUNC);
	fd = open(node->right->token->value, flags, 0644);
	if (fd < 0)
		return (perror(node->right->token->value), data->exit_status = 1);
	save = dup(STDOUT_FILENO);
	if (dup2(fd, STDOUT_FILENO) < 0)
		return (close(fd), data->exit_status = 1);
	close(fd);
	data->exit_status = execute_tree(data, node->left);
	dup2(save, STDOUT_FILENO);
	close(save);
	return (data->exit_status);
}

/*
** << DELIM  (builds a tmp file and stores its path in data->heredoc_name)
*/
int	create_heredoc_temp_file(t_ast *data, t_ast *node)
{
	char	tmp[] = "/tmp/minishell_heredocXXXXXX";
	char	*line;
	int		fd;

	fd = mkstemp(tmp);
	if (fd < 0)
		return (perror("mkstemp"), data->exit_status = 1);
	while (1)
	{
		line = readline("> ");
		if (!line || !ft_strcmp(line, node->token->value))
			break ;
		ft_putendl_fd(line, fd);
		free(line);
	}
	free(line);
	close(fd);
	/* Replace the DELIM token so later it’s treated as "< tmpfile" */
	free(node->token->value);
	node->token->value = ft_strdup(tmp);
	if (!node->token->value || add_heredoc_file(data, ft_strdup(tmp)))
		return (data->exit_status = 1);
	return (0);
}

### END OF FILE: ./redirections/redirection_utils.c ###


### START OF FILE: ./redirections/redirection_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirection_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/20 12:42:00 by user              #+#    #+#             */
/*   Updated: 2025/04/07 15:39:20 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void	print_error(char *filename, char *error_msg)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(filename, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putendl_fd(error_msg, STDERR_FILENO);
}

static void	find_last_output_redirection(t_ast *curr, char **file, int *type)
{
	while (curr)
	{
		if (curr->type == AST_REDIR_OUT || curr->type == AST_REDIR_APPEND)
		{
			*file = curr->token->value;
			*type = curr->type;
		}
		curr = curr->right;
	}
}

static int	open_output_file(char *filename, int redir_type)
{
	int	flags;
	int	fd;

	flags = O_WRONLY | O_CREAT;
	if (redir_type == AST_REDIR_OUT)
		flags |= O_TRUNC;
	else if (redir_type == AST_REDIR_APPEND)
		flags |= O_APPEND;
	fd = open(filename, flags, 0644);
	if (fd < 0)
		print_error(filename, strerror(errno));
	return (fd);
}

int	get_output_file(t_ast *tree)
{
	char	*last_file;
	int		redir_type;
	int		fd;

	last_file = NULL;
	redir_type = -1;
	fd = STDOUT_FILENO;
	find_last_output_redirection(tree->right, &last_file, &redir_type);
	if (last_file)
	{
		fd = open_output_file(last_file, redir_type);
		if (fd < 0)
			return (-1);
	}
	return (fd);
}

### END OF FILE: ./redirections/redirection_utils_2.c ###


### START OF FILE: ./signals/signals.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	handle_sigint(int signo)
{
	int	i;

	if (signo == SIGINT)
	{
		if (isatty(STDIN_FILENO))
		{
			i = write(1, "\n", 1);
			(void) i;
			if (g_child_pid == 42)
				g_child_pid = 44;
			if (g_child_pid != 0 && g_child_pid != 44)
			{
				kill(g_child_pid, SIGINT);
				g_child_pid++;
			}
			else
			{
				rl_on_new_line();
				rl_redisplay();
			}
		}
		else
			exit(EXIT_SUCCESS);
	}
}

void	handle_sigtstp_sigquit(int signo)
{
	if (signo == SIGTSTP || signo == SIGQUIT)
	{
		if (isatty(STDIN_FILENO))
		{
			if (g_child_pid == 0)
				rl_redisplay();
			else
			{
				kill(g_child_pid, signo);
				g_child_pid += 2;
			}
		}
	}
}

void	handle_c(int signo)
{
	handle_sigint(signo);
	handle_sigtstp_sigquit(signo);
}

int	handle_d(t_ast *data, char *line)
{
	(void)data;
	if (line == NULL)
	{
		rl_on_new_line();
		rl_redisplay();
	}
	if (ft_strlen(line) == 0)
	{
		ft_strdel(&line);
		return (1);
	}
	return (0);
}

### END OF FILE: ./signals/signals.c ###


### START OF FILE: ./signals/signals_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static void	sigint_handler(int sig)
{
	(void)sig;
	if (g_child_pid == 0)
	{
		ft_putstr_fd("\n", STDOUT_FILENO);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
	else
	{
		ft_putstr_fd("\n", STDOUT_FILENO);
		kill(g_child_pid, SIGINT);
	}
}

void	handle_signal(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sa_int.sa_handler = sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, NULL);
}

### END OF FILE: ./signals/signals_utils.c ###


### START OF FILE: ./utils/free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 12:54:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/08 14:45:33 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_token(t_token *token)
{
	t_token	*tmp;

	while (token)
	{
		tmp = token->next;
		free(token->value);
		free(token);
		token = tmp;
	}
}

void	free_heredoc_files(t_ast *data)
{
	int	i;

	if (!data->heredoc_files)
		return ;
	i = 0;
	while (i < data->heredoc_count)
	{
		if (data->heredoc_files[i])
		{
			unlink(data->heredoc_files[i]);
			free(data->heredoc_files[i]);
		}
		i++;
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
}

void	free_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->env_list)
		free_env_list(data->env_list);
	if (data->heredoc_files)
		free_heredoc_files(data);
	if (data)
		free_ast(data);
}

void	free_temp_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->token)
		free_token(data->token);
	free(data);
}

void	ft_strdel(char **as)
{
	if (as && *as)
	{
		free(*as);
		*as = NULL;
	}
}

### END OF FILE: ./utils/free.c ###


### START OF FILE: ./utils/utils4.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils4.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/20 12:42:00 by user              #+#    #+#             */
/*   Updated: 2025/04/12 13:51:19 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	*ft_realloc(void *ptr, size_t oldsize, size_t newsize)
{
	char	*newptr;

	newptr = malloc(newsize);
	if (!newptr)
		return (NULL);
	if (ptr)
	{
		ft_memcpy(newptr, ptr, oldsize);
		free(ptr);
	}
	return (newptr);
}

char	*ft_strndup(const char *s, size_t n)
{
	char	*dup;
	size_t	len;
	size_t	i;

	len = 0;
	while (len < n && s[len])
		len++;
	dup = (char *)malloc(sizeof(char) * (len + 1));
	if (!dup)
		return (NULL);
	i = 0;
	while (i < len)
	{
		dup[i] = s[i];
		i++;
	}
	dup[len] = '\0';
	return (dup);
}

void	free_2darray(char **array)
{
	int	i;

	i = -1;
	if (!array)
		return ;
	while (array[++i])
		ft_strdel(&array[i]);
	free(array);
}

char	*ft_strcpy(char *dest, const char *src)
{
	unsigned int i;

	i = 0;
	while (src[i] != '\0')
	{
		dest[i] = src[i];
		i++;
	}
	dest[i] = src[i];
	return (dest);
}

char	*ft_strcat(char *dest, const char *src)
{
	unsigned int	i;
	unsigned int	j;

	i = 0;
	while (dest[i] != '\0')
		++i;
	j = 0;
	while (src[j] != '\0')
	{
		dest[i] = src[j];
		i++;
		++j;
	}
	dest[i] = '\0';
	return (dest);
}
### END OF FILE: ./utils/utils4.c ###
