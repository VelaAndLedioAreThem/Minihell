

### START OF FILE: ./builtins/builtins.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	builtin_export(t_ast *data, t_ast *tree, int fd_out)
{
	if (!tree->cmd->args[1])
		print_env_list(data->env_list, fd_out);
	else
		execute_export(data, tree, fd_out);
	return (1);
}

static int	builtin_unset(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_unset(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_env(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	print_env_list(data->env_list, fd_out);
	return (1);
}

int	execute_home(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "HOME");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	return (0);
}

int	execute_oldpwd(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "OLDPWD");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: OLDPWD not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	ft_putendl_fd(path, STDOUT_FILENO);
	return (0);
}

static int	builtin_cd(t_ast *data, t_ast *tree, int fd_out)
{
	char	*path;
	char	*oldpwd;

	(void)fd_out;
	path = tree->cmd->args[1];
	oldpwd = getcwd(NULL, 0);
	if (!path || !ft_strcmp(path, "~"))
	{
		execute_home(data, path, oldpwd);
	}
	else if (!ft_strcmp(path, "-"))
	{
		execute_oldpwd(data, path, oldpwd);
	}
	if (execute_cd(data, path))
	{
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	set_env_var(data, "OLDPWD", oldpwd);
	free(oldpwd);
	return (1);
}

static int	builtin_pwd(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	if (execute_pwd(data, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_echo(t_ast *data, t_ast *tree, int fd_out)
{
	if (execute_echo(tree->cmd->args, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_exit(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_exit(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static const t_builtin	g_builtins[] = {
{"export", builtin_export},
{"unset", builtin_unset},
{"env", builtin_env},
{"cd", builtin_cd},
{"pwd", builtin_pwd},
{"echo", builtin_echo},
{"exit", builtin_exit},
	{NULL, NULL}
};

int	handle_builtin(t_ast *data, t_ast *tree, int fd_out)
{
	int	i;

	i = 0;
	if (!tree->cmd->args || !tree->cmd->args[0])
		return (0);
	while (g_builtins[i].name)
	{
		if (!ft_strcmp(tree->cmd->args[0], g_builtins[i].name))
			return (g_builtins[i].func(data, tree, fd_out));
		i++;
	}
	return (0);
}

### END OF FILE: ./builtins/builtins.c ###


### START OF FILE: ./builtins/builtins_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

bool	is_valid_identifier(const char *name)
{
	if (!name || !*name || ft_isdigit(*name))
		return (false);
	while (*name)
	{
		if (!ft_isalnum(*name) && *name != '_')
			return (false);
		name++;
	}
	return (true);
}

t_env	*get_env_node(t_env *env_list, const char *name)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (strcmp(current->key, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

static void	update_env_var(t_ast *data, const char *key, const char *value)
{
	t_env	*env;
	t_env	*new_env;

	env = get_env_node(data->env_list, key);
	if (env)
	{
		free(env->value);
		env->value = ft_strdup(value);
	}
	else
	{
		new_env = malloc(sizeof(t_env));
		new_env->key = ft_strdup(key);
		new_env->value = ft_strdup(value);
		new_env->next = data->env_list;
		data->env_list = new_env;
	}
}

int	execute_pwd(t_ast *data, int fd_out)
{
	char	*cwd;

	(void)data;
	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		ft_putendl_fd("minishell: pwd: error retrieving current directory",
			STDERR_FILENO);
		return (1);
	}
	ft_putendl_fd(cwd, fd_out);
	free(cwd);
	return (0);
}

int	execute_echo(char *args[], int fd_out)
{
	int	i;
	int	n_flag;

	i = 1;
	n_flag = 1;
	if (args[1] && !ft_strcmp(args[1], "-n"))
	{
		n_flag = 0;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], fd_out);
		if (args[i + 1])
			ft_putstr_fd(" ", fd_out);
		i++;
	}
	if (n_flag)
		ft_putendl_fd("", fd_out);
	return (0);
}

static int	handle_pwd_errors(char *old_pwd, int error_code)
{
	free(old_pwd);
	ft_putendl_fd(" error retrieving current directory", STDERR_FILENO);
	return (error_code);
}

static int	update_directory(t_ast *data, char *path, char *old_pwd)
{
	char	*new_pwd;

	if (chdir(path) != 0)
	{
		ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
		ft_putendl_fd(strerror(errno), STDERR_FILENO);
		free(old_pwd);
		return (1);
	}
	new_pwd = getcwd(NULL, 0);
	if (!new_pwd)
		return (handle_pwd_errors(old_pwd, 1));
	update_env_var(data, "OLDPWD", old_pwd);
	update_env_var(data, "PWD", new_pwd);
	free(old_pwd);
	free(new_pwd);
	return (0);
}

int	execute_cd(t_ast *data, char *path)
{
	char	*old_pwd;
	t_env	*home;

	old_pwd = getcwd(NULL, 0);
	if (!old_pwd)
		return (handle_pwd_errors(NULL, 1));
	if (!path)
	{
		home = get_env_node(data->env_list, "HOME");
		if (!home || !home->value)
		{
			ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
			free(old_pwd);
			return (1);
		}
		path = home->value;
	}
	return (update_directory(data, path, old_pwd));
}

static int	handle_export_error(char *arg)
{
	ft_putstr_fd("minishell: export: `", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}

static void	update_env_variable(t_env *env, char *name, char *eq)
{
	if (eq)
	{
		free(env->value);
		env->value = ft_strdup(eq + 1);
	}
	free(name);
}

int	create_new_env(t_ast *d, char *n, char *eq)
{
	t_env	*env;

	env = malloc(sizeof(t_env));
	if (!env)
		return (free(n), 1);
	env->key = n;
	if (eq)
		env->value = ft_strdup(eq + 1);
	else
		env->value = ft_strdup("");
	env->next = d->env_list;
	d->env_list = env;
	return (0);
}

static int	process_export_arg(t_ast *data, char *arg)
{
	char	*eq;
	char	*name;
	t_env	*env;

	eq = ft_strchr(arg, '=');
	if (eq)
		name = ft_substr(arg, 0, eq - arg);
	else
		name = ft_strdup(arg);
	if (!name || !is_valid_identifier(name))
		return (free(name), handle_export_error(arg));
	env = get_env_node(data->env_list, name);
	if (env)
		update_env_variable(env, name, eq);
	else if (create_new_env(data, name, eq))
		return (1);
	return (0);
}

int	execute_export(t_ast *data, t_ast *tree, int fd_out)
{
	int		i;
	int		status;

	(void)fd_out;
	i = 1;
	status = 0;
	while (tree->cmd->args[i])
	{
		if (process_export_arg(data, tree->cmd->args[i]))
			status = 1;
		i++;
	}
	return (status);
}

static int	handle_unset_error(char *name)
{
	ft_putstr_fd("minishell: unset: `", STDERR_FILENO);
	ft_putstr_fd(name, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}

static void	remove_env_node(t_ast *data, t_env *prev, t_env *curr)
{
	if (prev)
		prev->next = curr->next;
	else
		data->env_list = curr->next;
	free(curr->key);
	free(curr->value);
	free(curr);
}

static int	process_unset_arg(t_ast *data, char *name)
{
	t_env	*prev;
	t_env	*curr;

	if (!is_valid_identifier(name))
		return (handle_unset_error(name));
	prev = NULL;
	curr = data->env_list;
	while (curr)
	{
		if (!ft_strcmp(curr->key, name))
		{
			remove_env_node(data, prev, curr);
			break ;
		}
		prev = curr;
		curr = curr->next;
	}
	return (0);
}

int	execute_unset(t_ast *data, t_ast *tree)
{
	int	i;

	i = 1;
	while (tree->cmd->args[i])
	{
		process_unset_arg(data, tree->cmd->args[i]);
		i++;
	}
	return (0);
}

int	execute_exit(t_ast *data, t_ast *tree)
{
	int	status;

	status = 0;
	if (tree->cmd->args[1])
		status = ft_atoi(tree->cmd->args[1]);
	free_data(data);
	exit (status);
	return (0);
}

### END OF FILE: ./builtins/builtins_utils.c ###


### START OF FILE: ./builtins/heredoc_utils.c ###

#include "minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ioctl.h>

static	void	handle_sigint(int sig, siginfo_t *info, void *context)
{
	(void)sig;
	(void)info;
	(void)context;
	ioctl(STDIN_FILENO, TIOCSTI, "\n");
}

static void	configure_signals(t_signal *sig)
{
	sig->sa_new.sa_sigaction = handle_sigint;
	sigemptyset(&sig->sa_new.sa_mask);
	sig->sa_new.sa_flags = SA_SIGINFO;
	sigaction(SIGINT, &sig->sa_new, &sig->sa_old);
}

static int	process_input_loop(int fd, char *delimiter, t_signal *sig)
{
	char	*line;

	while (!sig->sigint)
	{
		line = readline("> ");
		if (!line)
		{
			ft_putstr_fd("minishell: warning: here-doc delimited by EOF\n", 2);
			break ;
		}
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		dprintf(fd, "%s\n", line);
		free(line);
	}
	return (sig->sigint ? -1 : 0);
}

int	create_heredoc_temp_file(char *delimiter, t_ast *data)
{
	t_signal	sig;
	char		*tmpname;
	int			fd;

	tmpname = "/tmp/minishell_heredoc_XXXXXX";
	fd = mkstemp(tmpname);
	if (fd < 0)
		return (-1);
	configure_signals(&sig);
	data->heredoc_files = realloc(data->heredoc_files,
			sizeof(char *) * (data->heredoc_count + 1));
	data->heredoc_files[data->heredoc_count] = ft_strdup(tmpname);
	data->heredoc_count++;
	if (process_input_loop(fd, delimiter, &sig) == -1)
		return (-1);
	sigaction(SIGINT, &sig.sa_old, NULL);
	close(fd);
	return (open(tmpname, O_RDONLY));
}

### END OF FILE: ./builtins/heredoc_utils.c ###


### START OF FILE: ./builtins/redirection_utils.c ###

#include "minishell.h"
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
// Updated get_input_file() in redirection_utils.c
int get_input_file(t_ast *data, t_ast *tree) {
    t_ast *curr = tree;
    char *last_red_inp = NULL;
    char *last_heredoc_delim = NULL;
    int heredoc_fd = -1;
    int fd = STDIN_FILENO;

    while (curr) {
        if (curr->type == AST_REDIR_IN) {
            last_red_inp = curr->token->value;
        } else if (curr->type == AST_EOF) {
            last_heredoc_delim = curr->token->value;
            heredoc_fd = create_heredoc_temp_file(last_heredoc_delim, data);
            if (heredoc_fd < 0) return -1;
            fd = heredoc_fd;
        }
        if (curr->left) {
            int left_fd = get_input_file(data, curr->left);
            if (left_fd != STDIN_FILENO) fd = left_fd;
        }
        curr = curr->right;
    }

    if (!last_heredoc_delim && last_red_inp) {
        fd = open(last_red_inp, O_RDONLY);
        if (fd < 0) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(last_red_inp, STDERR_FILENO);
            ft_putstr_fd(": ", STDERR_FILENO);
            ft_putendl_fd(strerror(errno), STDERR_FILENO);
            return -1;
        }
    }
    return fd;
}
int get_output_file(t_ast *tree) {
    t_ast *curr = tree->right; // Start with right child
    char *last_file = NULL;
    int redir_type = -1;
    int fd = STDOUT_FILENO;

    while (curr) {
        if (curr->type == AST_REDIR_OUT || curr->type == AST_REDIR_APPEND) {
            last_file = curr->token->value;
            redir_type = curr->type;
        }
        curr = curr->right; // Traverse right children
    }

    if (last_file) {
        int flags = O_WRONLY | O_CREAT;
        if (redir_type == AST_REDIR_OUT)
            flags |= O_TRUNC;
        else if (redir_type == AST_REDIR_APPEND)
            flags |= O_APPEND;

        fd = open(last_file, flags, 0644);
        if (fd < 0) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(last_file, STDERR_FILENO);
            ft_putstr_fd(": ", STDERR_FILENO);
            ft_putendl_fd(strerror(errno), STDERR_FILENO);
            return -1;
        }
    }
    return fd;
}
### END OF FILE: ./builtins/redirection_utils.c ###


### START OF FILE: ./execution/execute.c ###

#include "minishell.h"


int execute_group(t_ast *data, t_ast *tree)
{
    pid_t pid;
    int status;

    pid = fork();
    if (pid == 0)
    {
        int ret = execute_tree(data, tree->left);
        exit(ret);
    }
    else if (pid < 0)
    {
        ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
        return (data->exit_status = 1);
    }
    waitpid(pid, &status, 0);
    if (WIFEXITED(status))
        data->exit_status = WEXITSTATUS(status);
    else
        data->exit_status = 1;
    return data->exit_status;
}


int execute_sequence(t_ast *data, t_ast *tree)
{
    execute_tree(data, tree->left);
    return execute_tree(data, tree->right);
}

int execute_tree(t_ast *data,t_ast *tree)
{
    if (tree->type == AST_AND || tree->type == 	AST_OR)
    {
        if (tree->type == AST_AND)
            return execute_and(data, tree);
        else
            return execute_or(data, tree);
    }
    else if (tree->type == AST_PIPELINE)
    {
        return execute_pipe(data, tree);
    }
    else if (tree->type == AST_SUBSHELL)
    {
        return execute_group(data, tree);
    }
    else if (tree->type == AST_COMMAND)
    {
        return execute_word(data, tree);
    }
    return 0;
}

### END OF FILE: ./execution/execute.c ###


### START OF FILE: ./execution/execute_external.c ###

#include "minishell.h"
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

/* Execute an external command with proper redirections */
int execute_command(t_ast *data, t_ast *tree, int fd_inp, int fd_out)
{
    pid_t pid;
    int status;


    pid = fork();
    if (pid == 0) {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        
        // Handle input redirection
        if (fd_inp != STDIN_FILENO) {
            if (dup2(fd_inp, STDOUT_FILENO) == -1) {
                perror("minishell: dup2 input redirection");
                exit(1);
            }
            close(fd_inp);
        }
        
        // Handle output redirection
        if (fd_out != STDOUT_FILENO) {
            if (dup2(fd_out, STDOUT_FILENO) == -1) {
                perror("minishell: dup2 output redirection");
                exit(1);
            }
            close(fd_out);
        }
        
        // Execute command
        char *cmd_path = find_executable_path(data, tree->cmd->args[0]);
        if (!cmd_path) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
            ft_putendl_fd(": command not found", STDERR_FILENO);
            exit(127);
        }
        
        char **envp = env(&(data->env_list));
        execve(cmd_path, tree->cmd->args, envp);
        perror("minishell: execve");
        free_2darray(envp);
        exit(1);
    }
    
    // Parent process
    if (fd_inp != STDIN_FILENO)
        close(fd_inp);
    if (fd_out != STDOUT_FILENO)
        close(fd_out);
        
    waitpid(pid, &status, 0);
    
    // Cleanup heredoc files
    for (int i = 0; i < data->heredoc_count; i++) {
        unlink(data->heredoc_files[i]);
        free(data->heredoc_files[i]);
    }
    free(data->heredoc_files);
    data->heredoc_files = NULL;
    data->heredoc_count = 0;
    
    if (WIFEXITED(status))
        return WEXITSTATUS(status);
    return 1;
}

### END OF FILE: ./execution/execute_external.c ###


### START OF FILE: ./execution/execute_pipe.c ###

#include "minishell.h"
/* Execute a pipe command */int execute_pipe(t_ast *data, t_ast *tree) {
    int fd[2];
    pid_t left_pid, right_pid;
    int left_status, right_status;

    if (pipe(fd) == -1) {
        perror("minishell: pipe");
        return (data->exit_status = 1);
    }

    // Fork for left command
    left_pid = fork();
    if (left_pid == 0) {
        // Child process for left command
        close(fd[0]);
        dup2(fd[1], STDOUT_FILENO);
        close(fd[1]);
        
        // Execute left side of pipe
        exit(execute_tree(data, tree->left));
    } else if (left_pid < 0) {
        perror("minishell: fork");
        close(fd[0]);
        close(fd[1]);
        return (data->exit_status = 1);
    }

    // Fork for right command
    right_pid = fork();
    if (right_pid == 0) {
        // Child process for right command
        close(fd[1]);
        dup2(fd[0], STDIN_FILENO);
        close(fd[0]);
        
        // Execute right side of pipe
        exit(execute_tree(data, tree->right));
    } else if (right_pid < 0) {
        perror("minishell: fork");
        close(fd[0]);
        close(fd[1]);
        kill(left_pid, SIGTERM); // Cleanup left child
        return (data->exit_status = 1);
    }

    // Parent process
    close(fd[0]);
    close(fd[1]);

    waitpid(left_pid, &left_status, 0);
    waitpid(right_pid, &right_status, 0);

    // Set exit status to the right child's exit code (last command)
    if (WIFEXITED(right_status))
        data->exit_status = WEXITSTATUS(right_status);
    else
        data->exit_status = 1;

    return data->exit_status;
}
### END OF FILE: ./execution/execute_pipe.c ###


### START OF FILE: ./execution/execute_word.c ###

#include "minishell.h"

int execute_word(t_ast *data, t_ast *tree)
{
    
    // Get input and output file descriptors
    int fd_in = get_input_file(data, tree);
    int fd_out = get_output_file(tree);
    
    if (fd_in < 0 || fd_out < 0)
    {
        if (fd_in > 0 && fd_in != STDIN_FILENO)
            close(fd_in);
        if (fd_out > 0 && fd_out != STDOUT_FILENO)
            close(fd_out);
        data->exit_status = 1;
        return 1;
    }

    char **expanded_args = expand_wildcards_in_args(tree->cmd->args);
    if (!expanded_args) {
        close(fd_in);
        close(fd_out);
        return (data->exit_status = 1);
    }

    char **original_args = tree->cmd->args;
    tree->cmd->args = expanded_args;
    // Try to execute as builtin
    if (handle_builtin(data, tree, fd_out))
    {
        tree->cmd->args = original_args;
        free_2darray(expanded_args);
        if (fd_in != STDIN_FILENO)
            close(fd_in);
        if (fd_out != STDOUT_FILENO)
            close(fd_out);
        return data->exit_status;
    }
    
    // Execute as external command
    pid_t pid = fork();
    if (pid < 0)
    {
        ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
        data->exit_status = 1;
    }
    if (pid == 0)
    {
        // Child process
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        
        // Set up redirections
        if (fd_in != STDIN_FILENO)
        {
            dup2(fd_in, STDIN_FILENO);
            close(fd_in);
        }
        if (fd_out != STDOUT_FILENO)
        {
            dup2(fd_out, STDOUT_FILENO);
            close(fd_out);
        }
        
        // Execute command
        char *cmd_path = find_executable_path(data, tree->cmd->args[0]);
        if (!cmd_path) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
            ft_putendl_fd(": command not found", STDERR_FILENO);
            exit(127);
        }
        
        
        char **envp = env(&(data->env_list));
        execve(cmd_path, tree->cmd->args, envp);
        
        // If execve returns, there was an error
        ft_putstr_fd("minishell: ", STDERR_FILENO);
        ft_putendl_fd(strerror(errno), STDERR_FILENO);
        free(cmd_path);
        free_2darray(envp);
        exit(126);
    } 
    else
    {
        // Parent process
        int status;
        g_child_pid = pid;
        waitpid(pid, &status, 0);
        g_child_pid = 0; // Reset after child exi
        if (WIFEXITED(status))
            data->exit_status = WEXITSTATUS(status);
        else if (WIFSIGNALED(status))
            data->exit_status = 128 + WTERMSIG(status);
        else
            data->exit_status = 1;
    }
    tree->cmd->args = original_args;
    free_2darray(expanded_args);
    // Clean up file descriptors
    if (fd_in != STDIN_FILENO)
        close(fd_in);
    if (fd_out != STDOUT_FILENO)
        close(fd_out);
    
    return data->exit_status;
}

### END OF FILE: ./execution/execute_word.c ###


### START OF FILE: ./execution/exec_handling.c ###

#include "../../include/minishell.h"


int execute_and(t_ast *data, t_ast *tree)
{
    int left_status = execute_tree(data, tree->left);
    if (left_status != 0)
    {
        data->exit_status = left_status;
        return left_status;
    }
    int right_status = execute_tree(data, tree->right);
    data->exit_status = right_status;
    return right_status;
}


int execute_or(t_ast *data, t_ast *tree)
{
    int left_status = execute_tree(data, tree->left);
    if (left_status == 0)
    {
        data->exit_status = 0;
        return 0;
    }
    int right_status = execute_tree(data, tree->right);
    data->exit_status = right_status;
    return right_status;
}



### END OF FILE: ./execution/exec_handling.c ###


### START OF FILE: ./execution/expand_wildcard.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_wildcard.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/24 19:36:52 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/24 19:37:27 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

#include <dirent.h>


int match_pattern(const char *pattern, const char *text)
{
    if (!pattern || !text) return 0;
    
    while (*pattern)
    {
        if (*pattern == '*')
        {
            pattern++;
            while (*text && !match_pattern(pattern, text))
                text++;
        }
        else if (*pattern == '?' || *pattern == *text)
        {
            pattern++;
            text++;
        }
        else
        {
            return 0;
        }
    }
    return *text == '\0';
}

static int has_wildcard(const char *str) {
    return (ft_strchr(str, '*') != NULL);
}

static void split_pattern(const char *pattern, char **dir_part, char **file_part)
{
    char *last_slash = ft_strrchr(pattern, '/');
    
    if (last_slash)
    {
        *dir_part = ft_strndup(pattern, last_slash - pattern + 1);
        *file_part = ft_strdup(last_slash + 1);
    }
    else
    {
        *dir_part = ft_strdup(".");
        *file_part = ft_strdup(pattern);
    }
}

static char *build_full_path( char *dir, const char *file)
{
    if (ft_strcmp(dir, ".") == 0)
        return ft_strdup(file);
    if (dir[ft_strlen(dir)-1] == '/')
        return ft_strjoin(dir, file);
    return ft_strjoin3(dir, "/", file);
}

static void sort_matches(char **matches, int count) {
    int i, j;
    char *temp;

    for (i = 0; i < count - 1; i++) {
        for (j = i + 1; j < count; j++) {
            if (ft_strcmp(matches[i], matches[j]) > 0) {
                temp = matches[i];
                matches[i] = matches[j];
                matches[j] = temp;
            }
        }
    }
}

static int is_hidden_file(char *pattern, const char *filename) {
    return (filename[0] == '.' && (pattern[0] != '.' || ft_strcmp(pattern, ".") == 0));
}

char **expand_wildcard(char *pattern) {
    char *dir_part;
    char *file_part;
    DIR *dir;
    struct dirent *entry;

    split_pattern(pattern, &dir_part, &file_part);
    
    if (!has_wildcard(file_part) && !has_wildcard(dir_part))
    {
        free(dir_part);
        free(file_part);
        char **result = ft_calloc(2, sizeof(char *));
        result[0] = ft_strdup(pattern);
        return result;
    }

    dir = opendir(dir_part);
    if (!dir)
    {
        free(dir_part);
        free(file_part);
        return NULL;
    }

    char **matches = NULL;
    int count = 0;
    
    while ((entry = readdir(dir)) != NULL)
    {
        if (is_hidden_file(file_part, entry->d_name))
            continue;
        if (match_pattern(file_part, entry->d_name))
        {
            char *full_path = build_full_path(dir_part, entry->d_name);
            matches = realloc(matches, (count + 1) * sizeof(char *));
            matches[count++] = full_path;
        }
    }
    closedir(dir);

    if (count == 0) {
        free(matches);
        matches = NULL;
    } else {
        sort_matches(matches, count);
        matches = realloc(matches, (count + 1) * sizeof(char *));
        matches[count] = NULL;
    }

    free(dir_part);
    free(file_part);
    return matches;
}

char **expand_wildcards_in_args(char **args) {
    char **new_args = NULL;
    int new_count = 0;

    for (int i = 0; args[i]; i++) {
        char **matches = expand_wildcard(args[i]);
        if (!matches) {
            new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
            new_args[new_count++] = ft_strdup(args[i]);
        } else {
            for (int j = 0; matches[j]; j++) {
                new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
                new_args[new_count++] = ft_strdup(matches[j]);
            }
            for (int j = 0; matches[j]; j++) free(matches[j]);
            free(matches);
        }
    }
    new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
    new_args[new_count] = NULL;
    return new_args;
}
### END OF FILE: ./execution/expand_wildcard.c ###


### START OF FILE: ./signals/signals.c ###


#include "../../../include/minishell.h"

static void sigint_handler(int sig) {
	(void)sig;
	if (g_child_pid == 0) {
		// Interactive shell: handle Ctrl+C
		ft_putstr_fd("\n", STDOUT_FILENO);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	} else {
		// Child process is running: forward SIGINT and avoid prompt redisplay
		ft_putstr_fd("\n", STDOUT_FILENO);
		kill(g_child_pid, SIGINT);
	}
}
void	handle_signal(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	// Setup SIGINT handler
	sa_int.sa_handler = sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);

	// Ignore SIGQUIT in the parent shell
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, NULL);
}
void	handle_sigint(int signo)
{
	if (signo == SIGINT)
	{
		if (isatty(STDIN_FILENO))
		{
			int i = write(1, "\n", 1);
			(void) i;
			if (g_child_pid == 42)
				g_child_pid = 44;
			if (g_child_pid != 0 && g_child_pid != 44)
			{
				kill(g_child_pid, SIGINT);
				g_child_pid++;
			}
			else
			{
				rl_on_new_line();
				rl_redisplay();
			}
		}
		else
			exit(EXIT_SUCCESS);
	}
}

void	handle_sigtstp_sigquit(int signo)
{
	if (signo == SIGTSTP || signo == SIGQUIT)
	{
		if (isatty(STDIN_FILENO))
		{
			if (g_child_pid == 0)
				rl_redisplay();
			else
			{
				kill(g_child_pid, signo);
				g_child_pid += 2;
			}
		}
	}
}

void	handle_c(int signo)
{
	handle_sigint(signo);
	handle_sigtstp_sigquit(signo);
}

int	handle_d(t_ast *data, char *line)
{
	(void)data;
	if (line == NULL)
	{
		rl_on_new_line();
		rl_redisplay();
	}
	if (ft_strlen(line) == 0)
	{
		ft_strdel(&line);
		return (1);
	}
	return (0);
}

### END OF FILE: ./signals/signals.c ###


### START OF FILE: ./utils/asterisk_utils.c ###

#include "minishell.h"


int is_only_asterisks(char *str)
{
    int i = 0;
    if (!str)
        return 0;
    while (str[i])
    {
        if (str[i] != '*')
            return 0;
        i++;
    }
    return 1;
}

### END OF FILE: ./utils/asterisk_utils.c ###


### START OF FILE: ./utils/env_utils.c ###

#include "../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>

// Add this to your utils if missing

char *ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
    char *tmp = ft_strjoin(s1, s2);
    char *res = ft_strjoin(tmp, s3);
    free(tmp);
    return res;
}


// Updated print_env_list
void print_env_list(t_env *env_list, int fd_out)
{
    while (env_list)
    {
        ft_putstr_fd(env_list->key, fd_out);       // Changed var_name->key
        ft_putstr_fd("=", fd_out);
        ft_putendl_fd(env_list->value ? env_list->value : "", fd_out); // Changed var_value->value
        env_list = env_list->next;
    }
}

// Fixed env function
char **env(t_env **lst)
{
    t_env *tmp = *lst;
    int count = 0;
    
    // Count all environment entries
    while (tmp) {
        count++;
        tmp = tmp->next;
    }

    char **envp = malloc((count + 1) * sizeof(char *));
    tmp = *lst;
    int i = 0;
    while (tmp) {
        envp[i++] = ft_strjoin3(tmp->key, "=", tmp->value); // Updated member names
        tmp = tmp->next;
    }
    envp[i] = NULL;
    return envp;
}

// Updated environment variable functions
void incr_shell_lvl(t_ast *data)
{
    char *shlvl_str = get_env_value(data->env_list, "SHLVL");
    int shlvl = 0;
    
    if (shlvl_str)
        shlvl = ft_atoi(shlvl_str);
    shlvl++;

    t_env *tmp = data->env_list;
    while (tmp)
    {
        if (!ft_strcmp(tmp->key, "SHLVL"))  // Changed var_name->key
        {
            free(tmp->value);
            tmp->value = ft_itoa(shlvl);    // Changed var_value->value
            return;
        }
        tmp = tmp->next;
    }
    
    // Create new SHLVL entry if missing
    t_env *new_env = malloc(sizeof(t_env));
    if (new_env)
    {
        new_env->key = ft_strdup("SHLVL");
        new_env->value = ft_itoa(shlvl);
        new_env->next = data->env_list;
        data->env_list = new_env;
    }
}
void set_env_var(t_ast *data, char *var_name, const char *var_value)
{
    t_env *env = data->env_list;
    while (env)
    {
        if (!ft_strcmp(env->key, var_name))
        {
            free(env->value);
            env->value = ft_strdup(var_value);
            return;
        }
        env = env->next;
    }
    t_env *new_env = malloc(sizeof(t_env));
    if (!new_env)
        return;
    new_env->key = ft_strdup(var_name);
    new_env->value = ft_strdup(var_value);
    new_env->next = data->env_list;
    data->env_list = new_env;
}

void	free_paths(char **paths, char **original_paths)
{
	paths = original_paths;
	while (*paths)
	{
		ft_strdel(paths);
		paths++;
	}
	free(original_paths);
}
char *duplicate_cmd_and_free_paths(char *cmd, char **paths)
{
    char *result = ft_strdup(cmd);
    free_paths(paths, paths);
    return result;
}

t_env *find_envir_variable(t_ast *data, char *var_name, int len)
{
    t_env *current;

    current = data->env_list;
    while (current)
    {
        if (current->key && ft_strncmp(current->key, var_name, len) == 0)
            return (current);
        current = current->next;
    }
    return (NULL);
}

char *find_executable_path(t_ast *data, char *cmd)
{
    // If cmd contains a slash, it's likely a full or relative path
    if (ft_strchr(cmd, '/')) {
        if (access(cmd, X_OK) == 0)
            return ft_strdup(cmd);
        return NULL;
    }

    // Check for absolute PATH
    t_env *path_env = find_envir_variable(data, "PATH", 4);
    if (!path_env || !path_env->value)
        return NULL;

    char **paths = ft_split(path_env->value, ':');
    char **original_paths = paths;

    while (*paths)
    {
        char *full_path = ft_strjoin3(*paths, "/", cmd);
        if (access(full_path, X_OK) == 0)
        {
            // Free other paths
            char **temp = original_paths;
            while (*temp)
            {
                if (temp != paths)
                    free(*temp);
                temp++;
            }
            free(original_paths);
            return full_path;
        }
        free(full_path);
        paths++;
    }

    // Free split paths if no match found
    free_paths(original_paths, original_paths);
    return NULL;
}
### END OF FILE: ./utils/env_utils.c ###


### START OF FILE: ./utils/free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 12:54:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 12:54:56 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_token(t_token *token)
{
	t_token	*tmp;

	while (token)
	{
		tmp = token->next;
		free(token->value);
		free(token);
		token = tmp;
	}
}

void	free_heredoc_files(t_ast *data)
{
	int	i;

	if (!data->heredoc_files)
		return ;
	i = 0;
	while (i < data->heredoc_count)
	{
		if (data->heredoc_files[i])
		{
			unlink(data->heredoc_files[i]);
			free(data->heredoc_files[i]);
		}
		i++;
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
}
void	free_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->env_list)
		free_env_list(data->env_list);
	if (data->heredoc_files)
		free_heredoc_files(data);
	if (data)
		free_ast(data);
}

void	free_temp_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->token)
		free_token(data->token);
	free(data);
}



void	ft_strdel(char **as)
{
	if (as && *as)
	{
		free(*as);
		*as = NULL;
	}
}
### END OF FILE: ./utils/free.c ###


### START OF FILE: ./utils/free2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:04:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:04:56 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

// Keep this utility function as is
void	free_2darray(char **array)
{
	int	i;

	i = -1;
	if (!array)
		return ;
	while (array[++i])
		ft_strdel(&array[i]);
	free(array);
}

### END OF FILE: ./utils/free2.c ###


### START OF FILE: ./utils/utils4.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils4.c                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ipetruni <ipetruni@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/23 12:55:49 by ipetruni          #+#    #+#             */
/*   Updated: 2023/11/23 13:06:47 by ipetruni         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"


void *ft_realloc(void *ptr, size_t old_size, size_t new_size) {
    void *new_ptr = malloc(new_size);
    if (!new_ptr)
        return NULL;

    if (ptr) {
        size_t copy_size = old_size < new_size ? old_size : new_size;
        memcpy(new_ptr, ptr, copy_size);
        free(ptr);
    }

    return new_ptr;
}

char	*ft_strndup(const char *s, size_t n)
{
	char	*dup;
	size_t	len;
	size_t	i;

	len = 0;
	while (len < n && s[len])
		len++;
	dup = (char *)malloc(sizeof(char) * (len + 1));
	if (!dup)
		return (NULL);
	i = 0;
	while (i < len)
	{
		dup[i] = s[i];
		i++;
	}
	dup[len] = '\0';
	return (dup);
}

### END OF FILE: ./utils/utils4.c ###
