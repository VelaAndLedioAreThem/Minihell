

### START OF FILE: ./include/minishell.h ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 01:04:11 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 16:06:53 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#ifndef MINISHELL_H
# define MINISHELL_H

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <fcntl.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <sys/stat.h>
# include <signal.h>
# include <dirent.h>
# include <string.h>
# include <errno.h>
# include <termios.h>
# include <curses.h>
# include <term.h>
# include <sys/ioctl.h>
# include <readline/readline.h>
# include <readline/history.h>
# include "../libft/include/libft.h"
# define TOKEN_PROCESSED 42
# define TOKEN_READWRITE 43

// Parsing struct 
typedef enum e_token_type
{
	TOKEN_WORD,
	TOKEN_PIPE,
	TOKEN_REDIRECT_IN,
	TOKEN_REDIRECT_OUT,
	TOKEN_APPEND,
	TOKEN_HEREDOC,
	TOKEN_AND,
	TOKEN_OR,
	TOKEN_PAREN_OPEN,
	TOKEN_PAREN_CLOSE,
	TOKEN_EOF,
	TOKEN_WILDCARD,
	TOKEN_WHITESPACE
}	t_token_type;

typedef struct s_env
{
	char			*key;
	char			*value;
	struct s_env	*next;
}	t_env;

typedef struct s_quote
{
	bool			in_single_quotes;
	bool			in_double_quotes;
}	t_quotes;

// Parenthesis struct
typedef struct s_open_paren
{
	bool			has_commands;
	bool			expecting_commands;
	int				i;
}	t_open_paren;

typedef struct s_paren
{
	bool			has_commands;
	bool			has_content;
	char			last_op;
	bool			has_cmd_before;
	int				j;
	bool			has_operator;
	t_quotes		quote;
}	t_paren;

// Commands struct
typedef struct s_cmd
{
	bool		in_commands;
	bool		is_cmd_pos;
}	t_cmd;

typedef struct s_stack
{
	char			name;
	struct s_stack	*next;
}	t_stack;

typedef struct s_token
{
	char			*value;
	t_token_type	type;
	int				expandable;
	int				double_quotes;
	int				single_quotes;
	t_stack			*top;
	struct s_token	*next;
}	t_token;

typedef struct s_pipe
{
	t_token		*curr;
	t_token		*prev;
	t_token		*head;
	bool		expecting_command;
}	t_pipe;

typedef struct s_nest
{
	bool			success;
	t_token			*token;
	int				position;
}	t_nest;

typedef struct s_state
{
	t_quotes		quote;
	t_token			*token;
	int				pos;
	int				paren_count;
}	t_state;

typedef enum e_ast_type
{
	AST_COMMAND,
	AST_PIPELINE,
	AST_REDIR_IN,
	AST_REDIR_OUT,
	AST_REDIR_APPEND,
	AST_REDIR_HERDOC,
	AST_AND,
	AST_OR,
	AST_SUBSHELL
}	t_ast_type;

// Erorrs Messages
typedef enum e_errors_code
{
	ERR_NONE,
	ERR_UNBALANCED_PAREN,
	ERR_SYNTAX,
	ERR_UNEXPECTED_TOKEN,
	ERR_MEMORY,
	ERR_PARSE
}	t_errors_code;

typedef struct s_command
{
	char			**args;
	char			*infile;
	char			*outfile;
	char			*heredoc_delim;
	int				append;
	int				is_builtin;
}	t_commands;

typedef struct s_args
{
	int				argc;
	char			**argv;
	int				exit_status;
	char			*input;
	int				start;
	char			*result;
	int				single_quotes;
	int				double_quotes;
	int				last_quotes;
}	t_args;

// Main struct
typedef struct s_ast
{
	t_ast_type		type;
	struct s_ast	*left;
	struct s_ast	*right;
	t_commands		*cmd;
	int				operator_type;
	t_token			*token;
}	t_ast;
typedef struct s_shell_data {
    t_env *env_list;
    int exit_status;
    char **heredoc_files;
    int heredoc_count;
    pid_t child_pid;
    char *curr_dir;
} t_shell_data;


// Execution function prototypes
void	ft_strdel(char **as);

// Tokenization functions
t_token		*create_node(char *str, t_token_type type);
t_token		*tokenize(char *input);
void		append_node(t_token **token, t_token *current_token);
int			is_operator(char c);
int			return_parenthesis(t_token **token, char c);
int			handle_double_operator(t_token **head, char *input, int *i);
int			handle_single_operator(t_token **token, char c);
int			handle_word(t_token **token, char *input, int *i);
int			handle_quotes(t_token **token, char *input, int *i);
int			handle_whitespace(t_token **token, char *input, int *i);

// Environmental variables
t_env		*init_env_list(char **envp);
char		*gen_env_value(t_env *env_list, char *key);
char		*parse_env(char *input, t_env *env_list, t_args *arg);
char		*join_arguments(t_args *arg);
char		*get_env_value(t_env *env_list, char *name);
char		*join_arguments(t_args *arg);
char		*env_expansion(char *input, int *i, t_env *env_list, t_args *arg);

// Validation
bool		validation(t_token *tokens);
bool		validation_parenthesis(t_token *tokenize);

// Parenthesis
bool		check_parenthesis(t_token *token, char *input, int i,
				t_paren *commands);
void		process_quotes(char c, t_quotes *quote);
bool		valid_before_open_paren(char c);
bool		is_valid_after_open_paren(char c);
int			find_matching_paren(t_token *token, char *input, int start_pos);
bool		validate_paren_content(char *input, int start_pos, int end_pos,
				t_token *token);
t_nest		validate_nested_paren(char *input, int start, int end,
				t_token *token);
bool		op_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		pipe_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		seq_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		validate_redirect_in_paren(char *input, t_open_paren *paren,
				int end, t_token *token);
bool		validate_redirect_or_command(char *input, t_open_paren *paren,
				int end, t_token *token);
bool		validate_paren_content_utils(t_open_paren *paren, t_token *token);
bool		is_valid_close_paren(char c);
bool		process_close_paren(char *input, int i, t_token *token,
				t_paren *command);
bool		skip_whitespaces(char *input, int *i, int end);
bool		check_next_token(t_token *next);
bool		check_after_close_paren(char *input, int *i, t_token *token);
bool		it_is_log_or_pipe(char *input, int *i, t_token *token);
bool		it_is_logical_op(char *input, int *i, int *j, t_token *token);
bool		it_is_pipe(char *input, int *i, int *j, t_token *token);

// Operators
bool		ft_is_operator(char c);
bool		ft_is_logical_op(char current, char next);
bool		validate_logical_op(t_token *tokens);

// Quotes
bool		validation_quotes(t_token *tokens);

// Redirections
bool		ft_is_redirection(char c);
bool		ft_is_redirection_op(char current, char next);
bool		validate_next_redirect(t_token **next, t_token **curr);

//Commands
bool		ft_is_commands_position(char *input, int i);
bool		validate_commands(t_token *tokenize);
bool		is_valid_command_start(char c);
bool		is_valid_command_char(char c);
bool		is_command_or_arg_char(char c);

// Wildcards
bool		ft_is_wildcard(char c);

// Pipes
bool		pipes(t_token *tokenize);
bool		is_operator_token(t_token *prev);
bool		has_whitespace_between(t_token *prev, t_token *curr);
bool		is_only_whitespaces(char *str);
bool		return_pipes_mssg(bool *expecting_cmd);
bool		check_redirection_before_pipe(t_token *curr, t_token *head);

// Redirect
bool		validate_redirection(t_token *tokenize);
bool		check_after_redirection(t_token **curr);

// Stack operations
void		push(t_token *stack, char data);
void		initialize_stack(t_token *stack);
char		pop(t_token *stack);
void		free_stack(t_token *stack);
bool		is_empty(t_token *stack);

// Errors and Free functions
void		free_env_list(t_env *env_list);
t_token		*free_tokens(t_token *token);
void		report_error(t_errors_code code, char *token);
void		free_stack(t_token *token);

// Binary Tree
t_ast		*parse_tokens(t_token *tokens);

// Utils functions
int			ft_strcmp(char *s1, char *s2);
int			count_parenthesis(t_token *tokens);
int			ft_isspace(int num);

void	clear_data(t_env **data, char **envp);
void	handle_signal(void);
void	free_2darray(char **array);
int execute_tree(t_ast *data,t_ast *tree);

extern pid_t	g_child_pid;
#endif

### END OF FILE: ./include/minishell.h ###


### START OF FILE: ./src/main.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/* +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 01:11:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/20 12:41:16 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

void	handle_input(char *input, t_env *env_list, int argc, char **argv)
{
	t_token			*tokens;
	char			*expandable;
	t_args			arg;
	t_ast			*ast;

	arg.exit_status = 0;
	if (*input)
	{
		add_history(input);
		arg.argc = argc - 1;
		arg.argv = argv;
		expandable = parse_env(input, env_list, &arg);
		printf("Tokenizing value\n");
		tokens = tokenize(expandable);
		if (!tokens)
		{
			free_tokens(tokens);
		}
		if (!validation(tokens))
			return ;
		ast = parse_tokens(tokens);
		if (!ast)
		{
			free_tokens(tokens);
			return ;
		}
	}
}

int	main(int argc, char **argv, char **envp)
{
	char			*input;
	t_env			*env_list;

	env_list = init_env_list(envp);
	while (1)
	{
		input = readline("minishell$: ");
		if (!input)
		{
			printf("exit\n");
			exit(0);
		}
		handle_input(input, env_list, argc, argv);
	}
}

### END OF FILE: ./src/main.c ###


### START OF FILE: ./src/parse/env/convert_env.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   convert_env.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 20:29:25 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:11:32 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

char	*get_env_value(t_env *env_list, char *name)
{
	t_env		*current;

	current = env_list;
	while (current)
	{
		if (!ft_strcmp(current->key, name))
			return (current->value);
		current = current->next;
	}
	return (NULL);
}

t_env	*create_env_node(char *input)
{
	t_env		*new_node;
	char		*equal_sign;

	new_node = (t_env *)malloc(sizeof(t_env));
	if (!new_node)
		return (NULL);
	equal_sign = ft_strchr(input, '=');
	if (!equal_sign)
	{
		free(new_node);
		return (NULL);
	}
	new_node->key = ft_substr(input, 0, equal_sign - input);
	new_node->value = ft_strdup(equal_sign + 1);
	new_node->next = NULL;
	return (new_node);
}

t_env	*init_env_list(char **envp)
{
	t_env		*head;
	t_env		*current;
	int			i;
	t_env		*new_node;

	head = NULL;
	i = 0;
	while (envp[i])
	{
		new_node = create_env_node(envp[i]);
		if (!new_node)
		{
			free_env_list(new_node);
			return (NULL);
		}
		if (!head)
			head = new_node;
		else
			current->next = new_node;
		current = new_node;
		i++;
	}
	return (head);
}

### END OF FILE: ./src/parse/env/convert_env.c ###


### START OF FILE: ./src/parse/env/env_parsing.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_parsing.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 19:07:30 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:10:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static char	*handle_special_utils(char *input, char *str, int *i, t_args *arg)
{
	if (input[*i] == '$')
	{
		if (input[*i + 1] == '?')
		{
			str = ft_itoa(arg->exit_status);
			*i += 2;
		}
		else if (input[*i + 1] == '@')
		{
			str = join_arguments(arg);
			*i += 2;
		}
		else if (input[*i + 1] == '*')
		{
			str = join_arguments(arg);
			*i += 2;
		}
		else if (input[*i + 1] == '0')
		{
			str = ft_strdup(arg->argv[0]);
			i += 2;
		}
	}
	return (str);
}

static char	*handle_special_var(char *input, int *i, t_args *arg)
{
	char	*str;

	str = NULL;
	if (input[*i] == '$')
		str = handle_special_utils(input, str, i, arg);
	return (str);
}

static char	*get_env_name(char *input, int *i, t_args *arg)
{
	int		start;
	int		len;
	char	*name;
	char	*special;

	start = *i;
	special = handle_special_var(input, i, arg);
	if (special)
		return (special);
	len = 0;
	while (input[start + len] && (ft_isalnum(input[start + len])
			|| input[start + len] == '_'))
		len++;
	if (len == 0)
		return (NULL);
	name = ft_substr(input, start, len);
	*i = start + len;
	return (name);
}

static char	*handle_shlvl(t_env *env_list)
{
	char		*value;
	int			level;
	char		*new_value;

	value = get_env_value(env_list, "SHLVL");
	if (!value)
		level = 1;
	else
		level = ft_atoi(value) + 1;
	new_value = ft_itoa(level);
	return (new_value);
}

char	*env_expansion(char *input, int *i,
	t_env *env_list, t_args *arg)
{
	char		*value;
	char		*name;

	(*i)++;
	value = NULL;
	name = get_env_name(input, i, arg);
	if (!name)
		return (ft_strdup(""));
	if (!ft_strcmp(name, "SHLVL"))
	{
		value = handle_shlvl(env_list);
		free(name);
		return (value);
	}
	value = get_env_value(env_list, name);
	if (!value)
		value = ft_strdup("");
	else
		value = ft_strdup(value);
	free(name);
	return (value);
}

### END OF FILE: ./src/parse/env/env_parsing.c ###


### START OF FILE: ./src/parse/env/env_parsing_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_parsing_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/16 00:37:42 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:11:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

char	*join_arguments(t_args *arg)
{
	int			i;
	char		*result;

	result = ft_strdup("");
	i = 0;
	while (i < arg->argc)
	{
		result = ft_strjoin(result, arg->argv[i]);
		if (i < arg->argc - 1)
			result = ft_strjoin(result, " ");
		i++;
	}
	return (result);
}

static int	quotes(char	*input, int i, t_args *parse)
{
	if (input[i] == '"')
	{
		if (!parse->single_quotes)
		{
			parse->double_quotes = !parse->double_quotes;
			if (parse->double_quotes)
				parse->last_quotes = '"';
			else if (parse->last_quotes == '"')
				parse->last_quotes = 0;
		}
		return (1);
	}
	if (input[i] == '\'')
	{
		if (!parse->double_quotes)
		{
			parse->single_quotes = !parse->single_quotes;
			if (parse->single_quotes)
				parse->last_quotes = '\'';
			else if (parse->last_quotes)
				parse->last_quotes = 0;
		}
		return (1);
	}
	return (0);
}

static char	*handle_env_part(t_args *parse, int *i, t_env *env_list)
{
	char		*temp;

	if (parse->single_quotes || parse->last_quotes == '\'')
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free(temp);
		return (parse->result);
	}
	if (*i > parse->start)
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free (temp);
	}
	temp = env_expansion(parse->input, i, env_list, parse);
	parse->result = ft_strjoin(parse->result, temp);
	free(temp);
	return (parse->result);
}

static void	handle_remaining(t_args *parse, int *i)
{
	char		*temp;

	if (*i > parse->start)
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free(temp);
	}
}

char	*parse_env(char *input, t_env *env_list, t_args *arg)
{
	t_args		parse;
	int			i;

	i = 0;
	parse = (t_args){arg->argc, arg->argv, 0, input, 0, ft_strdup(""), 0, 0, 0};
	while (input[i])
	{
		if (quotes(input, i, &parse))
		{
			i++;
			continue ;
		}
		if (input[i] == '$' && input[i + 1] && input[i + 1] != ' '
			&& input[i + 1] != '"' && input[i + 1] != '\'')
		{
			parse.result = handle_env_part(&parse, &i, env_list);
			parse.start = i;
		}
		else
			i++;
		if (i > ft_strlen(input))
			i = ft_strlen(input);
	}
	handle_remaining(&parse, &i);
	return (parse.result);
}

### END OF FILE: ./src/parse/env/env_parsing_utils.c ###


### START OF FILE: ./src/parse/nodes/nodes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   nodes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 19:50:51 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 00:19:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	append_node(t_token **head, t_token *current_token)
{
	t_token		*temp;

	if (!head || !current_token)
		return ;
	if (*head == NULL)
	{
		*head = current_token;
		return ;
	}
	else
	{
		temp = *head;
		while (temp->next)
			temp = temp->next;
		temp->next = current_token;
	}
}

t_token	*create_node(char *str, t_token_type type)
{
	t_token		*node;

	node = malloc(sizeof(t_token));
	if (!node)
		return (NULL);
	node->value = ft_strdup(str);
	if (!node->value)
	{
		free(node);
		return (NULL);
	}
	node->type = type;
	node->expandable = 0;
	node->next = NULL;
	return (node);
}

### END OF FILE: ./src/parse/nodes/nodes.c ###


### START OF FILE: ./src/parse/stack/stack.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 01:07:35 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/04 16:45:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	initialize_stack(t_token *stack)
{
	if (stack)
		stack->top = NULL;
}

bool	is_empty(t_token *stack)
{
	return (!stack || !stack->top);
}

char	pop(t_token *stack)
{
	char		data;
	t_stack		*temp;

	if (!stack || !stack->top)
		return ('\0');
	temp = stack->top;
	data = temp->name;
	stack->top = temp->next;
	free(temp);
	return (data);
}

void	free_stack(t_token *stack)
{
	t_stack		*current;
	t_stack		*next;

	if (!stack || !stack->top)
		return ;
	current = stack->top;
	while (current)
	{
		next = current->next;
		free(current);
		current = next;
	}
	stack->top = NULL;
}

void	push(t_token *stack, char data)
{
	t_stack		*new_node;

	new_node = (t_stack *)malloc(sizeof(t_stack));
	if (!new_node)
		return ;
	new_node->name = data;
	new_node->next = stack->top;
	stack->top = new_node;
}

### END OF FILE: ./src/parse/stack/stack.c ###


### START OF FILE: ./src/parse/tokenize/tokenize.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 15:33:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/14 22:11:36 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	handle_operator(t_token **token, char *input, int *i)
{
	int		status;

	if (input[*i] == '(' || input[*i] == ')')
		return (return_parenthesis(token, input[*i]));
	status = handle_double_operator(token, input, i);
	if (status != 0)
		return (status);
	return (handle_single_operator(token, input[*i]));
}

int	tokenize_utils(t_token **token, char *input, int *i)
{
	int		status;

	status = 0;
	if (input[*i] == '\'' || input[*i] == '"')
		status = handle_quotes(token, input, i);
	else if (is_operator(input[*i]))
	{
		status = handle_operator(token, input, i);
		if (status == 0)
			status = handle_word(token, input, i);
	}
	else
		status = handle_word(token, input, i);
	return (status);
}

t_token	*tokenize(char *input)
{
	t_token	*token;
	int		i;
	int		status;

	if (!input)
		return (NULL);
	i = 0;
	token = NULL;
	status = -1;
	if (input == NULL)
		return (NULL);
	while (input[i])
	{
		if (ft_isspace(input[i]))
		{
			status = handle_whitespace(&token, input, &i);
			continue ;
		}
		status = tokenize_utils(&token, input, &i);
		if (status == -1)
			return (free_tokens(token));
		i++;
	}
	return (token);
}

### END OF FILE: ./src/parse/tokenize/tokenize.c ###


### START OF FILE: ./src/parse/tokenize/tokenize_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 23:25:01 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/14 20:22:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	handle_single_operator(t_token **token, char c)
{
	t_token		*current;

	if (c == '|')
		current = create_node("|", TOKEN_PIPE);
	else if (c == ' ')
		current = create_node(" ", TOKEN_WHITESPACE);
	else if (c == '<')
		current = create_node("<", TOKEN_REDIRECT_IN);
	else if (c == '>')
		current = create_node(">", TOKEN_REDIRECT_OUT);
	else if (c == '*')
		current = create_node("*", TOKEN_WILDCARD);
	else
		return (0);
	if (!current)
		return (-1);
	printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

static int	handle_double_operator_utils(t_token **current, char *input,
	int *i, char next_char)
{
	if (input[*i] == '<' && next_char == '<')
		*current = create_node("<<", TOKEN_HEREDOC);
	else if (input[*i] == '>' && next_char == '>')
		*current = create_node(">>", TOKEN_APPEND);
	else if (input[*i] == '&' && next_char == '&')
		*current = create_node("&&", TOKEN_AND);
	else if (input[*i] == '|' && next_char == '|')
		*current = create_node("||", TOKEN_OR);
	else
		return (0);
	if (!*current)
		return (-1);
	(*i)++;
	return (1);
}

int	handle_double_operator(t_token **head, char *input, int *i)
{
	t_token		*current;
	char		next_char;
	int			result;

	if (input[*i + 1] == '\0')
		return (0);
	next_char = input[*i + 1];
	if ((input[*i] == '&' && next_char == '&' && input[*i + 2] == '&')
		|| (input[*i] == '|' && next_char == '|' && input[*i + 2] == '|'))
	{
		report_error(ERR_SYNTAX, "invalid operator sequence");
		return (-1);
	}
	result = handle_double_operator_utils(&current, input, i, next_char);
	if (result == 1)
	{
		append_node(head, current);
		printf("%s\n", current->value);
	}
	return (result);
}

int	return_parenthesis(t_token **token, char c)
{
	t_token		*current;

	if (c == '(')
		current = create_node("(", TOKEN_PAREN_OPEN);
	else
		current = create_node(")", TOKEN_PAREN_CLOSE);
	if (!current)
		return (-1);
	printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

### END OF FILE: ./src/parse/tokenize/tokenize_utils.c ###


### START OF FILE: ./src/parse/tokenize/tokenize_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_utils_2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:12:02 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:17:53 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static int	get_quote_content(char *input, int *i,
	char quote_type, char **content)
{
	int		start;
	int		len;

	start = *i + 1;
	*i = start;
	while (input[*i] && input[*i] != quote_type)
		(*i)++;
	if (!input[*i])
	{
		report_error(ERR_SYNTAX, "Unmatched parenthesis");
		return (-1);
	}
	len = *i - start;
	*content = ft_substr(input, start, len);
	if (!*content)
		return (-1);
	return (0);
}

int	handle_quotes(t_token **token, char *input, int *i)
{
	t_token	*current;
	char	*content;
	char	quote_type;

	quote_type = input[*i];
	if (get_quote_content(input, i, quote_type, &content) == -1)
		return (-1);
	current = create_node(content, TOKEN_WORD);
	if (!current)
	{
		free(content);
		return (-1);
	}
	if (quote_type == '"')
	{
		current->expandable = 1;
		current->double_quotes = 1;
	}
	else if (quote_type == '\'')
		current->single_quotes = 1;
	printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

int	handle_word(t_token **token, char *input, int *i)
{
	int		start;
	char	*word;
	t_token	*current;

	start = *i;
	while (input[*i] && !ft_isspace(input[*i]) && !is_operator(input[*i])
		&& input[*i] != '\'' && input[*i] != '"')
		(*i)++;
	word = ft_substr(input, start, *i - start);
	if (!word)
		return (-1);
	current = create_node(word, TOKEN_WORD);
	free(word);
	if (!current)
		return (-1);
	current->expandable = 1;
	printf("Token: %s\n", current->value);
	append_node(token, current);
	(*i)--;
	return (1);
}

int	handle_whitespace(t_token **token, char *input, int *i)
{
	int		start;
	char	*whitespace;
	t_token	*curr;

	start = *i;
	while (input[*i] && ft_isspace(input[*i]))
		(*i)++;
	whitespace = ft_substr(input, start, *i - start);
	if (!whitespace)
		return (-1);
	curr = create_node(whitespace, TOKEN_WHITESPACE);
	free(whitespace);
	if (!curr)
		return (-1);
	printf("TOKEN: Whitespace\n");
	append_node(token, curr);
	return (1);
}

### END OF FILE: ./src/parse/tokenize/tokenize_utils_2.c ###


### START OF FILE: ./src/parse/utils/errors_free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors_free.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:21:04 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:49:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	free_env_list(t_env *env_list)
{
	t_env		*temp;

	while (env_list)
	{
		temp = env_list->next;
		free(env_list->key);
		free(env_list->value);
		free(env_list);
		env_list = temp;
	}
}

t_token	*free_tokens(t_token *token)
{
	t_token		*temp;

	while (token)
	{
		temp = token->next;
		free(token->value);
		free(token);
		token = temp;
	}
	return (NULL);
}

void	report_error(t_errors_code code, char *token)
{
	if (code == ERR_UNBALANCED_PAREN)
	{
		if (token)
			printf("minishell: syntax error near unexpected token `%s'\n",
				token);
		else
			printf("minishell: syntax error: unmatched parenthesis\n");
	}
	else if (code == ERR_SYNTAX)
	{
		if (token)
			printf("minishell: syntax error near unexpected `%s'\n", token);
		else
			printf("minishell: syntax error\n");
	}
	else if (code == ERR_UNEXPECTED_TOKEN)
		printf("minishell: syntax error near unexpected token `%s'\n", token);
	else if (code == ERR_MEMORY)
		printf("minishell: memory allocation failed\n");
	else if (code == ERR_PARSE)
		printf("minishell: parse error\n");
}

### END OF FILE: ./src/parse/utils/errors_free.c ###


### START OF FILE: ./src/parse/utils/utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 17:21:58 by ldurmish          #+#    #+#             */
/*   Updated: 2025/02/24 20:25:41 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	ft_isspace(int num)
{
	if (num == ' ' || num == '\n' || num == '\t'
		|| num == '\v' || num == '\f' || num == '\r')
		return (1);
	return (0);
}

int	is_operator(char c)
{
	if (c == '&' || c == '|' || c == '(' || c == ')'
		|| c == '>' || c == '<' || c == '*')
		return (1);
	return (0);
}

int	ft_strcmp(char *s1, char *s2)
{
	int			i;

	i = 0;
	while (s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int	count_parenthesise_util(char *input)
{
	t_quotes	quotes;
	int			i;
	int			open_paren;
	int			close_paren;

	i = 0;
	open_paren = 0;
	close_paren = 0;
	quotes = (t_quotes){false, false};
	while (input[i] != '\0')
	{
		process_quotes(input[i], &quotes);
		if (!quotes.in_double_quotes && !quotes.in_single_quotes)
		{
			if (input[i] == '(')
				open_paren++;
			else if (input[i] == ')')
				close_paren++;
		}
		i++;
	}
	return (open_paren - close_paren);
}

int	count_parenthesis(t_token *tokens)
{
	int		count;
	int		total_count;

	if (!tokens)
		return (0);
	total_count = 0;
	while (tokens)
	{
		if (tokens->value)
		{
			count = count_parenthesise_util(tokens->value);
			total_count += count;
		}
		tokens = tokens->next;
	}
	return (total_count);
}

### END OF FILE: ./src/parse/utils/utils.c ###


### START OF FILE: ./src/parse/validation/commands/commands_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   commands_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:08:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/15 18:57:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	is_valid_command_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/'
		|| c == '$' || c == '*' || c == '?' || c == '~');
}

bool	is_command_or_arg_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/'
		|| c == '$' || c == '~' || c == '"' || c == '\'');
}

bool	is_valid_command_start(char c)
{
	return (ft_isalnum(c) || c == '.' || c == '/' || c == '$' || c == '?'
		|| c == '#' || c == '_' || c == '*');
}

### END OF FILE: ./src/parse/validation/commands/commands_utils.c ###


### START OF FILE: ./src/parse/validation/commands/validate_commands.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_commands.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 01:08:32 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/06 03:21:00 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_commands_position(char *input, int i)
{
	int			pos;

	pos = i - 1;
	while (pos >= 0 && ft_isspace(input[pos]))
		pos--;
	if (pos < 0 || input[pos] == '|' || input[pos] == ';' || input[pos] == '('
		|| pos == '\n')
		return (true);
	if (pos > 0 && ((input[pos] == '&' && input[pos - 1] == '&')
			|| (input[pos] == '|' && input[pos - 1] == '|')))
		return (true);
	return (false);
}

static bool	check_commands_in_str(char *str, bool *in_cmd, bool *is_cmd_pos,
	int i)
{
	if (!*in_cmd && is_valid_command_char(str[i])
		&& !ft_isspace(str[i]))
	{
		*is_cmd_pos = ft_is_commands_position(str, i);
		if (*is_cmd_pos && !is_valid_command_start(str[i]))
		{
			report_error(ERR_SYNTAX, "invalid command");
			return (false);
		}
		*in_cmd = true;
	}
	else if (*in_cmd && (ft_isspace(str[i]) || str[i] == '('
			|| str[i] == ')' || ft_is_operator(str[i])
			|| ft_is_redirection(str[i])))
		*in_cmd = false;
	return (true);
}

bool	check_commands(char *str)
{
	int			i;
	t_quotes	quote;
	bool		in_commands;
	bool		is_cmd_pos;

	i = 0;
	quote = (t_quotes){false, false};
	in_commands = false;
	while (str && str[i])
	{
		process_quotes(str[i], &quote);
		if (!quote.in_single_quotes && !quote.in_double_quotes)
		{
			if (!check_commands_in_str(str, &in_commands, &is_cmd_pos, i))
				return (false);
		}
		i++;
	}
	if (quote.in_double_quotes || quote.in_single_quotes)
	{
		report_error(ERR_SYNTAX, "Unmatched quotes");
		return (false);
	}
	return (true);
}

bool	validate_commands(t_token *tokenize)
{
	t_token			*current;

	if (!tokenize)
		return (true);
	current = tokenize;
	while (current)
	{
		if (!check_commands(current->value))
			return (false);
		current = current->next;
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/commands/validate_commands.c ###


### START OF FILE: ./src/parse/validation/operators/operators_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operators_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:06:42 by ldurmish          #+#    #+#             */
/*   Updated: 2025/02/26 00:38:27 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_operator(char c)
{
	return (c == '|' || c == '&' || c == ';');
}

bool	ft_is_logical_op(char current, char next)
{
	return ((current == '&' && next == '&')
		|| (current == '|' && next == '|'));
}

### END OF FILE: ./src/parse/validation/operators/operators_utils.c ###


### START OF FILE: ./src/parse/validation/operators/validation_logical_operators.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_logical_operators.c                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/26 19:18:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 00:17:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	check_sequencing(t_token **curr, t_token **next)
{
	if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
		&& ft_strcmp((*next)->value, ";") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence &&;");
		return (false);
	}
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& ft_strcmp((*next)->value, ";") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence ||;");
		return (false);
	}
	if (ft_strcmp((*curr)->value, ";") == 0 && (*next)->type == TOKEN_OR
		&& ft_strcmp((*next)->value, "||") == 0)
	{
		report_error (ERR_SYNTAX, "invalid operator sequence ;||");
		return (false);
	}
	if (ft_strcmp((*curr)->value, ";") == 0 && (*next)->type == TOKEN_AND
		&& ft_strcmp((*next)->value, "&&") == 0)
		return (report_error(ERR_SYNTAX, "invalid operator sequence ;&&"),
			false);
	return (true);
}

static bool	check_tokens_utils(t_token **curr, t_token **next)
{
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& (*next)->type == TOKEN_OR && ft_strcmp((*next)->value, "|") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence |||");
		return (false);
	}
	if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
		&& (*next)->type == TOKEN_OR && ft_strcmp((*next)->value, "||") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence &&||");
		return (false);
	}
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& (*next)->type == TOKEN_AND && ft_strcmp((*next)->value, "&&") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence ||&&");
		return (false);
	}
	return (true);
}

bool	check_tokens(t_token **curr, t_token **next)
{
	if ((*next) && ((*next)->type == TOKEN_AND || (*next)->type == TOKEN_OR
			|| (*next)->type == TOKEN_PIPE))
	{
		if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
			&& (*next)->type == TOKEN_AND
			&& ft_strcmp((*next)->value, "&") == 0)
		{
			report_error(ERR_SYNTAX, "invalid operators sequence '&&&'");
			return (false);
		}
		if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
			&& (*next)->type == TOKEN_PIPE)
		{
			report_error(ERR_SYNTAX, "invalid operator '|||'");
			return (false);
		}
		if (!check_tokens_utils(curr, next))
			return (false);
		if (!check_sequencing(curr, next))
			return (false);
	}
	return (true);
}

bool	validate_logical_op(t_token *tokens)
{
	t_token		*next;
	t_token		*curr;

	curr = tokens;
	next = NULL;
	while (curr)
	{
		next = curr->next;
		if (curr->type == TOKEN_AND || curr->type == TOKEN_OR
			|| curr->type == TOKEN_PIPE)
		{
			if (!check_tokens(&curr, &next))
				return (false);
		}
		curr = curr->next;
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/operators/validation_logical_operators.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:19:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 02:21:29 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_redirect_after_paren(char *next_input, t_token *token, int *j)
{
	if (next_input[*j] && ft_is_redirection(next_input[*j]))
	{
		if (next_input[*j] && next_input[*j] == next_input[*j + 1])
			*j += 2;
		else
			*j += 1;
		while (next_input[*j] && ft_isspace(next_input[*j]))
			(*j)++;
		if (!next_input[*j] || is_valid_command_char(next_input[*j]))
		{
			report_error(ERR_SYNTAX, "redirection without filename");
			free_stack(token);
			return (false);
		}
	}
	return (true);
}

bool	check_commands_after_paren(char *input, int *j)
{
	bool	found_operator;
	int		k;

	if (input[*j] && is_command_or_arg_char(input[*j]))
	{
		found_operator = false;
		k = 0;
		while (k < *j)
		{
			if (ft_is_operator(input[k]) || input[*j] == '|'
				|| (input[k + 1] && ft_is_logical_op(input[k], input[k + 1])))
			{
				found_operator = true;
				break ;
			}
			k++;
		}
		if (!found_operator)
		{
			report_error(ERR_SYNTAX, "missing operator between"
				"parenthesis and commands");
			return (false);
		}
	}
	return (true);
}

bool	check_op_after_paren(char *input, t_token *token, int *j)
{
	if (*j > 0 || !input[*j + 1] || input[*j] != input[*j + 1])
	{
		report_error(ERR_SYNTAX, "incomplete logical operator");
		free_stack(token);
		return (false);
	}
	*j += 2;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j] || !is_valid_command_char(input[*j]))
	{
		report_error(ERR_SYNTAX, "operator without syntax");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	logical_op_after_paren(char *input, t_token *token, int *j)
{
	if (!input[*j])
		return (false);
	if (input[*j] == '&')
		return (check_op_after_paren(input, token, j));
	else if (input[*j] == '|')
	{
		if (input[*j + 1] && input[*j + 1] == '|')
			return (check_op_after_paren(input, token, j));
		else
		{
			(*j)++;
			while (input[*j] && ft_isspace(input[*j]))
				(*j)++;
			if (!input[*j] || !is_valid_command_char(input[*j]))
			{
				report_error(ERR_SYNTAX, "pipe without command");
				free_stack(token);
				return (false);
			}
		}
	}
	return (true);
}

bool	check_next_token(t_token *next)
{
	t_token			*next_token;
	char			*next_input;
	int				j;

	if (!next || !next->next)
		return (true);
	next_token = next->next;
	if (!next->value)
		return (report_error(ERR_SYNTAX, "null token after parenthesis"),
			false);
	next_input = next_token->value;
	j = 0;
	while (next_input[j] && ft_isspace(next_input[j]))
		j++;
	if (!next_input[j])
		return (true);
	if (!check_redirect_after_paren(next_input, next_token, &j))
		return (false);
	else if (!check_commands_after_paren(next_input, &j))
		return (false);
	else if (!logical_op_after_paren(next_input, next_token, &j))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 11:49:59 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 16:27:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	if_there_is_filename(char *input, int *j, t_token *token)
{
	int			k;
	t_token		*next;

	if (!input[*j] || !is_valid_command_char(input[*j]))
	{
		if (!input[*j] && token->next)
		{
			next = token->next;
			k = 0;
			while (input[k] && ft_isspace(input[k]))
				k++;
			if (!next->value[k] || !is_valid_command_char(input[k]))
			{
				report_error(ERR_SYNTAX, "redirect without filename");
				return (free_stack(token), false);
			}
		}
	}
	return (true);
}

bool	it_is_redirect(char *input, int *i, int *j, t_token *token)
{
	if (ft_is_redirection(input[*i + 1]))
	{
		*j = *i + 1;
		if (input[*j + 1] && input[*j] == input[*j + 1])
			*j += 2;
		else
			*j += 1;
		while (input[*j] && ft_isspace(input[*j]))
			(*j)++;
		if (!if_there_is_filename(input, j, token))
			return (false);
		else
		{
			report_error(ERR_SYNTAX, "redirection without filename");
			return (free_stack(token), false);
		}
	}
	return (true);
}

bool	it_is_operator(char *input, int *i, int *j, t_token *token)
{
	if (input[*i + 1] == '&' || input[*i + 1] == '|')
	{
		if (!input[*i + 2])
		{
			if (!it_is_log_or_pipe(input, i, token))
				return (false);
		}
		else if (input[*i + 2] == input[*i + 3])
		{
			if (!it_is_logical_op(input, i, j, token))
				return (false);
		}
		else if (input[*i + 1] && input[*i + 2] != '|')
		{
			if (!it_is_pipe(input, i, j, token))
				return (false);
		}
	}
	return (true);
}

bool	check_after_close_paren(char *input, int *i, t_token *token)
{
	int			j;

	j = 0;
	if (!it_is_redirect(input, i, &j, token))
		return (false);
	else if (!it_is_operator(input, i, &j, token))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren_utils.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren_utils_1.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 14:58:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/11 19:57:06 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	it_is_pipe(char *input, int *i, int *j, t_token *token)
{
	int		k;
	t_token	*next;

	*j = *i + 2;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j])
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "pipe without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(next->value[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
			return (report_error(ERR_SYNTAX, "pipe withou command"),
				free_stack(token), false);
	}
	else if (!is_valid_command_char(input[*j]))
		return (report_error(ERR_SYNTAX, "invalid token after pipe"),
			free_stack(token), false);
	return (true);
}

bool	it_is_logical_op(char *input, int *i, int *j, t_token *token)
{
	t_token	*next;
	int		k;

	*j = *i + 3;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j])
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "operator without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(next->value[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
			return (report_error(ERR_SYNTAX, "operator withoud command"),
				free_stack(token), false);
	}
	else if (!is_valid_command_char(input[*j]))
		return (report_error(ERR_SYNTAX, "invalid token after operator"),
			free_stack(token), false);
	return (true);
}

bool	it_is_log_or_pipe(char *input, int *i, t_token *token)
{
	int		k;
	t_token	*next;

	if (input[*i + 1] == '|')
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "pipe without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(input[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
		{
			report_error(ERR_SYNTAX, "operator without command");
			return (free_stack(token), false);
		}
	}
	else if (!token->next || token->next->value[0] != input[*i + 1])
		return (report_error(ERR_SYNTAX, "incomplete logical operator"),
			free_stack(token), false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren_utils_1.c ###


### START OF FILE: ./src/parse/validation/parenthesis/find_match_paren.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_match_paren.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 15:18:18 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 15:48:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static int	process_paren_char(char c, t_quotes *quote_type, int *paren_count)
{
	process_quotes(c, quote_type);
	if (!quote_type->in_double_quotes && !quote_type->in_single_quotes)
	{
		if (c == '(')
			(*paren_count)++;
		else if (c == ')')
			(*paren_count)--;
	}
	return (*paren_count);
}

static int	scan_token_paren(t_token *curr, char *input, int *total_pos,
	int start_pos)
{
	t_quotes	quote_type;
	int			paren_count;
	int			j;

	paren_count = 1;
	j = start_pos;
	quote_type = (t_quotes){false, false};
	while (curr)
	{
		input = curr->value;
		while (input[j] != '\0')
		{
			if (process_paren_char(input[j], &quote_type, &paren_count) == 0)
				return (*total_pos + j);
			j++;
		}
		*total_pos += ft_strlen(curr->value);
		j = 0;
		curr = curr->next;
	}
	return (-1);
}

int	find_matching_paren(t_token *token, char *input, int start_pos)
{
	t_token		*curr;
	int			total_pos;

	curr = token;
	total_pos = 0;
	while (curr && start_pos >= ft_strlen(curr->value))
	{
		start_pos -= ft_strlen(curr->value);
		curr = curr->next;
	}
	return (scan_token_paren(curr, input, &total_pos, start_pos));
}

### END OF FILE: ./src/parse/validation/parenthesis/find_match_paren.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 01:24:50 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:15:48 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	validate_open_paren(char *input, int i, t_token *token)
{
	if (i == 0)
		return (true);
	if (i > 0)
	{
		if (is_command_or_arg_char(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "missing operator or space before '(");
			return (free_stack(token), false);
		}
		if (ft_is_redirection(input[i - 1]) || ft_is_wildcard(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "invalid token before the '('");
			return (false);
		}
		if (!valid_before_open_paren(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "invalid token before '('");
			return (false);
		}
	}
	if (input[i + 1] && !is_valid_after_open_paren(input[i + 1]))
		return (report_error(ERR_SYNTAX, "invalid token after '('"), false);
	return (true);
}

static bool	validate_command_paren(char *input, int i, t_paren *command)
{
	command->j = i - 1;
	while (command->j >= 0 && ft_isspace(input[command->j]))
		command->j--;
	if (command->j >= 0 && is_command_or_arg_char(input[command->j]))
	{
		while (command->j >= 0 && is_command_or_arg_char(input[command->j]))
			command->j--;
		command->has_cmd_before = true;
	}
	if (command->has_cmd_before)
	{
		command->j++;
		command->has_operator = false;
		while (command->j < i && !command->has_operator)
		{
			if (ft_is_operator(input[command->j]))
				command->has_operator = true;
			command->j++;
		}
		if (!command->has_operator)
			return (false);
	}
	return (true);
}

int	check_matching_paren(char *input, int i, t_token *token, int start)
{
	t_token		*next_token;
	int			end_pos;

	if (i + 1 >= (int)ft_strlen(input))
	{
		start = 0;
		next_token = token->next;
		if (!next_token)
		{
			report_error(ERR_SYNTAX, "unmatched parenthesis");
			return (-1);
		}
		end_pos = find_matching_paren(next_token, next_token->value, start);
		if (end_pos != -1)
			return (end_pos + ft_strlen(input));
	}
	else
	{
		start = i + 1;
		end_pos = find_matching_paren(token, input, start);
		return (end_pos);
	}
	return (-1);
}

static int	process_open_paren(t_token *token, char *input, int i,
	t_paren *commands)
{
	int			start_pos;
	int			end_pos;

	if (i > 0 && !validate_command_paren(input, i, commands))
	{
		report_error(ERR_SYNTAX, "invalid command before parenthesis");
		return (free_stack(token), false);
	}
	if (!validate_open_paren(input, i, token))
		return (-1);
	start_pos = 0;
	end_pos = check_matching_paren(input, i, token, start_pos);
	if (end_pos == -1)
		return (report_error(ERR_SYNTAX, "unclosed parenthesis"), false);
	if (end_pos == i + 1)
		return (report_error(ERR_SYNTAX, "empty parenthesis"), false);
	if (!validate_paren_content(input, start_pos, end_pos, token))
		return (false);
	push(token, '(');
	commands->has_content = true;
	commands->last_op = ')';
	commands->has_commands = false;
	return (end_pos);
}

bool	check_parenthesis(t_token *token, char *input, int i,
	t_paren *commands)
{
	int			new_pos;

	if (!commands->quote.in_single_quotes
		&& !commands->quote.in_double_quotes)
	{
		if (!commands->has_commands && is_valid_command_char(input[i]))
			commands->has_commands = true;
		else if (commands->has_commands && ft_isspace(input[i]))
			commands->has_commands = false;
		if (input[i] == '(')
		{
			new_pos = process_open_paren(token, input, i, commands);
			if (new_pos <= 0)
				return (false);
			i = new_pos;
		}
		else if (input[i] == ')')
		{
			if (!process_close_paren(input, i, token, commands))
				return (false);
		}
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_content.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_content.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 00:53:16 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:51:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

t_nest	check_paren_in_token(t_state *state, int end, char *input)
{
	t_nest			result;

	result = (t_nest){false, state->token, state->pos};
	while (state->pos < end && input[state->pos])
	{
		process_quotes(input[state->pos], &state->quote);
		if (!state->quote.in_double_quotes && !state->quote.in_single_quotes)
		{
			if (input[state->pos] == '(')
				state->paren_count++;
			else if (input[state->pos] == ')')
			{
				state->paren_count--;
				if (state->paren_count == 0)
				{
					result.success = true;
					result.position = state->pos;
					return (result);
				}
			}
		}
		state->pos++;
	}
	return (result);
}

t_nest	check_paren_in_multiple_token(t_state *state, char *input,
	t_token *curr)
{
	t_nest				result;

	result = (t_nest){false, curr, state->pos};
	while (input[state->pos] && state->paren_count > 0)
	{
		process_quotes(input[state->pos], &state->quote);
		if (!state->quote.in_double_quotes && !state->quote.in_single_quotes)
		{
			if (input[state->pos] == '(')
				state->paren_count++;
			else if (input[state->pos] == ')')
			{
				state->paren_count--;
				if (state->paren_count == 0)
					return ((t_nest){true, curr, state->pos});
			}
		}
		state->pos++;
	}
	return (result);
}

t_nest	validate_nested_paren(char *input, int start, int end,
	t_token *start_token)
{
	t_nest				result;
	t_state				state;
	t_token				*curr;

	result = (t_nest){false, start_token, start};
	state = (t_state){{false, false}, start_token, start + 1, 1};
	result = check_paren_in_token(&state, end, input);
	if (result.success)
		return (result);
	curr = state.token->next;
	while (curr && state.paren_count > 0)
	{
		state.pos = 0;
		input = curr->value;
		result = check_paren_in_multiple_token(&state, input, curr);
		if (result.success)
			return (result);
		curr = curr->next;
	}
	report_error(ERR_SYNTAX, "unbalanced parenthesis");
	return (result);
}

bool	handle_paren(char *input, t_open_paren *paren, int *end,
	t_token **curr)
{
	t_nest				result;

	result = validate_nested_paren(input, paren->i, *end, *curr);
	if (!result.success)
		return (false);
	if (result.token != *curr)
	{
		*curr = result.token;
		input = (*curr)->value;
		*end = ft_strlen(input);
		paren->i = result.position + 1;
	}
	else
		paren->i = result.position + 1;
	paren->has_commands = true;
	paren->expecting_commands = false;
	return (true);
}

bool	validate_paren_content(char *input, int start, int end,
	t_token *token)
{
	t_open_paren		paren;
	char				*curent_input;
	t_token				*curr;

	paren = (t_open_paren){false, true, start};
	curent_input = input;
	curr = token;
	while (paren.i < end)
	{
		if (skip_whitespaces(input, &paren.i, end))
			break ;
		if (curent_input[paren.i] == '(')
		{
			if (!handle_paren(input, &paren, &end, &curr))
				return (false);
			continue ;
		}
		if (op_paren(input, &paren, token) || pipe_paren(input, &paren, token)
			|| seq_paren(input, &paren, token))
			continue ;
		if (!validate_redirect_or_command(input, &paren, end, token))
			return (false);
	}
	return (validate_paren_content_utils(&paren, token));
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_content.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 21:09:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/09 00:24:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	valid_before_open_paren(char c)
{
	return (ft_isspace(c) || c == '|' || c == '&' || c == '('
		|| c == ';' || c == '\0');
}

bool	is_valid_after_open_paren(char c)
{
	return (ft_isalnum(c) || c == '(' || c == '$');
}

bool	is_valid_close_paren(char c)
{
	return (ft_isspace(c) || c == '|' || c == '&' || c == ')' || c == ';'
		|| c == '\0');
}

bool	skip_whitespaces(char *input, int *i, int end)
{
	while (*i < end && ft_isspace(input[*i]))
		(*i)++;
	return (*i >= end);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils_1.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 23:59:21 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/10 16:19:47 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	validate_redirect_or_command(char *input, t_open_paren *paren,
	int end, t_token *token)
{
	if (validate_redirect_in_paren(input, paren, end, token))
		return (true);
	if (is_valid_command_char(input[paren->i]))
	{
		while (paren->i < end && is_valid_command_char(input[paren->i]))
			paren->i++;
		paren->has_commands = true;
		paren->expecting_commands = false;
	}
	else
	{
		report_error(ERR_SYNTAX, "invalid syntax near character");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	seq_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (input[paren->i] == ';')
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "sequence without preceding commands");
			free_stack(token);
			return (false);
		}
		paren->i++;
		paren->has_commands = false;
		paren->expecting_commands = true;
		return (true);
	}
	return (false);
}

bool	pipe_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (input[paren->i] == '|' && input[paren->i + 1] != '|')
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "pipe without preceding commands");
			free_stack(token);
			return (false);
		}
		paren->i++;
		paren->expecting_commands = true;
		paren->has_commands = false;
		return (true);
	}
	return (false);
}

bool	op_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (ft_is_logical_op(input[paren->i], input[paren->i + 1]))
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "operator without preceding command");
			free_stack(token);
			return (false);
		}
		paren->i += 2;
		paren->expecting_commands = true;
		paren->has_commands = false;
		return (true);
	}
	return (false);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_1.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils_2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 02:26:37 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 16:57:15 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	validate_redirect_in_paren(char *input, t_open_paren *paren, int end,
	t_token *token)
{
	if (ft_is_redirection(input[paren->i]))
	{
		if (paren->i + 1 < end && input[paren->i] == input[paren->i + 1])
			paren->i += 2;
		else
			paren->i++;
		while (paren->i < end && ft_isspace(input[paren->i]))
			paren->i++;
		if (paren->i >= end || !is_valid_command_char(input[paren->i]))
		{
			report_error(ERR_SYNTAX, "redirection without filenamd");
			free_stack(token);
			return (false);
		}
		while (paren->i < end && is_valid_command_char(input[paren->i]))
			paren->i++;
	}
	return (true);
}

bool	validate_paren_content_utils(t_open_paren *paren, t_token *token)
{
	if (paren->expecting_commands && !paren->has_commands)
	{
		report_error(ERR_SYNTAX, "missing command after operator");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	check_closed_paren(char *input, int i, t_token *token)
{
	if (!ft_isspace(input[i + 1]) && !is_valid_close_paren(input[i + 1])
		&& !ft_is_redirection(input[i + 1]) && !ft_is_wildcard(input[i + 1]))
	{
		report_error(ERR_SYNTAX, "invalid token after ')'");
		return (free_stack(token), false);
	}
	if (ft_is_redirection_op(input[i], input[i + 1]))
		return (true);
	if (ft_is_wildcard(input[i + 1]) && !ft_isspace(input[i + 1]))
	{
		report_error(ERR_SYNTAX, "missing space after ')'");
		return (free_stack(token), false);
	}
	return (true);
}

bool	process_close_paren(char *input, int i, t_token *token,
	t_paren *command)
{
	if (is_empty(token))
	{
		report_error(ERR_UNEXPECTED_TOKEN, ")");
		return (free_stack(token), false);
	}
	if (!command->has_content)
	{
		report_error(ERR_SYNTAX, "empty parenthesis");
		return (free_stack(token), false);
	}
	if (input[i + 1])
	{
		if (is_command_or_arg_char(input[i + 1]))
		{
			report_error(ERR_SYNTAX, "missing operator or space after ')'");
			return (free_stack(token), false);
		}
		if (!check_closed_paren(input, i, token))
			return (false);
	}
	else if (!check_next_token(token->next))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_2.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_validation.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_validation.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/23 17:59:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 01:18:42 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

void	process_quotes(char c, t_quotes *quote)
{
	if (c == '"' && !quote->in_single_quotes)
		quote->in_double_quotes = !quote->in_double_quotes;
	else if (c == '\'' && !quote->in_double_quotes)
		quote->in_single_quotes = !quote->in_single_quotes;
}

bool	parenthesis(t_token *token, char *input, t_paren *commands)
{
	int			i;

	i = 0;
	while (input[i] != '\0')
	{
		process_quotes(input[i], &commands->quote);
		if (!check_parenthesis(token, input, i, commands))
			return (false);
		i++;
	}
	return (true);
}

bool	parenthesis_utils(t_token *tokenize)
{
	char		*input;
	t_token		*stack;
	t_paren		commands;

	stack = tokenize;
	commands = (t_paren){false, false, '\0', false, 0, false, {false, false}};
	initialize_stack(stack);
	while (stack && stack->value)
	{
		input = stack->value;
		if (stack->single_quotes == 1)
			return (true);
		else if (stack->double_quotes == 1)
			return (true);
		if (!parenthesis(stack, input, &commands))
			return (false);
		stack = stack->next;
	}
	if (!is_empty(stack))
		return (report_error(ERR_UNEXPECTED_TOKEN, ")"),
			free_stack(stack), false);
	free_stack(stack);
	free(stack);
	return (true);
}

bool	check_count_paren(t_token *tokenize)
{
	int		paren_count;

	paren_count = count_parenthesis(tokenize);
	if (paren_count != 0)
	{
		if (paren_count > 0)
			report_error(ERR_UNEXPECTED_TOKEN, ")");
		else
			report_error(ERR_UNEXPECTED_TOKEN, "(");
		return (false);
	}
	if (!parenthesis_utils(tokenize))
		return (false);
	return (true);
}

bool	validation_parenthesis(t_token *tokenize)
{
	if (!tokenize)
		return (true);
	if (!check_count_paren(tokenize))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_validation.c ###


### START OF FILE: ./src/parse/validation/pipes/pipes_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 00:23:14 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/15 18:52:41 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	is_operator_token(t_token *prev)
{
	if (!prev)
		return (false);
	return (prev->type == TOKEN_REDIRECT_IN || prev->type == TOKEN_REDIRECT_OUT
		|| prev->type == TOKEN_APPEND || prev->type == TOKEN_HEREDOC
		|| prev->type == TOKEN_AND || prev->type == TOKEN_OR
		|| prev->type == TOKEN_PIPE);
}

bool	has_whitespace_between(t_token *first, t_token *second)
{
	t_token		*curr;

	curr = first->next;
	while (curr && curr != second)
	{
		if (curr->type == TOKEN_WORD && is_only_whitespaces(curr->value))
			return (true);
		curr = curr->next;
	}
	return (false);
}

bool	is_only_whitespaces(char *str)
{
	int			i;

	i = 0;
	if (!str)
		return (false);
	while (str[i] != '\0')
	{
		if (!ft_isspace(str[i]))
			return (false);
		i++;
	}
	return (true);
}

bool	return_pipes_mssg(bool *expecting_cmd)
{
	if (*expecting_cmd)
	{
		report_error(ERR_SYNTAX, "missing command after pipes");
		return (false);
	}
	return (true);
}

bool	check_redirection_before_pipe(t_token *curr, t_token *head)
{
	t_token		*check;
	t_token		*last_redir;
	bool		has_filename;

	check = head;
	while (check != curr)
	{
		if ((check->type == TOKEN_APPEND || check->type == TOKEN_REDIRECT_OUT)
			&& check->next == curr)
			return (true);
		check = check->next;
	}
	check = head;
	last_redir = NULL;
	has_filename = false;
	while (check != curr)
	{
		if (check->type == TOKEN_APPEND || check->type == TOKEN_REDIRECT_IN
			|| check->type == TOKEN_REDIRECT_OUT
			|| check->type == TOKEN_HEREDOC)
		{
			if (check->next == curr)
			{
				last_redir = NULL;
			}
			last_redir = check;
			has_filename = false;
		}
		else if (last_redir && check->type == TOKEN_WORD
			&& !is_only_whitespaces(check->value))
			has_filename = true;
		check = check->next;
	}
	if (last_redir && !has_filename)
		return (report_error(ERR_SYNTAX, "missing filename before pipes"),
			false);
	return (true);
}

### END OF FILE: ./src/parse/validation/pipes/pipes_utils.c ###


### START OF FILE: ./src/parse/validation/pipes/validation_pipes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_pipes.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 19:22:21 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:31:46 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_pipe_followed_by_logical(t_token *curr)
{
	t_token		*next;

	next = curr->next;
	while (next && next->type == TOKEN_WORD && is_only_whitespaces(next->value))
		next = next->next;
	if (next && (next->type == TOKEN_AND || next->type == TOKEN_OR))
	{
		if (next->type == TOKEN_AND && ft_strcmp(next->value, "&&") == 0)
			report_error(ERR_SYNTAX, "invalid operator sequence '|&&'");
		else if (next->type == TOKEN_OR && ft_strcmp(next->value, "||") == 0)
			report_error(ERR_SYNTAX, "invalid opeartor sequence '|||'");
		else
			report_error(ERR_SYNTAX, "invalid operator sequence");
		return (false);
	}
	return (true);
}

bool	check_operator_before_pipe(t_token *prev, t_token *curr)
{
	t_token		*check;
	bool		has_word;

	if (!is_operator_token(prev))
		return (true);
	if (prev->type == TOKEN_REDIRECT_OUT && ft_strcmp(prev->value, ">") == 0
		&& !has_whitespace_between(prev, curr))
		return (true);
	if (prev->type == TOKEN_APPEND && ft_strcmp(prev->value, ">>") == 0
		&& !has_whitespace_between(prev, curr))
		return (true);
	check = prev->next;
	has_word = false;
	while (check && check != curr)
	{
		if (check->type == TOKEN_WORD && !is_only_whitespaces(check->value))
		{
			has_word = true;
			break ;
		}
		check = check->next;
	}
	if (!has_word)
		return (report_error(ERR_SYNTAX, "token '|'"), false);
	return (true);
}

bool	validate_pipe_position(t_token *prev, t_token *curr, t_token *head)
{
	t_token		*next;

	if (!check_redirection_before_pipe(curr, head))
		return (false);
	if (curr->next == NULL)
	{
		report_error(ERR_UNEXPECTED_TOKEN, "'|'");
		return (false);
	}
	if (!check_pipe_followed_by_logical(curr))
		return (false);
	next = curr->next;
	while (next && next->type == TOKEN_WORD && is_only_whitespaces(next->value))
		next = next->next;
	if (next && next->type == TOKEN_PIPE)
		return (report_error(ERR_UNEXPECTED_TOKEN, "'|'"), false);
	if (!check_operator_before_pipe(prev, curr))
		return (false);
	return (true);
}

bool	has_expecting_command(t_token *curr, bool *expecting_command)
{
	t_token		*next;

	if (curr->type == TOKEN_WORD && is_only_whitespaces(curr->value))
		return (true);
	else if (curr->type == TOKEN_WORD && !is_only_whitespaces(curr->value))
		*expecting_command = false;
	else if (curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_REDIRECT_OUT
		|| curr->type == TOKEN_APPEND || curr->type == TOKEN_HEREDOC)
	{
		next = curr->next;
		if (!next)
			return (report_error(ERR_SYNTAX, "newline"), false);
		while (next && next->type == TOKEN_WORD
			&& is_only_whitespaces(next->value))
			next = next->next;
		if (next->type == TOKEN_WORD && !is_only_whitespaces(next->value))
			*expecting_command = false;
	}
	else if (curr->type == TOKEN_AND || curr->type == TOKEN_OR
		|| curr->type == TOKEN_PIPE)
	{
		report_error(ERR_SYNTAX, "missing command");
		return (false);
	}
	return (true);
}

bool	pipes(t_token *tokenize)
{
	t_pipe		pipe;

	pipe = (t_pipe){tokenize, NULL, tokenize, false};
	while (pipe.curr)
	{
		if (pipe.curr->type == TOKEN_WORD
			&& is_only_whitespaces(pipe.curr->value))
		{
			pipe.prev = pipe.curr;
			pipe.curr = pipe.curr->next;
			continue ;
		}
		if (pipe.curr->type == TOKEN_PIPE)
		{
			if (!validate_pipe_position(pipe.prev, pipe.curr, pipe.head))
				return (false);
			pipe.expecting_command = true;
		}
		else if (pipe.expecting_command
			&& !has_expecting_command(pipe.curr, &pipe.expecting_command))
			return (false);
		pipe.prev = pipe.curr;
		pipe.curr = pipe.curr->next;
	}
	return (return_pipes_mssg(&pipe.expecting_command));
}

### END OF FILE: ./src/parse/validation/pipes/validation_pipes.c ###


### START OF FILE: ./src/parse/validation/quotes/validation_quotes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_quotes.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 09:57:00 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/03 12:04:07 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	check_quotes(t_quotes *quote)
{
	if (quote->in_double_quotes || quote->in_single_quotes)
	{
		report_error(ERR_SYNTAX, "Unmtached %c quote detected");
		return (false);
	}
	return (true);
}

bool	validation_quotes(t_token *tokens)
{
	t_token		*curr;
	t_quotes	quote;
	int			i;
	char		*value;

	curr = tokens;
	quote = (t_quotes){false, false};
	while (curr)
	{
		if (curr->type == TOKEN_WORD)
		{
			value = curr->value;
			i = 0;
			while (value && value[i])
			{
				process_quotes(value[i], &quote);
				i++;
			}
		}
		curr = curr->next;
	}
	if (!check_quotes(&quote))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/quotes/validation_quotes.c ###


### START OF FILE: ./src/parse/validation/redirections/redirections_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:12:46 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:23:31 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_redirection(char c)
{
	return (c == '<' || c == '>');
}

bool	ft_is_redirection_op(char curr, char next)
{
	return ((curr == '>' && curr == '>') || (curr == '<' && next == '<'));
}

bool	check_after_redirection(t_token **curr)
{
	if (((*curr)->type == TOKEN_REDIRECT_OUT || (*curr)->type == TOKEN_APPEND
			|| (*curr)->type == TOKEN_REDIRECT_IN
			|| (*curr)->type == TOKEN_HEREDOC) && (*curr)->next
		&& ((*curr)->next->type == TOKEN_OR
			|| (*curr)->next->type == TOKEN_AND))
		return (report_error(ERR_UNEXPECTED_TOKEN, (*curr)->next->value),
			false);
	return (true);
}

bool	validate_next_redirect(t_token **next, t_token **curr)
{
	while (*next && (*next)->type == TOKEN_WHITESPACE)
		*next = (*next)->next;
	if (!*next || ((*next)->type != TOKEN_WORD
			&& (*next)->type != TOKEN_PROCESSED))
	{
		if (!*next)
			report_error(ERR_UNEXPECTED_TOKEN, "newline");
		else
			report_error(ERR_UNEXPECTED_TOKEN, (*curr)->value);
		return (false);
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/redirections/redirections_utils.c ###


### START OF FILE: ./src/parse/validation/redirections/validate_redirection.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_redirection.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/15 13:11:15 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:22:54 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_redirection(t_token **next)
{
	if (*next && ((*next)->type == TOKEN_APPEND
			|| (*next)->type == TOKEN_REDIRECT_IN
			|| (*next)->type == TOKEN_HEREDOC
			|| (*next)->type == TOKEN_REDIRECT_OUT))
	{
		report_error(ERR_UNEXPECTED_TOKEN, (*next)->value);
		return (false);
	}
	else if (*next && ((*next)->type == TOKEN_AND || (*next)->type == TOKEN_OR))
	{
		report_error(ERR_UNEXPECTED_TOKEN, (*next)->value);
		return (false);
	}
	return (true);
}

bool	check_adjacent_redirection(t_token **curr)
{
	if ((*curr)->type == TOKEN_REDIRECT_IN && (*curr)->next
		&& (*curr)->next->type == TOKEN_REDIRECT_OUT)
	{
		(*curr)->type = TOKEN_READWRITE;
		free((*curr)->value);
		(*curr)->value = ft_strdup("<>");
		(*curr)->next->type = TOKEN_PROCESSED;
		return (true);
	}
	return (true);
}

bool	validate_redirection_spaces(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr != NULL)
	{
		if (curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_APPEND
			|| curr->type == TOKEN_REDIRECT_OUT || curr->type == TOKEN_HEREDOC)
		{
			next = curr->next;
			if (next && next->type == TOKEN_WHITESPACE)
			{
				next = next->next;
				if (!check_redirection(&next))
					return (false);
			}
		}
		if (!check_after_redirection(&curr))
			return (false);
		curr = curr->next;
	}
	return (true);
}

bool	validate_redirection_combinations(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr && curr->next)
	{
		if (curr->type == TOKEN_HEREDOC || curr->type == TOKEN_REDIRECT_OUT
			|| curr->type == TOKEN_APPEND || curr->type == TOKEN_REDIRECT_OUT)
		{
			next = curr->next;
			while (next && next->type == TOKEN_WHITESPACE)
				next = next->next;
			if (next && (next->type == TOKEN_REDIRECT_OUT
					|| next->type == TOKEN_APPEND
					|| next->type == TOKEN_REDIRECT_IN
					|| next->type == TOKEN_HEREDOC))
			{
				report_error(ERR_UNEXPECTED_TOKEN, next->value);
				return (false);
			}
		}
		curr = curr->next;
	}
	return (validate_redirection_spaces(tokenize));
}

bool	validate_redirection(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr != NULL)
	{
		if (curr->type == TOKEN_PROCESSED)
		{
			curr = curr->next;
			continue ;
		}
		if (curr->type == TOKEN_APPEND || curr->type == TOKEN_REDIRECT_IN
			|| curr->type == TOKEN_REDIRECT_OUT || curr->type == TOKEN_HEREDOC)
		{
			if (!check_adjacent_redirection(&curr))
				return (false);
			next = curr->next;
			if (!validate_next_redirect(&next, &curr))
				return (true);
		}
		curr = curr->next;
	}
	return (validate_redirection_combinations(tokenize));
}

### END OF FILE: ./src/parse/validation/redirections/validate_redirection.c ###


### START OF FILE: ./src/parse/validation/validation.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 16:01:41 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:52:05 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

bool	validation_utils(t_token *tokenize)
{
	if (!pipes(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validate_redirection(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	return (true);
}

bool	validation(t_token *tokenize)
{
	if (!validate_logical_op(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validate_commands(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_parenthesis(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_quotes(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_utils(tokenize))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/validation.c ###


### START OF FILE: ./src/parse/validation/wildcards/wildcards_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wildcards_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 20:29:29 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/03 20:31:18 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_wildcard(char c)
{
	return (c == '*' || c == '?');
}

### END OF FILE: ./src/parse/validation/wildcards/wildcards_utils.c ###


### START OF FILE: ./src/tree/tree.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 15:32:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 14:38:01 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*parse_pipeline(t_token **tokens)
{
	t_ast		*left;
	t_ast		*right;
	t_token		*curr;

	(void)left;
	(void)right;
	(void)curr;

	if (!tokens || !*tokens)
		return (NULL);
	// TODO: Implement pipeline parsing logic here
	return (NULL);
}

t_ast	*parse_logic_sequence(t_token **tokens)
{
	t_ast		*left;
	t_ast		*right;
	t_token		*current;
	(void)right;
	(void)current;
	
	if (!tokens || !*tokens)
		return (NULL);
	left = parse_pipeline(tokens);
	if (!left)
		return (NULL);
	// TODO: Implement logic sequence parsing (&&, ||) here
	return (left);
}

t_ast	*parse_command_line(t_token **tokens)
{
	if (!tokens || !*tokens)
		return (NULL);
	return (parse_logic_sequence(tokens));
}

t_ast	*parse_tokens(t_token *tokens)
{
	t_token		*curr;
	t_ast		*root;

	if (!tokens)
		return (NULL);
	curr = tokens;
	root = parse_command_line(&curr);
	return (root);
}
### END OF FILE: ./src/tree/tree.c ###


### START OF FILE: ./src/tree/tree_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/18 21:23:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 01:16:41 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	free_ast(t_ast *node)
{
	int			i;

	if (!node)
		return ;
	free_ast(node->left);
	free_ast(node->right);
	if (node->cmd)
	{
		if (node->cmd->args)
		{
			i = -1;
			while (node->cmd->args[++i])
				free(node->cmd->args[i]);
			free(node->cmd->args[i]);
		}
		if (node->cmd->infile)
			free(node->cmd->infile);
		if (node->cmd->outfile)
			free(node->cmd->outfile);
		if (node->cmd->heredoc_delim)
			free(node->cmd->heredoc_delim);
		free(node->cmd);
	}
}

### END OF FILE: ./src/tree/tree_utils.c ###


### START OF FILE: ./src/execution/builtins/builtins.c ###

#include "minishell.h"

typedef int (*t_builtin_func)(t_ast *data, t_ast *tree, int fd_out);

typedef struct s_builtin {
    const char      *name;
    t_builtin_func  func;
} t_builtin;

static int builtin_export(t_ast *data, t_ast *tree, int fd_out)
{
    if (!tree->cmd->args[1])
        print_env_list(data->env_list, fd_out, 1); // Pass 1 to filter
    else
        execute_export(data, tree, fd_out);
    return 1;
}


static int builtin_unset(t_ast *data, t_ast *tree, int fd_out)
{
    (void)fd_out;
    if (execute_unset(data, tree))
        return (data->exit_status = 1, 1);
    return 1;
}

static int builtin_env(t_ast *data, t_ast *tree, int fd_out)
{
    (void)tree;
    print_env_list(data->env_list, fd_out, 0); 
    return 1;
}

static int builtin_cd(t_ast *data, t_ast *tree, int fd_out)
{
    (void)fd_out; 
    char *path = tree->cmd->args[1];
    char *oldpwd = getcwd(NULL, 0); 

    if (!path || !ft_strcmp(path, "~"))
    {
        path = get_env_value(data->env_list, "HOME");
        if (!path)
        {
            ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
            free(oldpwd);
            return (data->exit_status = 1, 1);
        }
    }
    else if (!ft_strcmp(path, "-")) 
    {
        path = get_env_value(data->env_list, "OLDPWD");
        if (!path)
        {
            ft_putendl_fd("minishell: cd: OLDPWD not set", STDERR_FILENO);
            free(oldpwd);
            return (data->exit_status = 1, 1);
        }
        ft_putendl_fd(path, STDOUT_FILENO); 
    }

    if (execute_cd(data, path))
    {
        free(oldpwd);
        return (data->exit_status = 1, 1);
    }

    set_env_var(data, "OLDPWD", oldpwd);
    free(oldpwd);
    return 1;
}

/* Builtin: pwd */
static int builtin_pwd(t_ast *data, t_ast *tree, int fd_out)
{
    (void)tree;
    if (execute_pwd(data, fd_out))
        return (data->exit_status = 1, 1);
    return 1;
}

/* Builtin: echo */
static int builtin_echo(t_ast *data, t_ast *tree, int fd_out)
{
    if (execute_echo(tree->cmd->args, fd_out))
        return (data->exit_status = 1, 1);
    return 1;
}

/* Builtin: exit */
static int builtin_exit(t_ast *data, t_ast *tree, int fd_out)
{
    (void)fd_out;
    if (execute_exit(data, tree))
        return (data->exit_status = 1, 1);
    return 1;
}

/* Builtin dispatch table */
static const t_builtin g_builtins[] = {
    { "export", builtin_export },
    { "unset",  builtin_unset  },
    { "env",    builtin_env    },
    { "cd",     builtin_cd     },
    { "pwd",    builtin_pwd    },
    { "echo",   builtin_echo   },
    { "exit",   builtin_exit   },
    { NULL,     NULL }
};

/*
 * handle_builtin - Check if the command is a builtin and execute it.
 * Returns 1 if a builtin was found and executed; otherwise, returns 0.
 */
int handle_builtin(t_ast *data, t_ast *tree, int fd_out)
{
    int i = 0;

    if (!tree->cmd->args || !tree->cmd->args[0])
        return 0;
    while (g_builtins[i].name)
    {
        if (!ft_strcmp(tree->cmd->args[0], g_builtins[i].name))
            return g_builtins[i].func(data, tree, fd_out);
        i++;
    }
    return 0;
}

### END OF FILE: ./src/execution/builtins/builtins.c ###


### START OF FILE: ./src/execution/builtins/builtins_utils.c ###

#include "minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>

/*
 * execute_pwd - Prints the current working directory to fd_out.
 * Returns 0 on success, 1 on error.
 */
int execute_pwd(t_ast *data, int fd_out)
{
    (void)data; // Unused parameter

    char *cwd = getcwd(NULL, 0); // Dynamically allocate buffer
    if (!cwd)
    {
        ft_putendl_fd("minishell: pwd: error retrieving current directory", STDERR_FILENO);
        return 1; // Return error status
    }

    // Print the current working directory to fd_out
    ft_putendl_fd(cwd, fd_out);

    // Free the dynamically allocated buffer
    free(cwd);

    return 0; // Success
}

/*
 * execute_echo - Prints the arguments to fd_out.
 * If "-n" is passed as the first argument, no trailing newline is printed.
 * Returns 0 on success.
 */
int execute_echo(char *args[], int fd_out)
{
    int i = 1;
    int newline = 1;

    if (args[1] && !ft_strcmp(args[1], "-n"))
    {
        newline = 0;
        i++;
    }
    while (args[i])
    {
        ft_putstr_fd(args[i], fd_out);
        if (args[i + 1])
            ft_putstr_fd(" ", fd_out);
        i++;
    }
    if (newline)
        ft_putendl_fd("", fd_out);
    return 0;
}

/*
 * execute_cd - Changes the current directory.
 * Uses path provided; if NULL, uses the HOME environment variable.
 * On failure, prints an error message and returns 1.
 * On success, updates data->curr_dir.
 */
int execute_cd(t_ast *data, char *path)
{
    if (!path || chdir(path) != 0)
    {
        ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
        ft_putstr_fd(strerror(errno), STDERR_FILENO);
        ft_putstr_fd("\n", STDERR_FILENO);
        return 1;
    }
    /* Update current directory */
    char *new_dir = getcwd(NULL, 0);
    if (new_dir)
    {
        if (data->curr_dir)
            free(data->curr_dir);
        data->curr_dir = new_dir;
    }
    return 0;
}

/*
 * execute_export - Exports or updates an environment variable.
 * Expects tree->args_array[1] to be of the form "VAR=VALUE".
 */
#include <stdbool.h>

bool is_valid_identifier(const char *name) {
    // Check for empty string
    if (name == NULL || *name == '\0')
        return false;
    
    // First character must be underscore or alphabetic
    char first = name[0];
    if (first != '_' && !((first >= 'A' && first <= 'Z') || (first >= 'a' && first <= 'z')))
        return false;
    
    // Subsequent characters must be alphanumeric or underscore
    for (int i = 1; name[i] != '\0'; i++) {
        char c = name[i];
        bool valid = (c == '_') || 
                    (c >= '0' && c <= '9') ||
                    (c >= 'A' && c <= 'Z') || 
                    (c >= 'a' && c <= 'z');
        if (!valid)
            return false;
    }
    return true;
}

t_envir *get_env_node(t_envir *env_list, const char *name) {
    t_envir *current = env_list;
    while (current != NULL) {
        // Compare variable name using case-sensitive match
        if (strcmp(current->var_name, name) == 0) {
            return current;
        }
        current = current->next;
    }
    return NULL; // Not found
}

int execute_export(t_ast *data, t_ast *tree, int fd_out)
{
    (void)fd_out; // Unused parameter
    int i = 1; // Handle multiple arguments
    int status = 0;
    
    while (tree->cmd->args[i]) {
        char *arg = tree->cmd->args[i];
        char *eq = ft_strchr(arg, '=');
        char *name = eq ? ft_substr(arg, 0, eq - arg) : ft_strdup(arg);
        if (!name) {
            ft_putendl_fd("minishell: export: memory error", STDERR_FILENO);
            status = 1;
            continue;
        }
        if (!is_valid_identifier(name)) {
            ft_putstr_fd("minishell: export: ", STDERR_FILENO);
            ft_putstr_fd(arg, STDERR_FILENO);
            ft_putendl_fd(": not a valid identifier", STDERR_FILENO);
            status = 1;
            free(name);
            i++;
            continue;
        }

        t_envir *node = get_env_node(data->env_list, name);
        if (node) {
            if (eq) { 
                free(node->var_value);
                node->var_value = eq ? ft_strdup(eq + 1) : ft_strdup("");
                if (!node->var_value) {
                    ft_putendl_fd("minishell: export: memory error", STDERR_FILENO);
                    status = 1;
                    free(name);
                    continue;
                }
            }
            node->visible = 1; 
        } else
        {
        t_envir *new = malloc(sizeof(t_envir));
        if (!new)
        return (status = 1, status);
        new->var_name = name; 
        new->var_value = eq ? ft_strdup(eq + 1) : ft_strdup("");
        new->visible = 1;
        new->next = data->env_list;
        new->prev = NULL;
        if (data->env_list)
        data->env_list->prev = new;
        data->env_list = new;
        free(name);
        }
        i++;
    }
    return status;
}

/*
 * execute_unset - Removes an environment variable.
 * tree->args_array[1] is the name of the variable to remove.
 */
int execute_unset(t_ast *data, t_ast *tree)
{
    int i = 1;
    int status = 0;

    while (tree->cmd->args[i])
    {
        char *name = tree->cmd->args[i];
        if (!is_valid_identifier(name))
        {
            ft_putstr_fd("minishell: unset: ", STDERR_FILENO);
            ft_putstr_fd(name, STDERR_FILENO);
            ft_putendl_fd(": not a valid identifier", STDERR_FILENO);
            status = 1;
            i++;
            continue;
        }

        t_envir *node = get_env_node(data->env_list, name);
        if (node)
        {
            // Adjust previous node's next pointer
            if (node->prev)
                node->prev->next = node->next;
            else
                data->env_list = node->next; // Update head if node is the first element

            // Adjust next node's prev pointer
            if (node->next)
                node->next->prev = node->prev;

            // Free the node's memory
            free(node->var_name);
            free(node->var_value);
            free(node);
        }
        i++;
    }
    return status;
}


/*
 * execute_exit - Exits the shell.
 * If an exit status is provided as an argument, it is used; otherwise, 0.
 * Frees allocated resources before exiting.
 */
int execute_exit(t_ast *data, t_ast *tree)
{
    int exit_status = 0;
    if (tree->cmd->args[1])
        exit_status = ft_atoi(tree->cmd->args[1]);
    free_data(data);
    exit(exit_status);
    return 0;
}

### END OF FILE: ./src/execution/builtins/builtins_utils.c ###


### START OF FILE: ./src/execution/builtins/heredoc_utils.c ###

#include "minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ioctl.h>

static int g_heredoc_sigint = 0;

static void sigint_handler(int sig) {
    (void)sig;
    g_heredoc_sigint = 1;
    ioctl(STDIN_FILENO, TIOCSTI, "\n");
}

int create_heredoc_temp_file(char *delimiter, t_ast *data) {
    int fd;
    char *line;
    char tmpname[] = "/tmp/minishell_heredoc_XXXXXX";

    fd = mkstemp(tmpname);
    if (fd < 0) return -1;

    // Add to heredoc_files for cleanup
    data->heredoc_files = realloc(data->heredoc_files, sizeof(char*) * (data->heredoc_count + 1));
    data->heredoc_files[data->heredoc_count] = ft_strdup(tmpname);
    data->heredoc_count++;

    // Set up SIGINT handler
    g_heredoc_sigint = 0;

    // Set up signal handler
    struct sigaction sa_new, sa_old;
    sa_new.sa_handler = sigint_handler;
    sigemptyset(&sa_new.sa_mask);
    sa_new.sa_flags = 0;
    sigaction(SIGINT, &sa_new, &sa_old);

    while (!g_heredoc_sigint) {
        line = readline("> ");
        if (!line) {
            ft_putstr_fd("minishell: warning: here-document delimited by end-of-file\n", STDERR_FILENO);
            break;
        }
        if (ft_strcmp(line, delimiter) == 0) {
            free(line);
            break;
        }
        dprintf(fd, "%s\n", line);
        free(line);
    }

    // Restore original signal handler
    sigaction(SIGINT, &sa_old, NULL);
    close(fd);

    // Re-open for reading
    fd = open(tmpname, O_RDONLY);
    return (g_heredoc_sigint) ? -1 : fd;
}
### END OF FILE: ./src/execution/builtins/heredoc_utils.c ###


### START OF FILE: ./src/execution/builtins/redirection_utils.c ###

#include "minishell.h"
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
// Updated get_input_file() in redirection_utils.c
int get_input_file(t_ast *data, t_ast *tree) {
    t_ast *curr = tree;
    char *last_red_inp = NULL;
    char *last_heredoc_delim = NULL;
    int heredoc_fd = -1;
    int fd = STDIN_FILENO;

    while (curr) {
        if (curr->type == AST_REDIR_IN) {
            last_red_inp = curr->token->value;
        } else if (curr->type == AST_EOF) {
            last_heredoc_delim = curr->token->value;
            heredoc_fd = create_heredoc_temp_file(last_heredoc_delim, data);
            if (heredoc_fd < 0) return -1;
            fd = heredoc_fd;
        }
        if (curr->left) {
            int left_fd = get_input_file(data, curr->left);
            if (left_fd != STDIN_FILENO) fd = left_fd;
        }
        curr = curr->right;
    }

    if (!last_heredoc_delim && last_red_inp) {
        fd = open(last_red_inp, O_RDONLY);
        if (fd < 0) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(last_red_inp, STDERR_FILENO);
            ft_putstr_fd(": ", STDERR_FILENO);
            ft_putendl_fd(strerror(errno), STDERR_FILENO);
            return -1;
        }
    }
    return fd;
}
int get_output_file(t_ast *tree) {
    t_ast *curr = tree->right; // Start with right child
    char *last_file = NULL;
    int redir_type = -1;
    int fd = STDOUT_FILENO;

    while (curr) {
        if (curr->type == AST_REDIR_OUT || curr->type == AST_REDIR_APPEND) {
            last_file = curr->token->value;
            redir_type = curr->type;
        }
        curr = curr->right; // Traverse right children
    }

    if (last_file) {
        int flags = O_WRONLY | O_CREAT;
        if (redir_type == AST_REDIR_OUT)
            flags |= O_TRUNC;
        else if (redir_type == AST_REDIR_APPEND)
            flags |= O_APPEND;

        fd = open(last_file, flags, 0644);
        if (fd < 0) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(last_file, STDERR_FILENO);
            ft_putstr_fd(": ", STDERR_FILENO);
            ft_putendl_fd(strerror(errno), STDERR_FILENO);
            return -1;
        }
    }
    return fd;
}
### END OF FILE: ./src/execution/builtins/redirection_utils.c ###


### START OF FILE: ./src/execution/execution/exec_handling.c ###

#include "../../include/minishell.h"


int execute_and(t_ast *data, t_ast *tree)
{
    int left_status = execute(data, tree->left);
    if (left_status != 0)
    {
        data->exit_status = left_status;
        return left_status;
    }
    int right_status = execute(data, tree->right);
    data->exit_status = right_status;
    return right_status;
}


int execute_or(t_ast *data, t_ast *tree)
{
    int left_status = execute(data, tree->left);
    if (left_status == 0)
    {
        data->exit_status = 0;
        return 0;
    }
    int right_status = execute(data, tree->right);
    data->exit_status = right_status;
    return right_status;
}



### END OF FILE: ./src/execution/execution/exec_handling.c ###


### START OF FILE: ./src/execution/execution/execute.c ###

#include "minishell.h"


int execute_group(t_ast *data, t_ast *tree)
{
    pid_t pid;
    int status;

    pid = fork();
    if (pid == 0)
    {
        int ret = execute(data, tree->left);
        exit(ret);
    }
    else if (pid < 0)
    {
        ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
        return (data->exit_status = 1);
    }
    waitpid(pid, &status, 0);
    if (WIFEXITED(status))
        data->exit_status = WEXITSTATUS(status);
    else
        data->exit_status = 1;
    return data->exit_status;
}


int execute_sequence(t_ast *data, t_ast *tree)
{
    execute(data, tree->left);
    return execute(data, tree->right);
}

int execute_tree(t_ast *data,t_ast *tree)
{
    if (tree->type == AST_AND || tree->type == 	AST_OR)
    {
        if (tree->type == AST_AND)
            return execute_and(data, data);
        else
            return execute_or(data, data);
    }
    else if (tree->type == AST_PIPELINE)
    {
        return execute_pipe(data, data);
    }
    else if (tree->type == AST_SUBSHELL)
    {
        return execute_group(data, data);
    }
    else if (tree->type == AST_COMMAND)
    {
        return execute_word(data, data);
    }
    return 0;
}

### END OF FILE: ./src/execution/execution/execute.c ###


### START OF FILE: ./src/execution/execution/execute_external.c ###

#include "minishell.h"
#include <sys/wait.h>
#include <unistd.h>
#include <errno.h>
#include <stdlib.h>

/* Execute an external command with proper redirections */
int execute_command(t_ast *data, t_ast *tree, int fd_inp, int fd_out)
{
    pid_t pid;
    int status;


    pid = fork();
    if (pid == 0) {
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        
        // Handle input redirection
        if (fd_inp != STDIN_FILENO) {
            if (dup2(fd_inp, STDOUT_FILENO) == -1) {
                perror("minishell: dup2 input redirection");
                exit(1);
            }
            close(fd_inp);
        }
        
        // Handle output redirection
        if (fd_out != STDOUT_FILENO) {
            if (dup2(fd_out, STDOUT_FILENO) == -1) {
                perror("minishell: dup2 output redirection");
                exit(1);
            }
            close(fd_out);
        }
        
        // Execute command
        char *cmd_path = find_executable_path(data, tree->cmd->args[0]);
        if (!cmd_path) {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
            ft_putendl_fd(": command not found", STDERR_FILENO);
            exit(127);
        }
        
        char **envp = env(&(data->env_list));
        execve(cmd_path, tree->cmd->args, envp);
        perror("minishell: execve");
        free_2darray(envp);
        exit(1);
    }
    
    // Parent process
    if (fd_inp != STDIN_FILENO)
        close(fd_inp);
    if (fd_out != STDOUT_FILENO)
        close(fd_out);
        
    waitpid(pid, &status, 0);
    
    // Cleanup heredoc files
    for (int i = 0; i < data->heredoc_count; i++) {
        unlink(data->heredoc_files[i]);
        free(data->heredoc_files[i]);
    }
    free(data->heredoc_files);
    data->heredoc_files = NULL;
    data->heredoc_count = 0;
    
    if (WIFEXITED(status))
        return WEXITSTATUS(status);
    return 1;
}

### END OF FILE: ./src/execution/execution/execute_external.c ###


### START OF FILE: ./src/execution/execution/execute_pipe.c ###

#include "minishell.h"
/* Execute a pipe command */
int execute_pipe(t_ast *data, t_ast *tree) {
    int fd[2];
    pid_t left_pid, right_pid;
    int left_status, right_status;

    if (pipe(fd) == -1) {
        perror("minishell: pipe");
        return (data->exit_status = 1);
    }

    // Fork for left command
    if ((left_pid = fork()) == 0) {
        close(fd[0]);
        dup2(fd[1], STDOUT_FILENO);
        close(fd[1]);
        exit(execute(data, tree->left));
    } else if (left_pid < 0) {
        perror("minishell: fork");
        close(fd[0]);
        close(fd[1]);
        return (data->exit_status = 1);
    }

    // Fork for right command
    if ((right_pid = fork()) == 0) {
        close(fd[1]);
        dup2(fd[0], STDIN_FILENO);
        close(fd[0]);
        exit(execute(data, tree->right));
    } else if (right_pid < 0) {
        perror("minishell: fork");
        close(fd[0]);
        close(fd[1]);
        kill(left_pid, SIGTERM); // Cleanup left child
        return (data->exit_status = 1);
    }

    // Parent process
    close(fd[0]);
    close(fd[1]);

    waitpid(left_pid, &left_status, 0);
    waitpid(right_pid, &right_status, 0);

    // Set exit status to the right child's exit code (last command)
    if (WIFEXITED(right_status))
        data->exit_status = WEXITSTATUS(right_status);
    else
        data->exit_status = 1;

    return data->exit_status;
}

### END OF FILE: ./src/execution/execution/execute_pipe.c ###


### START OF FILE: ./src/execution/execution/execute_word.c ###

#include "minishell.h"

int execute_word(t_ast *data, t_ast *tree)
{
    
    // Get input and output file descriptors
    int fd_in = get_input_file(data, tree);
    int fd_out = get_output_file(tree);
    
    if (fd_in < 0 || fd_out < 0)
    {
        if (fd_in > 0 && fd_in != STDIN_FILENO)
            close(fd_in);
        if (fd_out > 0 && fd_out != STDOUT_FILENO)
            close(fd_out);
        data->exit_status = 1;
        return 1;
    }

    char **expanded_args = expand_wildcards_in_args(tree->cmd->args);
    if (!expanded_args) {
        close(fd_in);
        close(fd_out);
        return (data->exit_status = 1);
    }

    char **original_args = tree->cmd->args;
    tree->cmd->args = expanded_args;
    // Try to execute as builtin
    if (handle_builtin(data, tree, fd_out))
    {
        tree->cmd->args = original_args;
        free_2darray(expanded_args);
        if (fd_in != STDIN_FILENO)
            close(fd_in);
        if (fd_out != STDOUT_FILENO)
            close(fd_out);
        return data->exit_status;
    }
    
    // Execute as external command
    pid_t pid = fork();
    if (pid == 0)
    {
        // Child process
        signal(SIGINT, SIG_DFL);
        signal(SIGQUIT, SIG_DFL);
        
        // Set up redirections
        if (fd_in != STDIN_FILENO)
        {
            dup2(fd_in, STDIN_FILENO);
            close(fd_in);
        }
        if (fd_out != STDOUT_FILENO)
        {
            dup2(fd_out, STDOUT_FILENO);
            close(fd_out);
        }
        
        // Execute command
        char *cmd_path = find_executable_path(data, tree->cmd->args[0]);
        if (!cmd_path)
        {
            ft_putstr_fd("minishell: ", STDERR_FILENO);
            ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
            ft_putendl_fd(": command not found", STDERR_FILENO);
            exit(127);
        }
        
        char **envp = env(&(data->env_list));
        execve(cmd_path, tree->cmd->args, envp);
        
        // If execve returns, there was an error
        ft_putstr_fd("minishell: ", STDERR_FILENO);
        ft_putendl_fd(strerror(errno), STDERR_FILENO);
        free(cmd_path);
        free_2darray(envp);
        exit(126);
    }
    else if (pid < 0)
    {
        ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
        data->exit_status = 1;
    }
    else
    {
        // Parent process
        int status;
        g_child_pid = pid;
        waitpid(pid, &status, 0);
        g_child_pid = 0; // Reset after child exi
        if (WIFEXITED(status))
            data->exit_status = WEXITSTATUS(status);
        else if (WIFSIGNALED(status))
            data->exit_status = 128 + WTERMSIG(status);
        else
            data->exit_status = 1;
    }
    
    // Clean up file descriptors
    if (fd_in != STDIN_FILENO)
        close(fd_in);
    if (fd_out != STDOUT_FILENO)
        close(fd_out);
    
    return data->exit_status;
}

### END OF FILE: ./src/execution/execution/execute_word.c ###


### START OF FILE: ./src/execution/execution/expand_wildcard.c ###

#include "minishell.h"
#include <dirent.h>

static int has_wildcard(const char *str) {
    return (ft_strchr(str, '*') != NULL);
}
static void split_pattern(const char *pattern, char **dir_part, char **file_part)
{
    char *last_slash = ft_strrchr(pattern, '/');
    
    if (last_slash)
    {
        *dir_part = ft_strndup(pattern, last_slash - pattern + 1);
        *file_part = ft_strdup(last_slash + 1);
    }
    else
    {
        *dir_part = ft_strdup(".");
        *file_part = ft_strdup(pattern);
    }
}

static char *build_full_path(const char *dir, const char *file)
{
    if (ft_strcmp(dir, ".") == 0)
        return ft_strdup(file);
    if (dir[ft_strlen(dir)-1] == '/')
        return ft_strjoin(dir, file);
    return ft_strjoin3(dir, "/", file);
}

static void sort_matches(char **matches, int count) {
    int i, j;
    char *temp;

    for (i = 0; i < count - 1; i++) {
        for (j = i + 1; j < count; j++) {
            if (ft_strcmp(matches[i], matches[j]) > 0) {
                temp = matches[i];
                matches[i] = matches[j];
                matches[j] = temp;
            }
        }
    }
}

static int is_hidden_file(const char *pattern, const char *filename) {
    return (filename[0] == '.' && (pattern[0] != '.' || ft_strcmp(pattern, ".") == 0));
}

char **expand_wildcard(char *pattern) {
    char *dir_part;
    char *file_part;
    DIR *dir;
    struct dirent *entry;

    split_pattern(pattern, &dir_part, &file_part);
    
    if (!has_wildcard(file_part) && !has_wildcard(dir_part))
    {
        free(dir_part);
        free(file_part);
        char **result = ft_calloc(2, sizeof(char *));
        result[0] = ft_strdup(pattern);
        return result;
    }

    dir = opendir(dir_part);
    if (!dir)
    {
        free(dir_part);
        free(file_part);
        return NULL;
    }

    char **matches = NULL;
    int count = 0;
    
    while ((entry = readdir(dir)) != NULL)
    {
        if (is_hidden_file(file_part, entry->d_name))
            continue;
        if (match_pattern(file_part, entry->d_name))
        {
            char *full_path = build_full_path(dir_part, entry->d_name);
            matches = ft_realloc(matches, count * sizeof(char *), (count + 1) * sizeof(char *));
            matches[count++] = full_path;
        }
    }
    closedir(dir);

    if (count == 0) {
        free(matches);
        return NULL;
    }

    sort_matches(matches, count);
    matches = ft_realloc(matches, count * sizeof(char *), (count + 1) * sizeof(char *));
    matches[count] = NULL;

    return matches;
}

char **expand_wildcards_in_args(char **args) {
    char **new_args = NULL;
    int new_count = 0;

    for (int i = 0; args[i]; i++) {
        char **matches = expand_wildcard(args[i]);
        if (!matches) {
            new_args = ft_realloc(new_args, new_count * sizeof(char *), (new_count + 1) * sizeof(char *));
            new_args[new_count++] = ft_strdup(args[i]);
        } else {
            for (int j = 0; matches[j]; j++) {
                new_args = ft_realloc(new_args, new_count * sizeof(char *), (new_count + 1) * sizeof(char *));
                new_args[new_count++] = ft_strdup(matches[j]);
            }
            free_2darray(matches);
        }
    }
    new_args = ft_realloc(new_args, new_count * sizeof(char *), (new_count + 1) * sizeof(char *));
    new_args[new_count] = NULL;
    return new_args;
}
### END OF FILE: ./src/execution/execution/expand_wildcard.c ###


### START OF FILE: ./src/execution/signals/signals.c ###


#include "../../../include/minishell.h"

static void sigint_handler(int sig) {
	(void)sig;
	if (g_child_pid == 0) {
		// Interactive shell: handle Ctrl+C
		ft_putstr_fd("\n", STDOUT_FILENO);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	} else {
		// Child process is running: forward SIGINT and avoid prompt redisplay
		ft_putstr_fd("\n", STDOUT_FILENO);
		kill(g_child_pid, SIGINT);
	}
}
void	handle_signal(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	// Setup SIGINT handler
	sa_int.sa_handler = sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);

	// Ignore SIGQUIT in the parent shell
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, NULL);
}
void	handle_sigint(int signo)
{
	if (signo == SIGINT)
	{
		if (isatty(STDIN_FILENO))
		{
			int i = write(1, "\n", 1);
			(void) i;
			if (g_child_pid == 42)
				g_child_pid = 44;
			if (g_child_pid != 0 && g_child_pid != 44)
			{
				kill(g_child_pid, SIGINT);
				g_child_pid++;
			}
			else
			{
				rl_on_new_line();
				rl_redisplay();
			}
		}
		else
			exit(EXIT_SUCCESS);
	}
}

void	handle_sigtstp_sigquit(int signo)
{
	if (signo == SIGTSTP || signo == SIGQUIT)
	{
		if (isatty(STDIN_FILENO))
		{
			if (g_child_pid == 0)
				rl_redisplay();
			else
			{
				kill(g_child_pid, signo);
				g_child_pid += 2;
			}
		}
	}
}

void	handle_c(int signo)
{
	handle_sigint(signo);
	handle_sigtstp_sigquit(signo);
}

int	handle_d(t_ast *data, char *line)
{
	(void)data;
	if (line == NULL)
	{
		rl_on_new_line();
		rl_redisplay();
	}
	if (ft_strlen(line) == 0)
	{
		ft_strdel(&line);
		return (1);
	}
	return (0);
}

### END OF FILE: ./src/execution/signals/signals.c ###


### START OF FILE: ./src/execution/utils/asterisk_utils.c ###

#include "minishell.h"


int is_only_asterisks(char *str)
{
    int i = 0;
    if (!str)
        return 0;
    while (str[i])
    {
        if (str[i] != '*')
            return 0;
        i++;
    }
    return 1;
}

### END OF FILE: ./src/execution/utils/asterisk_utils.c ###


### START OF FILE: ./src/execution/utils/env_utils.c ###

#include "../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>


char *get_env_value(t_envir *env_list, const char *key)
{
    while (env_list)
    {
        if (!ft_strcmp(env_list->var_name, key))
            return env_list->var_value;
        env_list = env_list->next;
    }
    return NULL;
}


void print_env_list(t_envir *env_list, int fd_out, int export_filter)
{
    while (env_list)
    {
        if (!export_filter || env_list->visible)
        {
            ft_putstr_fd(env_list->var_name, fd_out);
            ft_putstr_fd("=", fd_out);
            ft_putendl_fd(env_list->var_value ? env_list->var_value : "", fd_out);
        }
        env_list = env_list->next;
    }
}


char **env(t_envir **lst)
{
    t_envir *tmp = *lst;
    int count = 0;
    while (tmp) {
        if (tmp->visible) count++;
        tmp = tmp->next;
    }

    char **envp = malloc((count + 1) * sizeof(char *));
    tmp = *lst;
    int i = 0;
    while (tmp) {
        if (tmp->visible) {
            envp[i++] = ft_strjoin3(tmp->var_name, "=", tmp->var_value);
        }
        tmp = tmp->next;
    }
    envp[i] = NULL;
    return envp;
}

void incr_shell_lvl(t_ast *data)
{
    char *shlvl_str = get_env_value(data->env_list, "SHLVL");
    int shlvl = 0;
    if (shlvl_str)
        shlvl = ft_atoi(shlvl_str);
    shlvl++;
    t_envir *tmp = data->env_list;
    while (tmp)
    {
        if (!ft_strcmp(tmp->var_name, "SHLVL"))
        {
            free(tmp->var_value);
            tmp->var_value = ft_itoa(shlvl);
            return;
        }
        tmp = tmp->next;
    }
    t_envir *new_env = malloc(sizeof(t_envir));
    if (new_env)
    {
        new_env->var_name = ft_strdup("SHLVL");
        new_env->var_value = ft_itoa(shlvl);
        new_env->visible = 1;
        new_env->next = data->env_list;
        new_env->prev = NULL;
        if (data->env_list)
            data->env_list->prev = new_env;
        data->env_list = new_env;
    }
}
char *ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
    char *temp = ft_strjoin(s1, s2);
    char *result = ft_strjoin(temp, s3);
    free(temp);
    return result;
}
void set_env_var(t_ast *data, const char *var_name, const char *var_value)
{
    t_envir *env = data->env_list;
    while (env)
    {
        if (!ft_strcmp(env->var_name, var_name))
        {
            free(env->var_value);
            env->var_value = ft_strdup(var_value);
            return;
        }
        env = env->next;
    }
    t_envir *new_env = malloc(sizeof(t_envir));
    if (!new_env)
        return;
    new_env->var_name = ft_strdup(var_name);
    new_env->var_value = ft_strdup(var_value);
    new_env->visible = 1;
    new_env->next = data->env_list;
    new_env->prev = NULL;
    if (data->env_list)
        data->env_list->prev = new_env;
    data->env_list = new_env;
}

### END OF FILE: ./src/execution/utils/env_utils.c ###


### START OF FILE: ./src/execution/utils/free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: eseferi <eseferi@student.42wolfsburg.de    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/04 20:48:33 by eseferi           #+#    #+#             */
/*   Updated: 2023/11/25 05:45:51 by eseferi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->env_list)
		ft_envclear(&data->env_list);
	if (data->sorted_env_list)
		ft_envclear(&data->sorted_env_list);
	if (data->token_list)
		free_tokens(&data->token_list, free);
	if (data->curr_dir)
		ft_strdel(&data->curr_dir);
	if (data->input_line)
		ft_strdel(&data->input_line);
	if (data->root_directory && *data->root_directory)
		free_2darray(data->root_directory);
	if (data->heredoc_file)
		free_heredoc_files(data->heredoc_file);
	if (data->tree)
	{
		free_tree(&data->tree);
		data->tree = NULL;
	}
	free(data);
	data = NULL;
}

void	free_temp_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->input_line)
		ft_strdel(&data->input_line);
	if (data->token_list)
		free_tokens(&data->token_list, free);
	free(data);
	data = NULL;
}

void	free_tokens(t_token **begin, void (*del)(void *))
{
	t_token	*tmp;
	t_token	*tmp2;

	if (!begin || !del)
		return ;
	tmp = *begin;
	while (tmp)
	{
		ft_strdel(&tmp->word);
		tmp2 = tmp->next;
		free(tmp);
		tmp = tmp2;
	}
	*begin = NULL;
}

void	free_envir(t_envir *envir)
{
	t_envir	*tmp;

	if (!envir)
		return ;
	tmp = envir;
	if (tmp->var_name)
	{
		free(tmp->var_name);
		tmp->var_name = NULL;
	}
	if (tmp->var_value)
	{
		free(tmp->var_value);
		tmp->var_value = NULL;
	}
	free(tmp);
}

void	free_heredoc_files(t_heredoc_file *head)
{
	t_heredoc_file	*tmp;
	int				ret;

	while (head != NULL)
	{
		tmp = head->next;
		ret = unlink(head->filename);
		if (ret < 0)
			printf("minishell: %s\n", strerror(errno));
		free(head->filename);
		free(head);
		head = tmp;
	}
}


void	ft_strdel(char **as)
{
	if (as == 0)
		return ;
	if (*as)
		free(*as);
	*as = 0;
}


### END OF FILE: ./src/execution/utils/free.c ###


### START OF FILE: ./src/execution/utils/free2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: eseferi <eseferi@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/23 13:20:50 by ipetruni          #+#    #+#             */
/*   Updated: 2024/04/11 13:23:37 by eseferi          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_2darray(char **array)
{
	int	i;

	i = -1;
	if (!array)
		return ;
	while (array[++i])
		ft_strdel(&array[i]);
	free(array);
	array = NULL;
}

void	free_tree(t_ast **tree)
{
	t_tree	*temp_tree;
	t_tree	*left;
	t_tree	*right;

	temp_tree = *tree;
	left = NULL;
	right = NULL;
	if (!temp_tree)
		return ;
	if (temp_tree->value)
		ft_strdel(&temp_tree->value);
	if (temp_tree->args_array && *temp_tree->args_array)
		free_2darray(temp_tree->args_array);
	left = temp_tree->left;
	right = temp_tree->right;
	free(temp_tree);
	free_tree(&left);
	free_tree(&right);
}

### END OF FILE: ./src/execution/utils/free2.c ###


### START OF FILE: ./src/utils/data_handler.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   clear_data.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 13:39:34 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/20 13:45:13 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	clear_data(t_env **data, char **envp)
{
	*data = malloc(sizeof(t_env));
	if (!*data)
		exit(EXIT_FAILURE);
	(*data)->env_list = NULL;
	(*data)->heredoc_file = NULL;
	(*data)->sorted_env_list = NULL;
	(*data)->token_list = NULL;
	(*data)->input_line = NULL;
	(*data)->tree = NULL;
	(*data)->root_directory = NULL;
	(*data)->exit_status = 0;
	(*data)->input_minishell = "minishell>> ";
	(*data)->pid = getpid();
	(*data)->curr_dir = getcwd(NULL, 0);
	fill_env(envp, *data);
	incr_shell_lvl(*data);
}
void	reset_data(t_data *data)
{
	data->single_quote = 0;
	data->double_quote = 0;
	data->forked = 0;
	if (data->root_directory && *data->root_directory)
		free_2darray(data->root_directory);
	if (data->heredoc_file)
	{
		free_heredoc_files(data->heredoc_file);
		data->heredoc_file = NULL;
	}
	data->root_directory = get_root_directory();
	if (data->input_line && ft_strlen(data->input_line) > 0)
		ft_strdel(&data->input_line);
	if (data->tree)
	{
		free_tree(&data->tree);
		data->tree = NULL;
	}
	if (data->token_list)
		free_tokens(&data->token_list, free);
}
### END OF FILE: ./src/utils/data_handler.c ###


### START OF FILE: ./src/utils/errors_free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors_free.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:21:04 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:49:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	free_env_list(t_env *env_list)
{
	t_env		*temp;

	while (env_list)
	{
		temp = env_list->next;
		free(env_list->key);
		free(env_list->value);
		free(env_list);
		env_list = temp;
	}
}

t_token	*free_tokens(t_token *token)
{
	t_token		*temp;

	while (token)
	{
		temp = token->next;
		free(token->value);
		free(token);
		token = temp;
	}
	return (NULL);
}

void	report_error(t_errors_code code, char *token)
{
	if (code == ERR_UNBALANCED_PAREN)
	{
		if (token)
			printf("minishell: syntax error near unexpected token `%s'\n",
				token);
		else
			printf("minishell: syntax error: unmatched parenthesis\n");
	}
	else if (code == ERR_SYNTAX)
	{
		if (token)
			printf("minishell: syntax error near unexpected `%s'\n", token);
		else
			printf("minishell: syntax error\n");
	}
	else if (code == ERR_UNEXPECTED_TOKEN)
		printf("minishell: syntax error near unexpected token `%s'\n", token);
	else if (code == ERR_MEMORY)
		printf("minishell: memory allocation failed\n");
	else if (code == ERR_PARSE)
		printf("minishell: parse error\n");
}

### END OF FILE: ./src/utils/errors_free.c ###


### START OF FILE: ./src/utils/free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 17:25:05 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/20 17:27:27 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	free_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->env_list)
		ft_envclear(&data->env_list);
	if (data->sorted_env_list)
		ft_envclear(&data->sorted_env_list);
	if (data->token_list)
		free_tokens(&data->token_list, free);
	if (data->curr_dir)
		ft_strdel(&data->curr_dir);
	if (data->input_line)
		ft_strdel(&data->input_line);
	if (data->root_directory && *data->root_directory)
		free_2darray(data->root_directory);
	if (data->heredoc_file)
		free_heredoc_files(data->heredoc_file);
	if (data->tree)
	{
		free_tree(&data->tree);
		data->tree = NULL;
	}
	free(data);
	data = NULL;
}

void	free_heredoc_files(t_heredoc_file *head)
{
	t_heredoc_file	*tmp;
	int				ret;

	while (head != NULL)
	{
		tmp = head->next;
		ret = unlink(head->filename);
		if (ret < 0)
			printf("minishell: %s\n", strerror(errno));
		free(head->filename);
		free(head);
		head = tmp;
	}
}
void	free_envir(t_envir *envir)
{
	t_envir	*tmp;

	if (!envir)
		return ;
	tmp = envir;
	if (tmp->var_name)
	{
		free(tmp->var_name);
		tmp->var_name = NULL;
	}
	if (tmp->var_value)
	{
		free(tmp->var_value);
		tmp->var_value = NULL;
	}
	free(tmp);
}
void	free_temp_data(t_data *data)
{
	if (!data)
		return ;
	if (data->input_line)
		ft_strdel(&data->input_line);
	if (data->token_list)
		free_tokens(&data->token_list, free);
	free(data);
	data = NULL;
}
### END OF FILE: ./src/utils/free.c ###


### START OF FILE: ./src/utils/utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 17:21:58 by ldurmish          #+#    #+#             */
/*   Updated: 2025/02/24 20:25:41 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	ft_isspace(int num)
{
	if (num == ' ' || num == '\n' || num == '\t'
		|| num == '\v' || num == '\f' || num == '\r')
		return (1);
	return (0);
}

int	is_operator(char c)
{
	if (c == '&' || c == '|' || c == '(' || c == ')'
		|| c == '>' || c == '<' || c == '*')
		return (1);
	return (0);
}

int	ft_strcmp(char *s1, char *s2)
{
	int			i;

	i = 0;
	while (s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int	count_parenthesise_util(char *input)
{
	t_quotes	quotes;
	int			i;
	int			open_paren;
	int			close_paren;

	i = 0;
	open_paren = 0;
	close_paren = 0;
	quotes = (t_quotes){false, false};
	while (input[i] != '\0')
	{
		process_quotes(input[i], &quotes);
		if (!quotes.in_double_quotes && !quotes.in_single_quotes)
		{
			if (input[i] == '(')
				open_paren++;
			else if (input[i] == ')')
				close_paren++;
		}
		i++;
	}
	return (open_paren - close_paren);
}

int	count_parenthesis(t_token *tokens)
{
	int		count;
	int		total_count;

	if (!tokens)
		return (0);
	total_count = 0;
	while (tokens)
	{
		if (tokens->value)
		{
			count = count_parenthesise_util(tokens->value);
			total_count += count;
		}
		tokens = tokens->next;
	}
	return (total_count);
}

### END OF FILE: ./src/utils/utils.c ###
