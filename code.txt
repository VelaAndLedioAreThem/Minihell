

### START OF FILE: ./include/minishell.h ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 01:04:11 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/25 16:31:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <fcntl.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <sys/stat.h>
# include <signal.h>
# include <dirent.h>
# include <string.h>
# include <errno.h>
# include <termios.h>
# include <curses.h>
# include <term.h>
# include <sys/ioctl.h>
# include <readline/readline.h>
# include <readline/history.h>
# include "../libft/include/libft.h"
# define TOKEN_PROCESSED 42
# define TOKEN_READWRITE 43

// Parsing struct 
typedef enum e_token_type
{
	TOKEN_WORD,
	TOKEN_PIPE,
	TOKEN_REDIRECT_IN,
	TOKEN_REDIRECT_OUT,
	TOKEN_APPEND,
	TOKEN_HEREDOC,
	TOKEN_AND,
	TOKEN_OR,
	TOKEN_PAREN_OPEN,
	TOKEN_PAREN_CLOSE,
	TOKEN_EOF,
	TOKEN_WILDCARD,
	TOKEN_WHITESPACE
}	t_token_type;

typedef enum e_ast_type
{
	AST_COMMAND,
	AST_PIPELINE,
	AST_REDIR_IN,
	AST_REDIR_OUT,
	AST_REDIR_APPEND,
	AST_REDIR_HERDOC,
	AST_AND,
	AST_OR,
	AST_SUBSHELL,
	AST_EOF
}	t_ast_type;

// Erorrs Messages
typedef enum e_errors_code
{
	ERR_NONE,
	ERR_UNBALANCED_PAREN,
	ERR_SYNTAX,
	ERR_UNEXPECTED_TOKEN,
	ERR_MEMORY,
	ERR_PARSE
}	t_errors_code;

typedef enum e_flag_state
{
	FLAG_NONE,
	FLAG_SINGLE_DASH,
	FLAG_DOUBLE_DASH
}	t_flag_state;

typedef struct s_env
{
	char			*key;
	char			*value;
	struct s_env	*next;
}	t_env;

typedef struct s_quote
{
	bool			in_single_quotes;
	bool			in_double_quotes;
}	t_quotes;

// Parenthesis struct
typedef struct s_open_paren
{
	bool			has_commands;
	bool			expecting_commands;
	int				i;
}	t_open_paren;

typedef struct s_paren
{
	bool			has_commands;
	bool			has_content;
	char			last_op;
	bool			has_cmd_before;
	int				j;
	bool			has_operator;
	t_quotes		quote;
}	t_paren;

// Commands struct
typedef struct s_cmd
{
	bool		in_commands;
	bool		is_cmd_pos;
}	t_cmd;

typedef struct s_stack
{
	char			name;
	struct s_stack	*next;
}	t_stack;

typedef struct s_token
{
	char			*value;
	t_token_type	type;
	int				expandable;
	int				double_quotes;
	int				single_quotes;
	t_stack			*top;
	struct s_token	*next;
}	t_token;

typedef struct s_pipe
{
	t_token		*curr;
	t_token		*prev;
	t_token		*head;
	bool		expecting_command;
}	t_pipe;

typedef struct s_nest
{
	bool			success;
	t_token			*token;
	int				position;
}	t_nest;

typedef struct s_state
{
	t_quotes		quote;
	t_token			*token;
	int				pos;
	int				paren_count;
}	t_state;

typedef struct s_command
{
	char			**args;
	char			*infile;
	char			*outfile;
	char			*heredoc_delim;
	int				append;
	int				is_builtin;
}	t_commands;

typedef struct s_args
{
	int				argc;
	char			**argv;
	int				exit_status;
	char			*input;
	int				start;
	char			*result;
	int				single_quotes;
	int				double_quotes;
	int				last_quotes;
}	t_args;

// Main struct
typedef struct s_ast
{
	t_ast_type		type;
	struct s_ast	*left;
	struct s_ast	*right;
	long int		exit_status;
	t_commands		*cmd;
	int				operator_type;
	t_token			*token;
	char			**heredoc_files;
	int				heredoc_count;
	t_env			*env_list;
}	t_ast;

typedef struct s_signal
{
	struct sigaction		sa_new;
	struct sigaction		sa_old;
	volatile sig_atomic_t	sigint;
}	t_signal;

typedef int (*t_builtin_func)(t_ast *data, t_ast *tree, int fd_out);

typedef struct s_builtin {
    const char      *name;
    t_builtin_func  func;
} t_builtin;

extern pid_t	g_child_pid;

t_env		*get_env_node(t_env *env_list, const char *name);
bool		is_valid_identifier(const char *name);
void		incr_shell_lvl(t_env *data);
void		print_export_error(char *arg);
void		print_unset_error(char *name);
char		*get_export_name(char *arg, char *eq);
void		update_existing_env(t_env *env, char *eq, char *name);
int			create_new_env(t_ast *d, char *n, char *eq);
int			handle_cd_home(t_ast *data, char **path, char *old_pwd);
void		handle_cd_error(char *path, char *old_pwd);
void		free_data(t_ast *data);
void		ft_strdel(char **as);
char		*find_executable_path(t_ast *data, char *cmd);
char		**expand_wildcards_in_args(char **args);
int			get_output_file(t_ast *tree);
int			get_input_file(t_ast *data, t_ast *tree);
char		**env(t_env **lst);
int			execute_or(t_ast *data, t_ast *tree);
int			execute_and(t_ast *data, t_ast *tree);
int			execute_pipe(t_ast *data, t_ast *tree);
int			handle_builtin(t_ast *data, t_ast *tree, int fd_out);
int			execute_word(t_ast *data, t_ast *tree);
char		*ft_strndup(const char *s, size_t n);
char		*ft_strjoin3(const char *s1, const char *s2, const char *s3);
int			execute_export(t_ast *data, t_ast *tree, int fd_out);
int			create_heredoc_temp_file(char *delimiter, t_ast *data);
int			execute_unset(t_ast *data, t_ast *tree);
void		print_env_list(t_env *env_list, int fd_out);
int			execute_cd(t_ast *data, char *path);
void		set_env_var(t_ast *data, char *var_name, const char *var_value);
int			execute_pwd(t_ast *data, int fd_out);
int			execute_echo(char *args[], int fd_out);
int			execute_exit(t_ast *data, t_ast *tree);

// Tokenization functions
t_token		*create_node(char *str, t_token_type type);
t_token		*tokenize(char *input);
void		append_node(t_token **token, t_token *current_token);
int			is_operator(char c);
int			return_parenthesis(t_token **token, char c);
int			handle_double_operator(t_token **head, char *input, int *i);
int			handle_single_operator(t_token **token, char c);
int			handle_word(t_token **token, char *input, int *i);
int			handle_quotes(t_token **token, char *input, int *i);
int			handle_whitespace(t_token **token, char *input, int *i);
// Environmental variables
t_env		*init_env_list(char **envp);
char		*gen_env_value(t_env *env_list, char *key);
char		*parse_env(char *input, t_env *env_list, t_args *arg);
char		*get_env_value(t_env *env_list, char *name);
char		*join_arguments(t_args *arg);
char		*env_expansion(char *input, int *i, t_env *env_list, t_args *arg);
t_env		*deep_copy_env_list(t_env *env_list);
// Validation
bool		validation(t_token *tokens);
bool		validation_parenthesis(t_token *tokenize);

// Parenthesis
bool		check_parenthesis(t_token *token, char *input, int i,
				t_paren *commands);
void		process_quotes(char c, t_quotes *quote);
bool		valid_before_open_paren(char c);
bool		is_valid_after_open_paren(char c);
int			find_matching_paren(t_token *token, char *input, int start_pos);
bool		validate_paren_content(char *input, int start_pos, int end_pos,
				t_token *token);
t_nest		validate_nested_paren(char *input, int start, int end,
				t_token *token);
bool		op_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		pipe_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		seq_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		validate_redirect_in_paren(char *input, t_open_paren *paren,
				int end, t_token *token);
bool		validate_redirect_or_command(char *input, t_open_paren *paren,
				int end, t_token *token);
bool		validate_paren_content_utils(t_open_paren *paren, t_token *token);
bool		is_valid_close_paren(char c);
bool		process_close_paren(char *input, int i, t_token *token,
				t_paren *command);
bool		skip_whitespaces(char *input, int *i, int end);
bool		check_next_token(t_token *next);
bool		check_after_close_paren(char *input, int *i, t_token *token);
bool		it_is_log_or_pipe(char *input, int *i, t_token *token);
bool		it_is_logical_op(char *input, int *i, int *j, t_token *token);
bool		it_is_pipe(char *input, int *i, int *j, t_token *token);

// Operators
bool		ft_is_operator(char c);
bool		ft_is_logical_op(char current, char next);
bool		validate_logical_op(t_token *tokens);

// Quotes
bool		validation_quotes(t_token *tokens);

// Redirections
bool		ft_is_redirection(char c);
bool		ft_is_redirection_op(char current, char next);
bool		validate_next_redirect(t_token **next, t_token **curr);

//Commands
bool		ft_is_commands_position(char *input, int i);
bool		validate_commands(t_token *tokenize);
bool		is_valid_command_start(char c);
bool		is_valid_command_char(char c);
bool		is_command_or_arg_char(char c);
bool		is_valid_flag_char(char c);
bool		process_flag(char *str, int i,
				t_flag_state *flag_state);

// Wildcards
bool		ft_is_wildcard(char c);

// Pipes
bool		pipes(t_token *tokenize);
bool		is_operator_token(t_token *prev);
bool		has_whitespace_between(t_token *prev, t_token *curr);
bool		is_only_whitespaces(char *str);
bool		return_pipes_mssg(bool *expecting_cmd);
bool		check_redirection_before_pipe(t_token *curr, t_token *head);

// Redirect
bool		validate_redirection(t_token *tokenize);
bool		check_after_redirection(t_token **curr);

// Stack operations
void		push(t_token *stack, char data);
void		initialize_stack(t_token *stack);
char		pop(t_token *stack);
bool		is_empty(t_token *stack);

// Errors and Free functions
void		free_env_list(t_env *env_list);
t_token		*free_tokens(t_token *token);
void		report_error(t_errors_code code, char *token);
void		free_stack(t_token *token);

// Binary Tree
t_ast		*parse_tokens(t_token *tokens);
t_ast		*parse_command_line(t_token **curr);
t_ast		*parse_logic_sequence(t_token **tokens);
t_ast		*create_ast_node(t_ast_type type, t_token *token);
void		free_ast(t_ast *node);
t_ast		*parse_simple_commands(t_token **tokens);
t_commands	*create_command_struct(void);
t_ast		*create_command_node(t_token *start, int word_count);
void		skip_tree_whitespaces(t_token **tokens);
t_ast		*parse_redirection(t_token **tokens, t_ast *cmd_node);
t_ast		*parse_subshell(t_token **tokens);
t_ast		*parse_pipeline_node(t_ast *left, t_token **tokens);

// Utils functions
int			ft_strcmp(const char *s1, const char *s2);
int			count_parenthesis(t_token *tokens);
int			ft_isspace(int num);

void		clear_data(t_env **data, char **envp);
void		handle_signal(void);
void		free_2darray(char **array);
int			execute_tree(t_ast *data, t_ast *tree);

#endif

### END OF FILE: ./include/minishell.h ###


### START OF FILE: ./libft/bonus/ft_lstadd_back_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_back_bonus.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/16 20:13:28 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 12:19:45 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Add a new node with the specified content at the end of a list.
 *
 * @param lst A pointer to the pointer to the first node of the list.
 * @param new The new node to add to the end of the list.
 *
 * @details Adds the new node 'new' with the specified content to the end
 * of the list pointed to by 'lst'. Updates 'lst' if it's initially NULL.
 */

#include "libft.h"

void	ft_lstadd_back(t_list **lst, t_list *new)
{
	t_list		*last;

	if (lst == NULL || new == NULL)
	{
		return ;
	}
	if (*lst == NULL)
	{
		*lst = new;
		return ;
	}
	last = ft_lstlast(*lst);
	last -> next = new;
}
/**int main()
{
	t_list		*new;
	int			*value1;
	int			*value2;
	int			*value3;

	value1 = (int *)malloc(sizeof(int));
	if (value1 == NULL)
		return (1);
	*value1 = 54;
	new = ft_lstnew(value1);
	
	value2 = (int *)malloc(sizeof(int));
	if (value2 == NULL)
		return (1);
	*value2 = 56;
	t_list *new_node = ft_lstnew(value2);
	new -> next = new_node;

	value3 = (int *)malloc(sizeof(int));
	if (value3 == NULL)
		return (1);
	*value3 = 90;
	t_list *last_node = ft_lstnew(value3);
	if (last_node == NULL)
		return (1);
	
	ft_lstadd_back(&new, last_node);
	t_list *current = new;
	if (new != NULL)
	{
		while (current -> next != NULL)
		{
			current = current -> next;
		}
		printf("The last linked list is %d\n", *(int *)current-> content);
	}
	free(new);
	free(value1);
	free(value2);
	free(new_node);
	free(value3);
	free(last_node);
}*/
### END OF FILE: ./libft/bonus/ft_lstadd_back_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstadd_front_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstadd_front_bonus.c                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/15 14:43:06 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 12:19:14 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Add a new node with the specified content at the beginning of a list.
 *
 * @param lst A pointer to the pointer to the first node of the list.
 * @param new The new node to add to the beginning of the list.
 *
 * @details Adds the new node 'new' with the specified content to the beginning
 * of the list pointed to by 'lst'. Updates 'lst' to point to the new first node.
 */

#include "libft.h"

void	ft_lstadd_front(t_list **lst, t_list *new)
{
	if (lst == NULL || new == NULL)
		return ;
	new -> next = *lst;
	*lst = new;
}
// int main()
// {
// 	t_list		*list;
// 	int			*value1;
// 	int			*value2;
// 	int			*value3;
// 	value1 = (int *)malloc(sizeof(int));
// 	if (value1 == NULL)
// 		return (1);
// 	*value1 = 45;
// 	list = ft_lstnew(value1);
// 	if (list == NULL)
// 		return (1);
// 	value2 = (int *)malloc(sizeof(int));
// 	if (value2 == NULL)
// 		return (1);
// 	*value2 = 30;
// 	t_list	*ptr;
// 	ptr = ft_lstnew(value2);
// 	if (ptr == NULL)
// 		return (1);
// 	list -> next = ptr;
// 	value3 = (int *)malloc(sizeof(int));
// 	if (value3 == NULL)
// 		return (1);
// 	*value3 = 20;
// 	t_list *new_node = ft_lstnew(value3);
// 	ft_lstadd_front(&list, new_node);
// 	while (list != NULL)
// 	{
// 		printf("%d\n", *(int *)list -> content);
// 		list = list -> next;
// 	}
// 	free(list);
// 	free(value1);
// 	free(ptr);
// 	free(value2);
// 	free(new_node);
// 	free(value3);
// }
### END OF FILE: ./libft/bonus/ft_lstadd_front_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstclear_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstclear_bonus.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/17 13:07:29 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:23:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Delete all nodes of a list and their content using a given function.
 *
 * @param lst A pointer to the pointer to the first node of the list.
 * @param del The function used to delete the content of each node.
 *
 * @details Deletes all nodes of the list starting from
 * 'lst' and frees their content using the function 'del'. 
 * Updates 'lst' to NULL. Does nothing if 'lst' or 'del' is NULL.
 */

#include "libft.h"

/*void	del(void *ptr)
{
	free(ptr);
}*/

void	ft_lstclear(t_list **lst, void (*del)(void*))
{
	t_list		*temp;

	if (*lst == NULL || del == NULL)
		return ;
	while (*lst)
	{
		temp = (*lst)->next;
		ft_lstdelone(*lst, del);
		*lst = temp;
	}
	*lst = NULL;
}

/**int main()
{
    t_list *list;
    int *value1 = (int *)malloc(sizeof(int));
    int *value2 = (int *)malloc(sizeof(int));
    int *value3 = (int *)malloc(sizeof(int));

    if (!value1 || !value2 || !value3)
        return 1;

    *value1 = 42;
    *value2 = 58;
    *value3 = 100;

    list = ft_lstnew(value1);
    if (list == NULL)
        return 1;

    t_list *new2 = ft_lstnew(value2);
    if (new2 == NULL)
        return 1;
    list->next = new2;
    t_list *current = list;
    while (current != NULL)
    {
        printf("Node value: %d\n", *(int *)(current->content));
        current = current->next;
    }

    // Clear the list
    ft_lstclear(&list, del);

    // Ensure the list is cleared
    if (list == NULL)
        printf("List has been cleared successfully.\n");
    else
        printf("List has not been cleared successfully.\n");

    return 0;
}*/
### END OF FILE: ./libft/bonus/ft_lstclear_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstdelone_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstdelone_bonus.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/16 23:45:39 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:24:12 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Delete a node and free its content using a given function.
 *
 * @param lst The node to be deleted.
 * @param del The function used to delete the content of the node.
 *
 * @details Deletes the node 'lst' and frees its content
 * using the function 'del'.
 * The memory of 'lst' itself is also freed. 
 * Does nothing if 'lst' or 'del' is NULL.
 */

#include "libft.h"

/**void	del(void *ptr)
{
	free(ptr);
}*/

void	ft_lstdelone(t_list *lst, void (*del)(void*))
{
	if (lst == NULL)
		return ;
	if (del != NULL)
		del(lst -> content);
	free(lst);
}

/**int main()
{
    t_list            *new;
    int                *value1;
    int                *value2;
    int                *value3;

    value1 = (int *)malloc(sizeof(int));
    if (value1 == NULL)
        return (1);
    *value1 = 45;
    new = ft_lstnew(value1);
    if (new == NULL)
        return (1);
    value2 = (int *)malloc(sizeof(int));
    if (value2 == NULL)
        return (1);
    *value2 = 56;
    t_list *new_node = ft_lstnew(value2);
    new -> next = new_node;
    value3 = (int *)malloc(sizeof(int));
    if (value3 == NULL)
        return (1);
    *value3 = 20;
    t_list *last_node = ft_lstnew(value3);
	if (last_node == NULL)
		return (1);
	new -> next -> next = last_node;
	
	t_list *current = new;
	while (current != NULL)
	{
		printf("The current nodes are %d\n", *(int *)current -> content);
		current = current -> next;
	}
	current = new;
	while (current -> next != last_node)
	{
		current = current -> next;
	}
	current -> next = NULL;
	ft_lstdelone(last_node, del);
	printf("After deletion of the last nodes:\n");
	current = new;
	while (current != NULL)
	{
		printf("The nodes are %d\n", *(int *)current -> content);
		current = current -> next;
	}
	current = new;
	while (current != NULL)
	{
		t_list *temp = current -> next;
		ft_lstdelone(current, del);
		current = temp;
	}
}*/
### END OF FILE: ./libft/bonus/ft_lstdelone_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstiter_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstiter_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/18 12:05:33 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 12:20:12 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Iterate over each node of a list and apply a function to its content.
 *
 * @param lst The beginning of the list.
 * @param f The function to apply to the content of each node.
 *
 * @details Iterates over each node of the list starting from 'lst' and applies
 * the function 'f' to the content of each node.
 */

#include "libft.h"

/**void	print_content(void *ptr)
{
	int *value = (int *)ptr;
	(*value)++;
}*/

void	ft_lstiter(t_list *lst, void (*f)(void *))
{
	if (lst == NULL || f == NULL)
		return ;
	while (lst != NULL)
	{
		f(lst -> content);
		lst = lst -> next;
	}
}

/**int main()
{
	t_list		*list;
	int			*value1 = (int *)malloc(sizeof(int));
	int			*value2 = (int *)malloc(sizeof(int));
	
	if (!value1 || !value2)
		return (1);
	*value1 = 56;
	list = ft_lstnew(value1);
	*value2 = 78;
	t_list *new_node = ft_lstnew(value2);
	list -> next = new_node;
	ft_lstiter(list, print_content);
	while (list != NULL)
	{
		printf("The nodes are %d\n", *(int *)list -> content);
		list = list -> next;
	}
}*/
### END OF FILE: ./libft/bonus/ft_lstiter_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstlast_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstlast_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/16 15:21:00 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:24:34 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Find the last node of a list.
 *
 * @param lst The beginning of the list.
 * @return The last node of the list, or NULL if the list is empty.
 *
 * @details Traverses the list starting from
 * 'lst' and returns a pointer to the last node.
 * Returns NULL if 'lst' is NULL (empty list).
 */

#include "libft.h"

t_list	*ft_lstlast(t_list *lst)
{
	if (lst == NULL)
		return (NULL);
	while (lst -> next != NULL)
	{
		lst = lst -> next;
	}
	return (lst);
}

/**int main()
{
	t_list      *list;
	int         *value1;
	int         *value2;

	value1 = (int *)malloc(sizeof(int));
	if (value1 == NULL)
		return (1);
	list = ft_lstnew(value1);
	if (list == NULL)
		return (1);
	*value1 = 45;
	value2 = (int *)malloc(sizeof(int));
	if (value2 == NULL)
		return (1);
	*value2 = 54;
	t_list *new = ft_lstnew(value2);
	if (new == NULL)
		return (1);
	list -> next = new;
	t_list *last_node = ft_lstlast(list);
	if (last_node != NULL)
	{
		printf("The last node is %d\n", *(int *)last_node -> content);
	}
	free (value1);
	free (list);
	free (value2);
	free (new);
}*/
### END OF FILE: ./libft/bonus/ft_lstlast_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstmap_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstmap_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/18 13:02:27 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 11:29:37 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
** ft_lstmap:
**    Iterates the linked list 'lst' and applies the function 'f' to each
**    content. Creates a new list resulting from the applications of 'f'.
**    If the allocation fails, it cleans up the allocated memory.
**
**    lst: The original list to iterate.
**    f:   The function to apply to each content of the list.
**    del: The function to delete a single element's content.
**
** Returns:
**    A new list resulting from the applications of 'f', or NULL if the
**    allocation fails or any parameter is NULL.
*/

#include "libft.h"

// void	*increment(void *ptr)
// {
// 	int *value = (int *)ptr;
// 	(*value)++;
// 	return (value);
// }

// void	del_lstmap(void *ptr)
// {
// 	free(ptr);
// }

t_list	*ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *))
{
	t_list			*new_node;
	t_list			*new_list;
	void			*new_content;

	if (lst == NULL || f == NULL || del == NULL)
		return (NULL);
	new_list = NULL;
	while (lst != NULL)
	{
		new_content = f(lst -> content);
		new_node = ft_lstnew(new_content);
		if (!new_node)
		{
			del(new_content);
			ft_lstclear(&new_list, del);
			return (NULL);
		}
		ft_lstadd_back(&new_list, new_node);
		lst = lst -> next;
	}
	return (new_list);
}
// int main()
// {
// 	t_list		*list;
// 	int			*value1 = (int *)malloc(sizeof(int));
// 	int			*value2 = (int *)malloc(sizeof(int));

// 	if (!value1 || !value2)
// 		return (1);
// 	*value1 = 56;
// 	list = ft_lstnew(value1);
// 	*value2 = 67;
// 	t_list *new_node = ft_lstnew(value2);
// 	list -> next = new_node;
// 	t_list *current = list;
// 	printf("The original list:\n");
// 	while (current != NULL)
// 	{
// 		printf("The nodes are %d\n", *(int *)current -> content);
// 		current = current -> next;
// 	}
// 	printf("The new list is:\n");
// 	t_list	*new_list = ft_lstmap(list, increment, del_lstmap);
// 	t_list *result = new_list;
// 	while (result != NULL)
// 	{
// 		printf("The new list value are %d\n", *(int *)result -> content);
// 		result = result -> next;
// 	}
// 	ft_lstclear(&new_list, del_lstmap);
// 	ft_lstclear(&list, del_lstmap);
// }
### END OF FILE: ./libft/bonus/ft_lstmap_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstnew_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstnew_bonus.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/15 12:11:23 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:13:14 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Create a new list node.
 *
 * @param content The content to be added to the new node.
 * @return The newly allocated list node, or NULL if allocation fails.
 *
 * @details Allocates a new list node with the given content.
 * If 'content' is NULL,
 * initializes the 'content' pointer in the new node to NULL.
 */

#include "libft.h"

t_list	*ft_lstnew(void *content)
{
	t_list		*head;

	head = (t_list *)malloc(sizeof(t_list));
	if (!head)
		return (NULL);
	head -> content = content;
	head -> next = NULL;
	return (head);
}

// int main()
// {
// 	int value1 = 45;
// 	int value2 = 52;
// 	int value3 = 78;
// 	t_list	*node1 = ft_lstnew(&value1);
// 	t_list	*node2 = ft_lstnew(&value2);
// 	t_list	*node3 = ft_lstnew(&value3);
// 	t_list	*current;

// 	node1 -> next = node2;
// 	node2 -> next = node3;
// 	current = node1;
// 	while (current != NULL)
// 	{
// 		printf("The linked list is %d\n", *(int *)current -> content);
// 		current = current -> next;
// 	}
// 	current = node1;
// 	while (current != NULL)
// 	{
// 		t_list *temp = current;
// 		current = current -> next;
// 		free(temp);
// 	}
// }
### END OF FILE: ./libft/bonus/ft_lstnew_bonus.c ###


### START OF FILE: ./libft/bonus/ft_lstsize_bonus.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_lstsize_bonus.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/16 14:07:15 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:12:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Count the number of elements in a list.
 *
 * @param lst The beginning of the list.
 * @return The number of elements in the list.
 *
 * @details Counts and returns the number of nodes in
 * the list starting from 'lst'.
 */

#include "libft.h"

int	ft_lstsize(t_list *lst)
{
	int			count;

	count = 0;
	while (lst != NULL)
	{
		count++;
		lst = lst -> next;
	}
	return (count);
}

/**int main()
{
	t_list      *list;
	int         *value1;
	int         *value2;
	int			count;

	count = 0;
	value1 = (int *)malloc(sizeof(int));
	if (value1 == NULL)
		return (1);
	*value1 = 20;
	list = ft_lstnew(value1);

	value2 = (int *)malloc(sizeof(int));
	if (value2 == NULL)
		return (1);
	t_list *new = ft_lstnew(value2);
	list -> next = new;
	int length = ft_lstsize(list);
	printf("The number of nodes is %d\n", length);
	free(value1);
	free(list);
	free(value2);
	free(new);
}*/
### END OF FILE: ./libft/bonus/ft_lstsize_bonus.c ###


### START OF FILE: ./libft/include/libft.h ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   libft.h                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ledio <ledio@student.42.fr>                +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/09 21:49:14 by ldurmish          #+#    #+#             */
/*   Updated: 2025/02/14 01:32:30 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef LIBFT_H
# define LIBFT_H
# include <string.h>
# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>

typedef struct s_list
{
	void			*content;
	struct s_list	*next;
}	t_list;
void							*ft_memset(void *s, int c, size_t n);
void							ft_bzero(void *s, size_t n);
void							*ft_memcpy(void *dest,
									const void *source, size_t num);
void							*ft_memmove(void *dest,
									const void *src, size_t n);
void							*ft_memchr(const void *s, int c, size_t n);
int								ft_memcmp( const void *str1,
									const void *str2, size_t num);
int								ft_isalnum(int c);
int								ft_isalpha(int c);
int								ft_isascii(int c);
int								ft_isdigit(int c);
int								ft_isprint(int c);
int								ft_strlen(const char *str);
size_t							ft_strlcpy(char *dest,
									const char *src, size_t size);
size_t							ft_strlcat(char *dest,
									const char *src, size_t size);
int								ft_toupper(int c);
int								ft_tolower(int c);
char							*ft_strchr(const char *s, int c);
char							*ft_strrchr(const char *str, int c);
int								ft_strncmp(const char *str1,
									const char *str2, size_t n);
char							*ft_strnstr(const char *str,
									const char *subs, size_t len);
int								ft_atoi(const char *str);
char							*ft_strdup(const char *s);
void							*ft_calloc(size_t count, size_t size);
char							*ft_substr(char const *s,
									unsigned int start, size_t len);
char							*ft_strjoin(char const *s1, char const *s2);
char							*ft_strtrim(char const *s1, char const *set);
char							**ft_split(char const *s, char c);
char							*ft_itoa(int n);
char							*ft_strmapi(char const *s,
									char (*f)(unsigned int, char));
void							ft_striteri(char *s,
									void (*f)(unsigned int, char*));
void							ft_putchar_fd(char c, int fd);
void							ft_putstr_fd(char *s, int fd);
void							ft_putendl_fd(char *s, int fd);
void							ft_putnbr_fd(int n, int fd);
int								ft_lstsize(t_list *lst);
t_list							*ft_lstnew(void *content);
void							ft_lstadd_front(t_list **lst, t_list *new);
t_list							*ft_lstlast(t_list *lst);
void							ft_lstadd_back(t_list **lst, t_list *new);
void							ft_lstdelone(t_list *lst, void (*del)(void*));
void							ft_lstclear(t_list **lst, void (*del)(void*));
void							ft_lstiter(t_list *lst, void (*f)(void *));
t_list							*ft_lstmap(t_list *lst,
									void *(*f)(void *), void (*del)(void *));

#endif

### END OF FILE: ./libft/include/libft.h ###


### START OF FILE: ./libft/src/ft_atoi.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_atoi.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/10 23:49:38 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 17:39:05 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_atoi - Convert a string to an integer.
 * @str: The string to be converted.
 *
 * Description: This function takes a string 'str' and converts it to an
 * integer. The function discards any whitespace characters until the first
 * non-whitespace character is found. Then, it takes an optional plus or minus
 * sign followed by as many numerical digits as possible, and interprets them
 * as an integer. If the first non-whitespace character is not a valid integer,
 * the function returns 0.
 *
 * Return: The converted integer, or 0 if no valid conversion could be performed.
 */

#include "libft.h"

int	ft_atoi(const char *str)
{
	int			res;
	int			sign;

	res = 0;
	sign = 1;
	while (*str == ' ' || (*str >= 9 && *str <= 13))
		str++;
	if (*str == '-' || *str == '+')
	{
		if (*str == '-')
			sign = -1;
		str++;
	}
	while (*str >= '0' && *str <= '9')
	{
		res = res * 10 + (*str - '0');
		str++;
	}
	return (res * sign);
}

/**int main()
{
    printf("ft_atoi(\"42\"): %d\n", ft_atoi("42"));           
    printf("ft_atoi(\"   -42\"): %d\n", ft_atoi("   -42"));  
    printf("ft_atoi(\"4193 with words\"): %d\n", ft_atoi("4193 with words"));
    printf("ft_atoi(\"words and 987\"): %d\n", ft_atoi("words and 987"));     
    printf("ft_atoi(\"-91283472332\"): %d\n", ft_atoi("-91283472332")); 
    printf("ft_atoi(\"+\"): %d\n", ft_atoi("+")); 
    printf("ft_atoi(\"\"): %d\n", ft_atoi("")); 

    return 0;
}*/

### END OF FILE: ./libft/src/ft_atoi.c ###


### START OF FILE: ./libft/src/ft_bzero.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_bzero.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 22:13:36 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:34:40 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_bzero - Zero a block of memory.
 * @s: The memory area to be zeroed.
 * @n: The number of bytes to be zeroed.
 *
 * Description: This function sets the first 'n' bytes of the memory area
 * pointed to by 's' to zero (bytes containing '\0').
 *
 * Return: None.
 */

#include "libft.h"

void	ft_bzero(void *s, size_t n)
{
	unsigned char		*ptr;
	size_t				i;

	ptr = (unsigned char *)s;
	i = 0;
	while (i < n)
	{
		ptr[i] = 0;
		i++;
	}
}

/**int main()
{
	char s[] = "Hello";
	size_t n = 2;
	ft_bzero(s, n);
	printf("The string is ");
	for (size_t i = 0; i < sizeof(s); i++) {
		printf("%c", s[i]);
	}
	printf("\n");
}*/
### END OF FILE: ./libft/src/ft_bzero.c ###


### START OF FILE: ./libft/src/ft_calloc.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_calloc.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/11 00:36:01 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:28:59 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_calloc - Allocate and zero-initialize array.
 * @count: The number of elements to be allocated.
 * @size: The size of each element.
 *
 * Description: This function allocates memory for an array of 'count'
 * elements of 'size' bytes each and initializes all its bits to zero.
 * The memory is dynamically allocated and needs to be freed by the caller.
 *
 * Return: A pointer to the allocated memory, or NULL if the allocation fails.
 */

#include "libft.h"

void	*ft_calloc(size_t count, size_t size)
{
	size_t		i;
	char		*ptr;
	size_t		total_size;

	total_size = count * size;
	i = 0;
	ptr = malloc(total_size);
	if (count != 0 && total_size / count != size)
		return (NULL);
	if (!ptr)
		return (NULL);
	while (i < total_size)
	{
		ptr[i] = 0;
		i++;
	}
	return (ptr);
}

/**int main() {
    int num_elements = 5;
    int *arr;

    // Allocate memory for an array of integers using ft_calloc
    arr = (int *)ft_calloc(num_elements, sizeof(int));
    if (arr == NULL)
        return 1;
    // Print the values (should be initialized to 0)
    printf("Memory allocated by ft_calloc:\n");
    for (int i = 0; i < num_elements; i++)
        printf("%d ", arr[i]);
    printf("\n");
    free(arr);
    return 0;
}
*/
### END OF FILE: ./libft/src/ft_calloc.c ###


### START OF FILE: ./libft/src/ft_isalnum.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalnum.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 15:01:21 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:12:08 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Check if a character is alphanumeric (a-z, A-Z, 0-9).
 *
 * @param c The character to check.
 * @return Non-zero if 'c' is alphanumeric, 0 otherwise.
 *
 * @details Determines if the character 'c' is alphanumeric
 * (a-z, A-Z, 0-9) according to the ASCII table.
 */

#include "libft.h"

int	ft_isalnum(int c)
{
	if ((c >= 'a' && c <= 'z')
		|| (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
		return (1);
	return (0);
}

### END OF FILE: ./libft/src/ft_isalnum.c ###


### START OF FILE: ./libft/src/ft_isalpha.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isalpha.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 14:43:31 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:14:04 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_isalpha - Check if a character is alphabetic.
 * @c: The character to be checked.
 *
 * Description: This function checks if the character 'c' is an alphabetic
 * letter. An alphabetic letter is defined as either an uppercase letter
 * (A-Z) or a lowercase letter (a-z).
 *
 * Return: 1 if the character is alphabetic, 0 otherwise.
 */

#include "libft.h"

int	ft_isalpha(int c)
{
	if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))
		return (1);
	return (0);
}

### END OF FILE: ./libft/src/ft_isalpha.c ###


### START OF FILE: ./libft/src/ft_isascii.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isascii.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 15:04:53 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 12:17:00 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Check if a character is a valid ASCII character (0-127).
 *
 * @param c The character to check.
 * @return Non-zero if 'c' is an ASCII character, 0 otherwise.
 *
 * @details Determines if the character 'c' is within the ASCII range (0-127).
 */

#include "libft.h"

int	ft_isascii(int c)
{
	if (c >= 0 && c <= 127)
		return (1);
	return (0);
}

### END OF FILE: ./libft/src/ft_isascii.c ###


### START OF FILE: ./libft/src/ft_isdigit.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isdigit.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 14:53:09 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:14:47 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Check if a character is a digit (0-9).
 *
 * @param c The character to check.
 * @return Non-zero if 'c' is a digit, 0 otherwise.
 *
 * @details Determines if the character 'c'\
 * is a digit (0-9) according to the ASCII table.
 */

#include "libft.h"

int	ft_isdigit(int c)
{
	if (c >= '0' && c <= '9')
		return (1);
	return (0);
}

/**int main()
{
    char ch = '7';
    if (ft_isdigit(ch))
        printf("Character '%c' is a digit: true\n", ch);
    else
        printf("Character '%c' is a digit: false\n", ch);
    
    return 0;
}*/
### END OF FILE: ./libft/src/ft_isdigit.c ###


### START OF FILE: ./libft/src/ft_isprint.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_isprint.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 20:43:15 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 12:17:14 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Check if a character is a printable ASCII character (32-126).
 *
 * @param c The character to check.
 * @return Non-zero if 'c' is a printable ASCII character, 0 otherwise.
 *
 * @details Determines if the character 'c' is a printable ASCII character,
 * which includes characters from space (32) to tilde (126) inclusive.
 */

#include "libft.h"

int	ft_isprint(int c)
{
	if (c >= ' ' && c <= '~')
		return (1);
	return (0);
}

### END OF FILE: ./libft/src/ft_isprint.c ###


### START OF FILE: ./libft/src/ft_itoa.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_itoa.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/13 20:48:01 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 21:45:16 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_itoa - Convert an integer to a null-terminated string.
 * @n: The integer to be converted.
 *
 * Description: This function takes an integer 'n' and converts it to a string
 * representation. Memory for the resulting string is dynamically allocated
 * and needs to be freed by the caller. If the allocation fails, the function
 * returns NULL. The function handles both positive and negative integers.
 *
 * Return: A pointer to the resulting null-terminated string, or NULL if memory
 * allocation fails.
 */

#include "libft.h"

static	int	ft_num_len(int num)
{
	int		len;

	len = 0;
	if (num <= 0)
		len = 1;
	while (num)
	{
		num /= 10;
		len++;
	}
	return (len);
}

static	char	*ft_allocate_length(int length)
{
	char	*str;

	str = (char *)malloc(sizeof(char) * (length + 1));
	if (str == NULL)
		return (NULL);
	return (str);
}

char	*ft_itoa(int n)
{
	int		length;
	char	*str;
	long	num;

	num = n;
	length = ft_num_len(n);
	str = ft_allocate_length(length);
	if (!str)
		return (NULL);
	str[length--] = '\0';
	if (num < 0)
	{
		str[0] = '-';
		num = -num;
	}
	if (num == 0)
		str[0] = '0';
	while (num)
	{
		str[length] = (num % 10) + '0';
		num /= 10;
		length--;
	}
	return (str);
}

/**int main()
{
	int	num = -2147483648;
	char *str = ft_itoa(num);
	printf("The number is %d\n", num);
	if (str)
	{
		printf("The number is %s\n", str);
		free(str);
	}
	return (0);
}
**/

### END OF FILE: ./libft/src/ft_itoa.c ###


### START OF FILE: ./libft/src/ft_memchr.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/10 17:27:21 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:15:03 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_memchr - Locate a byte in memory.
 * @s: The memory area to be searched.
 * @c: The byte to be located.
 * @n: The number of bytes to be searched.
 *
 * Description: This function searches the first 'n' bytes of the memory area
 * pointed to by 's' for the first occurrence of the byte 'c'. The search stops
 * when the byte is found or 'n' bytes have been searched.
 *
 * Return: A pointer to the matching byte or NULL if the byte is not found.
 */

#include "libft.h"

void	*ft_memchr(const void *s, int c, size_t n)
{
	size_t						i;

	i = 0;
	while (i < n)
	{
		if (((unsigned char *)s)[i] == (unsigned char)c)
			return ((void *)s + i);
		i++;
	}
	return (NULL);
}

/**int main()
{
	const char str[] = "jkashd jas daksjd alksjd aksjd";
	char c = 'd';
	
	char *result = ft_memchr(str, c, 8);
	char *result1 = memchr(str, c, 8);
	printf("My ft is %p\n", result);
	printf("The og is %p\n", result1);
}*/
### END OF FILE: ./libft/src/ft_memchr.c ###


### START OF FILE: ./libft/src/ft_memcmp.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcmp.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/10 19:53:20 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 21:24:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_memcmp - Compare two blocks of memory.
 * @s1: The first memory block to be compared.
 * @s2: The second memory block to be compared.
 * @n: The number of bytes to be compared.
 *
 * Description: This function compares the first 'n' bytes of the memory
 * areas 's1' and 's2'. The comparison is done byte by byte.
 *
 * Return: An integer less than, equal to, or greater than zero if the first
 * 'n' bytes of 's1' is found, respectively, to be less than, to match, or
 * be greater than the first 'n' bytes of 's2'.
 */

#include "libft.h"

int	ft_memcmp( const void *str1, const void *str2, size_t num)
{
	const unsigned char			*ptr1;
	const unsigned char			*ptr2;
	size_t						i;

	i = 0;
	ptr1 = (unsigned char *)str1;
	ptr2 = (unsigned char *)str2;
	if (num == 0)
		return (0);
	while (i < num)
	{
		if (ptr1[i] != ptr2[i])
			return (ptr1[i] - ptr2[i]);
		i++;
	}
	return (0);
}

### END OF FILE: ./libft/src/ft_memcmp.c ###


### START OF FILE: ./libft/src/ft_memcpy.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memcpy.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 23:15:36 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:15:07 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_memcpy - Copy memory area.
 * @dst: The destination buffer where the content is to be copied.
 * @src: The source buffer from where the content is to be copied.
 * @n: The number of bytes to be copied.
 *
 * Description: This function copies 'n' bytes from memory area 'src' to
 * memory area 'dst'. The memory areas must not overlap. Use ft_memmove if
 * the memory areas do overlap.
 *
 * Return: A pointer to the destination buffer 'dst'.
 */

#include "libft.h"

void	*ft_memcpy(void	*dest, void const *src, size_t n)
{
	size_t					i;
	unsigned char			*dest_ptr;
	unsigned char			*src_ptr;

	i = 0;
	dest_ptr = (unsigned char *)dest;
	src_ptr = (unsigned char *)src;
	if (dest == src || n == 0)
		return (dest);
	if (!dest && !src)
		return (0);
	while (i < n)
	{
		dest_ptr[i] = src_ptr[i];
		i++;
	}
	return (dest);
}

### END OF FILE: ./libft/src/ft_memcpy.c ###


### START OF FILE: ./libft/src/ft_memmove.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memmove.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 22:04:08 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:15:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_memmove - Copy memory area with overlapping regions.
 * @dst: The destination buffer where the content is to be copied.
 * @src: The source buffer from where the content is to be copied.
 * @len: The number of bytes to be copied.
 *
 * Description: This function copies 'len' bytes from memory area 'src' to
 * memory area 'dst'. The memory areas may overlap, and the copy is done
 * in a safe way.
 *
 * Return: A pointer to the destination buffer 'dst'.
 */

#include "libft.h"

void	*ft_memmove(void *dest, const void *src, size_t n)
{
	size_t				i;
	unsigned char		*dest_ptr;
	unsigned char		*src_ptr;

	i = 0;
	dest_ptr = (unsigned char *)dest;
	src_ptr = (unsigned char *)src;
	if (!dest && !src)
		return (NULL);
	if (dest == src)
		return (dest);
	if (dest > src)
	{
		while (n--)
			dest_ptr[n] = src_ptr[n];
	}
	else
	{
		while (i < n)
		{
			dest_ptr[i] = src_ptr[i];
			i++;
		}
	}
	return (dest);
}

### END OF FILE: ./libft/src/ft_memmove.c ###


### START OF FILE: ./libft/src/ft_memset.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_memset.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 21:39:20 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:15:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_memset - Fill a block of memory with a specific value.
 * @b: The memory area to be filled.
 * @c: The value to be set.
 * @len: The number of bytes to be set to the value.
 *
 * Description: This function fills the first 'len' bytes of the memory area
 * pointed to by 'b' with the constant byte 'c'.
 *
 * Return: A pointer to the memory area 'b'.
 */

#include "libft.h"

void	*ft_memset(void *s, int c, size_t n)
{
	unsigned char		*ptr;
	size_t				i;

	i = 0;
	ptr = (unsigned char *)s;
	while (i < n)
	{
		ptr[i] = (unsigned char)c;
		i++;
	}
	return (s);
}

### END OF FILE: ./libft/src/ft_memset.c ###


### START OF FILE: ./libft/src/ft_putchar_fd.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putchar_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/14 15:27:44 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:15:28 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_putchar_fd - Outputs the character 'c' to the given file descriptor.
 * @c: The character to output.
 * @fd: The file descriptor on which to write.
 *
 * Description: This function writes the character 'c' to the file descriptor
 * specified by 'fd'. If writing fails, the function does not perform any
 * error handling; it is the caller's responsibility to handle errors
 * appropriately.
 *
 * Return: This function does not return a value.
 */

#include "libft.h"

void	ft_putchar_fd(char c, int fd)
{
	write(fd, &c, 1);
}

/**int main()
{
	ft_putchar_fd('H', 1);
}**/
### END OF FILE: ./libft/src/ft_putchar_fd.c ###


### START OF FILE: ./libft/src/ft_putendl_fd.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putendl_fd.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/14 19:04:01 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 17:15:34 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_putendl_fd - Output a string to a file descriptor, followed by a newline.
 * @s: The string to be output.
 * @fd: The file descriptor on which to write.
 *
 * Description: This function writes the string 's' to the given file
 * descriptor 'fd', followed by a newline character. It first checks if
 * the string is null or if the file descriptor is invalid. If either
 * condition is true, it returns without doing anything.
 *
 * Return: None.
 */

#include "libft.h"

void	ft_putendl_fd(char *s, int fd)
{
	if (!s || fd < 0)
		return ;
	write(fd, s, ft_strlen(s));
	write(fd, "\n", 1);
}

### END OF FILE: ./libft/src/ft_putendl_fd.c ###


### START OF FILE: ./libft/src/ft_putnbr_fd.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putnbr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/14 23:20:06 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 22:42:54 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_putnbr_fd - Output an integer to a file descriptor.
 * @n: The integer to be output.
 * @fd: The file descriptor on which to write.
 *
 * Description: This function writes the integer 'n' to the given file
 * descriptor 'fd'.
 *
 * Return: None.
 */

#include "libft.h"

void	ft_putnbr_fd(int n, int fd)
{
	if (n == -2147483648)
	{
		ft_putchar_fd('-', fd);
		ft_putchar_fd('2', fd);
		n = 147483648;
	}
	if (n < 0)
	{
		ft_putchar_fd('-', fd);
		n = -n;
	}
	if (n >= 10)
	{
		ft_putnbr_fd(n / 10, fd);
		ft_putnbr_fd(n % 10, fd);
	}
	else
		ft_putchar_fd(n + '0', fd);
}

/**int main()
{
	ft_putnbr_fd(-24, 1);
	ft_putchar_fd('\n', 1);
	ft_putnbr_fd(2147483647, 1);
	ft_putchar_fd('\n', 1);
	ft_putnbr_fd(-2147483648 , 1);
	ft_putchar_fd('\n', 1);
	ft_putnbr_fd(102389, 1);
}*/
### END OF FILE: ./libft/src/ft_putnbr_fd.c ###


### START OF FILE: ./libft/src/ft_putstr_fd.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_putstr_fd.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/14 18:39:42 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:37:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_putstr_fd - Output a string to a file descriptor.
 * @s: The string to be output.
 * @fd: The file descriptor on which to write.
 *
 * Description: This function writes the string 's' to the given file
 * descriptor 'fd'. It does not add a newline character.
 *
 * Return: None.
 */

#include "libft.h"

void	ft_putstr_fd(char *s, int fd)
{
	if (!s || !fd)
		return ;
	write(fd, s, ft_strlen(s));
}

/**int main()
{
	ft_putstr_fd("Hello World", 1);
}*/
### END OF FILE: ./libft/src/ft_putstr_fd.c ###


### START OF FILE: ./libft/src/ft_split.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_split.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/13 01:27:53 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 12:41:49 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_split - A function to split a string into an array of strings.
 * @s: The string to be split.
 * @c: The delimiter character used to split the string.
 *
 * Description: This function takes a string 's' and a delimiter 'c',
 * and splits 's' into an array of strings, where each element is a
 * substring of 's' that was delimited by one or more occurrences of 'c'.
 * Memory for the array is dynamically allocated and needs to be freed
 * by the caller. If the allocation fails, the function returns NULL.
 *
 * Return: A pointer to the array of split strings, or NULL if memory
 * allocation fails.
 */

#include "libft.h"

static	int	ft_count_words(const char *s, char c)
{
	int		count;
	int		words;

	count = 0;
	words = 0;
	while (*s)
	{
		if (*s != '\0' && *s != c)
		{
			if (!words)
			{
				words = 1;
				count++;
			}
		}
		else
		{
			words = 0;
		}
		s++;
	}
	return (count);
}

static	int	ft_word_len(const char *s, char c)
{
	int		len;

	len = 0;
	while (*s && *s != c)
	{
		len++;
		s++;
	}
	return (len);
}

static	char	**ft_allocate_words(int words)
{
	char		**array;
	int			i;

	array = (char **)malloc(sizeof(char *) * (words + 1));
	if (!array)
		return (NULL);
	i = 0;
	while (i <= words)
	{
		array[i] = NULL;
		i++;
	}
	return (array);
}

static	int	ft_fill_words(char **array, const char *str, char c, int words)
{
	int		i;
	int		len;

	i = 0;
	while (i < words)
	{
		while (*str == c)
			str++;
		len = ft_word_len(str, c);
		array[i] = (char *)malloc(sizeof(char) * (len + 1));
		if (!array[i])
		{
			while (i > 0)
				free(array[--i]);
			free(array);
			return (0);
		}
		ft_strlcpy(array[i], str, len + 1);
		str += len;
		i++;
	}
	return (1);
}

char	**ft_split(const char *str, char c)
{
	int			words;
	char		**array;

	words = ft_count_words(str, c);
	array = ft_allocate_words(words);
	if (!array)
		return (NULL);
	if (!(ft_fill_words(array, str, c, words)))
		return (NULL);
	array[words] = NULL;
	return (array);
}

/**int main()
{
    char *str1 = "hello world";
    char *str2 = "    hello   world   ";
    char *str3 = "hello";
    char *str4 = "";
    char *str5 = "    ";
    char *str6 = "abc:def:ghi";
    char *str7 = "abc::def:ghi";
    char *str8 = "::abc::def::ghi::";

    printf("Testing ft_split:\n");

    // Test 1: Basic split
    char **split1 = ft_split(str1, ' ');
    if (split1)
    {
        printf("Split result:\n");
        for (int i = 0; split1[i]; i++)
        {
            printf("%s\n", split1[i]);
        }
        free(split1);
    }

    // Test 2: Split with multiple delimiters
    char **split2 = ft_split(str2, ' ');
    if (split2)
    {
        printf("Split result:\n");
        for (int i = 0; split2[i]; i++)
        {
            printf("%s\n", split2[i]);
        }
        free(split2);
    }

    // Test 3: Split with no delimiter
    char **split3 = ft_split(str3, ' ');
    if (split3)
    {
        printf("Split result:\n");
        for (int i = 0; split3[i]; i++)
        {
            printf("%s\n", split3[i]);
        }
        free(split3);
    }

    // Test 4: Empty string
    char **split4 = ft_split(str4, ' ');
    if (split4)
    {
        printf("Split result:\n");
        for (int i = 0; split4[i]; i++)
        {
            printf("%s\n", split4[i]);
        }
        free(split4);
    }

    // Test 5: String with only delimiters
    char **split5 = ft_split(str5, ' ');
    if (split5)
    {
        printf("Split result:\n");
        for (int i = 0; split5[i]; i++)
        {
            printf("%s\n", split5[i]);
        }
        free(split5);
    }

    // Test 6: Split with different delimiter
    char **split6 = ft_split(str6, ':');
    if (split6)
    {
        printf("Split result:\n");
        for (int i = 0; split6[i]; i++)
        {
            printf("%s\n", split6[i]);
        }
        free(split6);
    }

    // Test 7: Split with consecutive delimiters
    char **split7 = ft_split(str7, ':');
    if (split7)
    {
        printf("Split result:\n");
        for (int i = 0; split7[i]; i++)
        {
            printf("%s\n", split7[i]);
        }
        free(split7);
    }

    // Test 8: Split with leading and trailing delimiters
    char **split8 = ft_split(str8, ':');
    if (split8)
    {
        printf("Split result:\n");
        for (int i = 0; split8[i]; i++)
        {
            printf("%s\n", split8[i]);
        }
        free(split8);
    }

    return 0;
}*/
### END OF FILE: ./libft/src/ft_split.c ###


### START OF FILE: ./libft/src/ft_strchr.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strchr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/09 22:13:35 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:10:23 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strchr - Locate the first occurrence of a character in a string.
 * @s: The string to be searched.
 * @c: The character to be located.
 *
 * Description: This function searches for the first occurrence of the
 * character 'c' in the string 's'. The terminating null byte is considered
 * part of the string, so if 'c' is '\0', the function locates the
 * terminating '\0'.
 *
 * Return: A pointer to the first occurrence of the character 'c' in the
 * string 's', or NULL if the character is not found.
 */

#include "libft.h"

char	*ft_strchr(const char *s, int c)
{
	int			i;

	i = 0;
	while (s[i] != '\0' && s[i] != (char)c)
		i++;
	if (s[i] == (char)c)
		return ((char *)&s[i]);
	return (0);
}

/**int main()
{
    char *str = "Hello, world!";
    char *ptr = ft_strchr(str, 'w');
    if (ptr)
        printf("Character 'w' found at position: %ld\n", ptr - str);
    else
        printf("Character 'w' not found\n");
    return 0;
}*/
### END OF FILE: ./libft/src/ft_strchr.c ###


### START OF FILE: ./libft/src/ft_strdup.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strdup.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/11 00:10:24 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:38:08 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strdup - Duplicate a string.
 * @s1: The string to be duplicated.
 *
 * Description: This function takes a string 's1' and allocates memory
 * to create a copy of it. The copy is created and a pointer to it is
 * returned. The memory for the new string is dynamically allocated
 * and should be freed by the caller. If the allocation fails, the
 * function returns NULL.
 *
 * Return: A pointer to the duplicated string, or NULL if memory
 * allocation fails.
 */

#include "libft.h"

char	*ft_strdup(const char *s)
{
	int			len;
	char		*result;

	len = ft_strlen(s);
	result = ((char *)malloc(sizeof(char) * (len + 1)));
	if (result == NULL)
		return (NULL);
	len = 0;
	while (s[len] != '\0')
	{
		result[len] = s[len];
		len++;
	}
	result[len] = '\0';
	return (result);
}

### END OF FILE: ./libft/src/ft_strdup.c ###


### START OF FILE: ./libft/src/ft_striteri.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_striteri.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/14 13:08:52 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:38:13 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief This function applies function "f" on each character of
 * the string passed as argument, passing its index as first argument.
 * Each character is passed by address to "f" to be modified if necessary.
 * 
 * @param s The string on which to iterate.
 * @param f The function to apply to each character.
 */

#include "libft.h"

/**void	to_upper(unsigned int i, char *str)
{
	if (*str >= 'a' && *str <= 'z')
	{
		*str -= 32;
	}
	printf("%d : %c\n", i, *str);
}**/

void	ft_striteri(char *s, void (*f)(unsigned int, char *))
{
	unsigned int		i;

	if (!s || !f)
		return ;
	i = 0;
	while (s[i] != '\0')
	{
		f(i, &s[i]);
		i++;
	}
}

/**int main()
{
	char s[] = "hello, world";
	printf("The first string is %s\n", s);
	ft_striteri(s, to_upper);
	return (0);	
}**/
### END OF FILE: ./libft/src/ft_striteri.c ###


### START OF FILE: ./libft/src/ft_strjoin.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strjoin.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/11 21:21:11 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:19:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Concatenate two strings into a new allocated string.
 *
 * @param s1 The first string.
 * @param s2 The second string.
 * @return The newly allocated string resulting from the
 * concatenation of 's1' and 's2',
 * or NULL if memory allocation fails.
 *
 * @details Allocates a new string that is the concatenation of
 * 's1' and 's2'. 
 * The memory for the new string is dynamically allocated.
 * Returns NULL if memory allocation fails.
 */

#include "libft.h"

char	*ft_strjoin(char const *s1, char const *s2)
{
	size_t			index;
	size_t			total_length;
	char			*result;

	if (!s1 || !s2)
		return (NULL);
	total_length = ft_strlen(s1) + ft_strlen(s2) + 1;
	result = (char *)malloc(sizeof(char) * total_length);
	if (!result)
		return (NULL);
	index = 0;
	while (*s1)
		result[index++] = *s1++;
	while (*s2)
		result[index++] = *s2++;
	result[index] = '\0';
	return (result);
}

### END OF FILE: ./libft/src/ft_strjoin.c ###


### START OF FILE: ./libft/src/ft_strlcat.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcat.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/09 20:49:42 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:38:22 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strlcat - Concatenate strings with size limit.
 * @dst: The destination buffer where the string is to be concatenated.
 * @src: The source string to be appended.
 * @dstsize: The size of the destination buffer.
 *
 * Description: This function appends the null-terminated string 'src' to
 * the end of 'dst'. It will append at most 'dstsize - strlen(dst) - 1' bytes,
 * null-terminating the result. If 'dstsize' is 0 or less than the length of
 * 'dst', it only returns the length of 'src' plus 'dstsize'.
 *
 * Return: The total length of the string it tried to create, which is the
 * initial length of 'dst' plus the length of 'src'.
 */

#include "libft.h"

size_t	ft_strlcat(char *dest, const char *src, size_t size)
{
	size_t		i;
	size_t		len_dest;
	size_t		len_src;

	i = 0;
	len_dest = ft_strlen(dest);
	len_src = ft_strlen(src);
	if (size == 0 || len_dest >= size)
		return (size + len_src);
	while (i < (size - len_dest - 1) && src[i] != '\0')
	{
		dest[len_dest + i] = src[i];
		i++;
	}
	dest[len_dest + i] = '\0';
	return (len_dest + len_src);
}

// int main()
// {
// 	const char src[] = "Workbitch, asda";
// 	char dest[20] = "U better";
// 	size_t result = ft_strlcat(dest, src, 14);
// 	printf("The source is %s\n", src);
// 	printf("The dest is %s\n", dest);
// 	printf("The length is %zu\n", result);
// }
### END OF FILE: ./libft/src/ft_strlcat.c ###


### START OF FILE: ./libft/src/ft_strlcpy.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlcpy.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/09 20:09:16 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 21:35:22 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strlcpy - Copy a string to a buffer with size limit.
 * @dst: The destination buffer where the string is to be copied.
 * @src: The source string to be copied.
 * @dstsize: The size of the destination buffer.
 *
 * Description: This function copies up to 'dstsize - 1' characters from
 * the null-terminated string 'src' to 'dst', null-terminating the result.
 * If 'dstsize' is 0, the function does nothing.
 *
 * Return: The total length of the string it tried to create, which is
 * the length of 'src'.
 */

#include "libft.h"

size_t	ft_strlcpy(char *dest, const char *src, size_t size)
{
	size_t	i;
	size_t	src_len;

	src_len = ft_strlen(src);
	i = 0;
	if (!dest || !src)
		return (0);
	if (size == 0)
		return (ft_strlen(src));
	while (src[i] != '\0' && i < size - 1)
	{
		dest[i] = src[i];
		i++;
	}
	if (size != 0)
		dest[i] = '\0';
	return (src_len);
}

### END OF FILE: ./libft/src/ft_strlcpy.c ###


### START OF FILE: ./libft/src/ft_strlen.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strlen.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/08 20:54:12 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:09:49 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strlen - Calculate the length of a string.
 * @str: The string to calculate the length of.
 *
 * Description: This function takes a string 'str' and returns its
 * length, not including the terminating null byte ('\0'). The function
 * iterates through the string until it encounters the null byte.
 *
 * Return: The length of the string.
 */

#include "libft.h"

int	ft_strlen(const char *str)
{
	int		len;

	len = 0;
	while (str[len] != '\0')
		len++;
	return (len);
}

/**int main()
{
    char *str = "Hello, world!";
    size_t len = ft_strlen(str);
    printf("Length of '%s' is %zu\n", str, len);
    return 0;
}*/
### END OF FILE: ./libft/src/ft_strlen.c ###


### START OF FILE: ./libft/src/ft_strmapi.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strmapi.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/14 11:28:49 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/21 14:09:53 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strmapi - Apply a function to each character of a string.
 * @s: The input string.
 * @f: The function to apply to each character.
 *
 * Description: Applies the function 'f' to each character of the string 's',
 * passing the character's index as the first argument to 'f', and creates a new
 * string with the results. The new string is dynamically allocated and must be
 * freed by the caller.
 *
 * Return: A pointer to the new string, or NULL if memory allocation fails.
 */

#include "libft.h"

/**char	ft_transform(unsigned int i, char c)
{
	if (i % 2 == 0)
		return (ft_toupper(c));
	else
		return (ft_tolower(c));
	return (c);
}**/

char	*ft_strmapi(char const *s, char (*f)(unsigned int, char))
{
	size_t				i;
	size_t				length;
	char				*str;

	if (!s || !f)
		return (NULL);
	length = ft_strlen(s);
	str = (char *)malloc(sizeof(char) * (length + 1));
	if (!str)
		return (NULL);
	i = 0;
	while (i < length)
	{
		str[i] = f(i, s[i]);
		i++;
	}
	str[i] = '\0';
	return (str);
}

/**int main()
{
	char original[] = "Hello, WORld";
	char *transformed = ft_strmapi(original, ft_transform);
	if (transformed)
	{
		printf("The original string is %s\n", original);
		printf("The transformed string is %s\n", transformed);
		free(transformed);
	}
}
**/

### END OF FILE: ./libft/src/ft_strmapi.c ###


### START OF FILE: ./libft/src/ft_strncmp.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strncmp.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/10 16:45:01 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 21:09:32 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strncmp - Compare two strings up to a specified number of characters.
 * @s1: The first string to be compared.
 * @s2: The second string to be compared.
 * @n: The maximum number of characters to compare.
 *
 * Description: This function compares up to 'n' characters of the strings
 * 's1' and 's2'. The comparison is done lexicographically. It stops comparing
 * either after 'n' characters have been compared, or a null character is
 * encountered.
 *
 * Return: An integer less than, equal to, or greater than zero if 's1' is
 * found, respectively, to be less than, to match, or be greater than 's2'.
 */

#include "libft.h"

int	ft_strncmp(const char *str1, const char *str2, size_t n)
{
	size_t	i;

	i = 0;
	if (n == 0)
		return (0);
	while (str1[i] != '\0' && str2[i] != '\0'
		&& str1[i] == str2[i] && i < n - 1)
		i++;
	return ((unsigned char)str1[i] - (unsigned char)str2[i]);
}

### END OF FILE: ./libft/src/ft_strncmp.c ###


### START OF FILE: ./libft/src/ft_strnstr.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strnstr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/10 22:27:39 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:38:44 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strnstr - Locate a substring in a string with length limit.
 * @haystack: The string to be searched.
 * @needle: The substring to be located.
 * @len: The maximum number of characters to search.
 *
 * Description: This function locates the first occurrence of the null-terminated
 * string 'needle' in the string 'haystack', where not more than 'len' characters
 * are searched. Characters after a '\0' are not searched.
 *
 * Return: A pointer to the first character of the first occurrence of 'needle',
 * or NULL if 'needle' is not found.
 */

#include "libft.h"

char	*ft_strnstr(const char *str, const char *subs, size_t len)
{
	size_t				i;
	size_t				j;

	i = 0;
	if (*subs == '\0')
		return ((char *)str);
	while (i < len && str[i] != '\0')
	{
		j = 0;
		while (str[i + j] == subs[j] && i + j < len)
		{
			if (subs[j + 1] == '\0')
				return ((char *)&str[i]);
			j++;
		}
		i++;
	}
	return (NULL);
}

### END OF FILE: ./libft/src/ft_strnstr.c ###


### START OF FILE: ./libft/src/ft_strrchr.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strrchr.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/10 15:21:34 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:38:49 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_strrchr - Locate the last occurrence of a character in a string.
 * @s: The string to be searched.
 * @c: The character to be located.
 *
 * Description: This function searches for the last occurrence of the
 * character 'c' in the string 's'. The terminating null byte is considered
 * part of the string, so if 'c' is '\0', the function locates the
 * terminating '\0'.
 *
 * Return: A pointer to the last occurrence of the character 'c' in the
 * string 's', or NULL if the character is not found.
 */

#include "libft.h"

char	*ft_strrchr(const char *str, int c)
{
	int			i;
	char		*ptr;

	i = ft_strlen(str);
	while (i >= 0)
	{
		if (str[i] == (char)c)
		{
			ptr = (char *)&str[i];
			return (ptr);
		}
		i--;
	}
	return (NULL);
}

### END OF FILE: ./libft/src/ft_strrchr.c ###


### START OF FILE: ./libft/src/ft_strtrim.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_strtrim.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/11 23:04:53 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:20:20 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Trim leading and trailing whitespaces from a string.
 *
 * @param s The string to be trimmed.
 * @param set The set of characters to trim.
 * @return The trimmed string, or NULL if memory allocation fails.
 *
 * @details Allocates and returns a copy of the string 's' with the leading and
 * trailing characters from the 'set' removed.
 * The 'set' characters are considered to be whitespaces.
 * Returns NULL if memory allocation fails.
 */

#include "libft.h"

char	*ft_strtrim(char const *s1, char const *set)
{
	size_t			start;
	size_t			end;
	size_t			length;
	char			*trim;

	start = 0;
	end = ft_strlen(s1);
	if (!s1 || !set)
		return (NULL);
	while (s1[start] != '\0' && ft_strchr(set, s1[start]))
		start++;
	while (end > start && ft_strchr(set, s1[end - 1]))
		end--;
	length = end - start;
	trim = malloc(sizeof(char) * length + 1);
	if (!trim)
		return (NULL);
	ft_strlcpy(trim, &s1[start], length + 1);
	return (trim);
}

### END OF FILE: ./libft/src/ft_strtrim.c ###


### START OF FILE: ./libft/src/ft_substr.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_substr.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/11 16:28:46 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/19 13:23:23 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * @brief Extract a substring from a string.
 *
 * @param s The string from which to extract the substring.
 * @param start The starting index of the substring in 's'.
 * @param len The maximum length of the substring.
 * @return The substring extracted from 's', or NULL
 * If memory allocation fails or 'start' is out of range.
 *
 * @details Allocates and returns a substring from the string 's' 
 * beginning at index 'start' for up to 'len' characters.
 * The substring is terminated with '\0'. 
 * If 'start' is beyond the end of 's', the function returns NULL. 
 * Returns NULL if memory allocation fails.
 */

#include "libft.h"

char	*ft_substr(const char *s, unsigned int start, size_t len)
{
	char			*substring;
	size_t			str_len;
	size_t			sub_length;

	if (!s)
		return (NULL);
	str_len = ft_strlen(s);
	if (start >= str_len)
		return (ft_strdup(""));
	if (len < str_len - start)
		sub_length = len;
	else
		sub_length = str_len - start;
	substring = (char *)malloc(sizeof(char) * (sub_length + 1));
	if (!substring)
		return (NULL);
	ft_strlcpy(substring, s + start, sub_length + 1);
	return (substring);
}
/**int main()
{
    char *s = "Hello, world!";
    char *substr;

    substr = ft_substr(s, 7, 5);
    printf("Substring 1: \"%s\"\n", substr); // Expected: "world"
    free(substr);

    substr = ft_substr(s, 0, 20);
    printf("Substring 2: \"%s\"\n", substr); // Expected: "Hello, world!"
    free(substr);

    substr = ft_substr(s, 15, 5);
    printf("Substring 3: \"%s\"\n", substr); // Expected: ""
    free(substr);

    substr = ft_substr(NULL, 0, 5);
    printf("Substring 4: \"%s\"\n", substr); // Expected: NULL
    free(substr);

    return 0;
}*/

### END OF FILE: ./libft/src/ft_substr.c ###


### START OF FILE: ./libft/src/ft_tolower.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_tolower.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/09 22:10:30 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:39:05 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_tolower - Convert an uppercase letter to a lowercase letter.
 * @c: The character to be converted.
 *
 * Description: This function converts an uppercase letter to the
 * corresponding lowercase letter. If the character is not an uppercase
 * letter, it is returned unchanged.
 *
 * Return: The lowercase equivalent of the character if it is an uppercase
 * letter, otherwise the character itself.
 */

#include "libft.h"

int	ft_tolower(int c)
{
	if (c >= 'A' && c <= 'Z')
		c += 32;
	return (c);
}

### END OF FILE: ./libft/src/ft_tolower.c ###


### START OF FILE: ./libft/src/ft_toupper.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ft_toupper.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish <ldurmish@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/06/09 21:52:52 by ldurmish          #+#    #+#             */
/*   Updated: 2024/06/18 20:39:09 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/**
 * ft_toupper - Convert a lowercase letter to an uppercase letter.
 * @c: The character to be converted.
 *
 * Description: This function converts a lowercase letter to the
 * corresponding uppercase letter. If the character is not a lowercase
 * letter, it is returned unchanged.
 *
 * Return: The uppercase equivalent of the character if it is a lowercase
 * letter, otherwise the character itself.
 */

#include "libft.h"

int	ft_toupper(int c)
{
	if (c >= 'a' && c <= 'z')
		c -= 32;
	return (c);
}

### END OF FILE: ./libft/src/ft_toupper.c ###


### START OF FILE: ./src/execution/builtins/builtins.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	builtin_export(t_ast *data, t_ast *tree, int fd_out)
{
	if (!tree->cmd->args[1])
		print_env_list(data->env_list, fd_out);
	else
		execute_export(data, tree, fd_out);
	return (1);
}

static int	builtin_unset(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_unset(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_env(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	print_env_list(data->env_list, fd_out);
	return (1);
}

int	execute_home(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "HOME");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	return (0);
}

int	execute_oldpwd(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "OLDPWD");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: OLDPWD not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	ft_putendl_fd(path, STDOUT_FILENO);
	return (0);
}

static int	builtin_cd(t_ast *data, t_ast *tree, int fd_out)
{
	char	*path;
	char	*oldpwd;

	(void)fd_out;
	path = tree->cmd->args[1];
	oldpwd = getcwd(NULL, 0);
	if (!path || !ft_strcmp(path, "~"))
	{
		execute_home(data, path, oldpwd);
	}
	else if (!ft_strcmp(path, "-"))
	{
		execute_oldpwd(data, path, oldpwd);
	}
	if (execute_cd(data, path))
	{
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	set_env_var(data, "OLDPWD", oldpwd);
	free(oldpwd);
	return (1);
}

static int	builtin_pwd(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	if (execute_pwd(data, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_echo(t_ast *data, t_ast *tree, int fd_out)
{
	if (execute_echo(tree->cmd->args, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_exit(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_exit(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static const t_builtin	g_builtins[] = {
{"export", builtin_export},
{"unset", builtin_unset},
{"env", builtin_env},
{"cd", builtin_cd},
{"pwd", builtin_pwd},
{"echo", builtin_echo},
{"exit", builtin_exit},
{NULL, NULL}
};

int	handle_builtin(t_ast *data, t_ast *tree, int fd_out)
{
	int	i;

	i = 0;
	if (!tree->cmd->args || !tree->cmd->args[0])
		return (0);
	while (g_builtins[i].name)
	{
		if (!ft_strcmp(tree->cmd->args[0], g_builtins[i].name))
			return (g_builtins[i].func(data, tree, fd_out));
		i++;
	}
	return (0);
}

### END OF FILE: ./src/execution/builtins/builtins.c ###


### START OF FILE: ./src/execution/builtins/builtins_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

bool	is_valid_identifier(const char *name)
{
	if (!name || !*name || ft_isdigit(*name))
		return (false);
	while (*name)
	{
		if (!ft_isalnum(*name) && *name != '_')
			return (false);
		name++;
	}
	return (true);
}

t_env	*get_env_node(t_env *env_list, const char *name)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (strcmp(current->key, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

static void	update_env_var(t_ast *data, const char *key, const char *value)
{
	t_env	*env;
	t_env	*new_env;

	env = get_env_node(data->env_list, key);
	if (env)
	{
		free(env->value);
		env->value = ft_strdup(value);
	}
	else
	{
		new_env = malloc(sizeof(t_env));
		new_env->key = ft_strdup(key);
		new_env->value = ft_strdup(value);
		new_env->next = data->env_list;
		data->env_list = new_env;
	}
}

int	execute_pwd(t_ast *data, int fd_out)
{
	char	*cwd;

	(void)data;
	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		ft_putendl_fd("minishell: pwd: error retrieving current directory",
			STDERR_FILENO);
		return (1);
	}
	ft_putendl_fd(cwd, fd_out);
	free(cwd);
	return (0);
}

int	execute_echo(char *args[], int fd_out)
{
	int	i;
	int	n_flag;

	i = 1;
	n_flag = 1;
	if (args[1] && !ft_strcmp(args[1], "-n"))
	{
		n_flag = 0;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], fd_out);
		if (args[i + 1])
			ft_putstr_fd(" ", fd_out);
		i++;
	}
	if (n_flag)
		ft_putendl_fd("", fd_out);
	return (0);
}

static int	handle_pwd_errors(char *old_pwd, int error_code)
{
	free(old_pwd);
	ft_putendl_fd(" error retrieving current directory", STDERR_FILENO);
	return (error_code);
}

static int	update_directory(t_ast *data, char *path, char *old_pwd)
{
	char	*new_pwd;

	if (chdir(path) != 0)
	{
		ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
		ft_putendl_fd(strerror(errno), STDERR_FILENO);
		free(old_pwd);
		return (1);
	}
	new_pwd = getcwd(NULL, 0);
	if (!new_pwd)
		return (handle_pwd_errors(old_pwd, 1));
	update_env_var(data, "OLDPWD", old_pwd);
	update_env_var(data, "PWD", new_pwd);
	free(old_pwd);
	free(new_pwd);
	return (0);
}

int	execute_cd(t_ast *data, char *path)
{
	char	*old_pwd;
	t_env	*home;

	old_pwd = getcwd(NULL, 0);
	if (!old_pwd)
		return (handle_pwd_errors(NULL, 1));
	if (!path)
	{
		home = get_env_node(data->env_list, "HOME");
		if (!home || !home->value)
		{
			ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
			free(old_pwd);
			return (1);
		}
		path = home->value;
	}
	return (update_directory(data, path, old_pwd));
}

int	create_new_env(t_ast *d, char *n, char *eq)
{
	t_env	*env;

	env = malloc(sizeof(t_env));
	if (!env)
		return (free(n), 1);
	env->key = n;
	if (eq)
		env->value = ft_strdup(eq + 1);
	else
		env->value = ft_strdup("");
	env->next = d->env_list;
	d->env_list = env;
	return (0);
}

int	execute_exit(t_ast *data, t_ast *tree)
{
	int	status;

	status = 0;
	if (tree->cmd->args[1])
		status = ft_atoi(tree->cmd->args[1]);
	free_data(data);
	exit (status);
	return (0);
}

### END OF FILE: ./src/execution/builtins/builtins_utils.c ###


### START OF FILE: ./src/execution/builtins/heredoc_utils.c ###

#include "minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <fcntl.h>
#include <signal.h>
#include <sys/ioctl.h>

static	void	handle_sigint(int sig, siginfo_t *info, void *context)
{
	(void)sig;
	(void)info;
	(void)context;
	ioctl(STDIN_FILENO, TIOCSTI, "\n");
}

static void	configure_signals(t_signal *sig)
{
	sig->sa_new.sa_sigaction = handle_sigint;
	sigemptyset(&sig->sa_new.sa_mask);
	sig->sa_new.sa_flags = SA_SIGINFO;
	sigaction(SIGINT, &sig->sa_new, &sig->sa_old);
}

static int	process_input_loop(int fd, char *delimiter, t_signal *sig)
{
	char	*line;
	int		result;

	result = 0;
	while (!sig->sigint)
	{
		line = readline("> ");
		if (!line)
		{
			ft_putstr_fd("minishell: warning: here-doc delimited by EOF\n", 2);
			break ;
		}
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		dprintf(fd, "%s\n", line);
		free(line);
	}
	if (sig->sigint)
		result = -1;
	return (result);
}

int	create_heredoc_temp_file(char *delimiter, t_ast *data)
{
	t_signal	sig;
	char		*tmpname;
	int			fd;

	tmpname = "/tmp/minishell_heredoc_XXXXXX";
	fd = mkstemp(tmpname);
	if (fd < 0)
		return (-1);
	configure_signals(&sig);
	data->heredoc_files = realloc(data->heredoc_files,
			sizeof(char *) * (data->heredoc_count + 1));
	data->heredoc_files[data->heredoc_count] = ft_strdup(tmpname);
	data->heredoc_count++;
	if (process_input_loop(fd, delimiter, &sig) == -1)
		return (-1);
	sigaction(SIGINT, &sig.sa_old, NULL);
	close(fd);
	return (open(tmpname, O_RDONLY));
}

### END OF FILE: ./src/execution/builtins/heredoc_utils.c ###


### START OF FILE: ./src/execution/builtins/redirection_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirection_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/20 12:42:00 by user              #+#    #+#             */
/*   Updated: 2025/04/07 15:39:20 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

static void	print_error(char *filename, char *error_msg)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(filename, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putendl_fd(error_msg, STDERR_FILENO);
}

static int	open_regular_input(char *last_red_inp)
{
	int	fd;

	fd = open(last_red_inp, O_RDONLY);
	if (fd < 0)
	{
		print_error(last_red_inp, strerror(errno));
		return (-1);
	}
	return (fd);
}
/* ==================== INPUT FILE HANDLING ==================== */

static void	handle_redir_in(t_ast *node, char **last_red_inp)
{
	if (node->type == AST_REDIR_IN)
		*last_red_inp = node->token->value;
}

static int	hh(t_ast *node, t_ast *data, char **delim, int *fd)
{
	if (node->type == AST_EOF)
	{
		*delim = node->token->value;
		*fd = create_heredoc_temp_file(*delim, data);
		if (*fd < 0)
			return (-1);
	}
	return (0);
}

int	get_input_file(t_ast *data, t_ast *tree)
{
	t_ast	*curr;
	char	*last_red_inp;
	char	*lhd;
	int		fd;

	curr = tree;
	last_red_inp = NULL;
	lhd = NULL;
	fd = STDIN_FILENO;
	while (curr)
	{
		handle_redir_in(curr, &last_red_inp);
		if (curr->type == AST_EOF && hh(curr, data, &lhd, &fd) == -1)
			return (-1);
		if (curr->left)
		{
			fd = get_input_file(data, curr->left);
			if (fd == -1)
				return (-1);
		}
		curr = curr->right;
	}
	if (!lhd && last_red_inp)
		fd = open_regular_input(last_red_inp);
	return (fd);
}

static void	find_last_output_redirection(t_ast *curr, char **file, int *type)
{
	while (curr)
	{
		if (curr->type == AST_REDIR_OUT || curr->type == AST_REDIR_APPEND)
		{
			*file = curr->token->value;
			*type = curr->type;
		}
		curr = curr->right;
	}
}

static int	open_output_file(char *filename, int redir_type)
{
	int	flags;
	int	fd;

	flags = O_WRONLY | O_CREAT;
	if (redir_type == AST_REDIR_OUT)
		flags |= O_TRUNC;
	else if (redir_type == AST_REDIR_APPEND)
		flags |= O_APPEND;
	fd = open(filename, flags, 0644);
	if (fd < 0)
		print_error(filename, strerror(errno));
	return (fd);
}

int	get_output_file(t_ast *tree)
{
	char	*last_file;
	int		redir_type;
	int		fd;

	last_file = NULL;
	redir_type = -1;
	fd = STDOUT_FILENO;
	find_last_output_redirection(tree->right, &last_file, &redir_type);
	if (last_file)
	{
		fd = open_output_file(last_file, redir_type);
		if (fd < 0)
			return (-1);
	}
	return (fd);
}

### END OF FILE: ./src/execution/builtins/redirection_utils.c ###


### START OF FILE: ./src/execution/env/env_export.c ###

#include "../../../include/minishell.h"

static void	update_env_variable(t_env *env, char *name, char *eq)
{
	if (eq)
	{
		free(env->value);
		env->value = ft_strdup(eq + 1);
	}
	free(name);
}

static int	handle_export_error(char *arg)
{
	ft_putstr_fd("minishell: export: `", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}
static int	process_export_arg(t_ast *data, char *arg)
{
	char	*eq;
	char	*name;
	t_env	*env;

	eq = ft_strchr(arg, '=');
	if (eq)
		name = ft_substr(arg, 0, eq - arg);
	else
		name = ft_strdup(arg);
	if (!name || !is_valid_identifier(name))
		return (free(name), handle_export_error(arg));
	env = get_env_node(data->env_list, name);
	if (env)
		update_env_variable(env, name, eq);
	else if (create_new_env(data, name, eq))
		return (1);
	return (0);
}

int	execute_export(t_ast *data, t_ast *tree, int fd_out)
{
	int		i;
	int		status;

	(void)fd_out;
	i = 1;
	status = 0;
	while (tree->cmd->args[i])
	{
		if (process_export_arg(data, tree->cmd->args[i]))
			status = 1;
		i++;
	}
	return (status);
}

### END OF FILE: ./src/execution/env/env_export.c ###


### START OF FILE: ./src/execution/env/env_unset.c ###

#include "../../../include/minishell.h"

static void	remove_env_node(t_ast *data, t_env *prev, t_env *curr)
{
	if (prev)
		prev->next = curr->next;
	else
		data->env_list = curr->next;
	free(curr->key);
	free(curr->value);
	free(curr);
}

static int	handle_unset_error(char *name)
{
	ft_putstr_fd("minishell: unset: `", STDERR_FILENO);
	ft_putstr_fd(name, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}
static int	process_unset_arg(t_ast *data, char *name)
{
	t_env	*prev;
	t_env	*curr;

	if (!is_valid_identifier(name))
		return (handle_unset_error(name));
	prev = NULL;
	curr = data->env_list;
	while (curr)
	{
		if (!ft_strcmp(curr->key, name))
		{
			remove_env_node(data, prev, curr);
			break ;
		}
		prev = curr;
		curr = curr->next;
	}
	return (0);
}

int	execute_unset(t_ast *data, t_ast *tree)
{
	int	i;

	i = 1;
	while (tree->cmd->args[i])
	{
		process_unset_arg(data, tree->cmd->args[i]);
		i++;
	}
	return (0);
}

### END OF FILE: ./src/execution/env/env_unset.c ###


### START OF FILE: ./src/execution/env/env_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_utils.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/17 12:34:56 by user              #+#    #+#             */
/*   Updated: 2025/04/08 14:58:16 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>

char	*ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
	char	*tmp;
	char	*res;

	tmp = ft_strjoin(s1, s2);
	res = ft_strjoin(tmp, s3);
	free(tmp);
	return (res);
}

void	print_env_list(t_env *env_list, int fd_out)
{
	while (env_list)
	{
		ft_putstr_fd(env_list->key, fd_out);
		ft_putstr_fd("=", fd_out);
		if (env_list->value)
			ft_putendl_fd(env_list->value, fd_out);
		else
			ft_putendl_fd("", fd_out);
		env_list = env_list->next;
	}
}

static int	count_env_nodes(t_env *lst)
{
	int	count;

	count = 0;
	while (lst)
	{
		count++;
		lst = lst->next;
	}
	return (count);
}

char	**env(t_env **lst)
{
	t_env	*tmp;
	char	**envp;
	int		i;
	int		count;

	count = count_env_nodes(*lst);
	envp = malloc((count + 1) * sizeof(char *));
	if (!envp)
		return (NULL);
	tmp = *lst;
	i = 0;
	while (tmp)
	{
		envp[i++] = ft_strjoin3(tmp->key, "=", tmp->value);
		tmp = tmp->next;
	}
	envp[i] = NULL;
	return (envp);
}

static void	create_new_shlvl(t_env *data, int shlvl)
{
	t_env	*new_env;

	new_env = malloc(sizeof(t_env));
	if (!new_env)
		return ;
	new_env->key = ft_strdup("SHLVL");
	new_env->value = ft_itoa(shlvl);
	new_env->next = data;
	data = new_env;
}

void	incr_shell_lvl(t_env *data)
{
	char	*shlvl_str;
	int		shlvl;
	t_env	*tmp;

	shlvl_str = get_env_value(data, "SHLVL");
	shlvl = 0;
	if (shlvl_str)
		shlvl = ft_atoi(shlvl_str);
	shlvl++;
	tmp = data;
	while (tmp)
	{
		if (!ft_strcmp(tmp->key, "SHLVL"))
		{
			free(tmp->value);
			tmp->value = ft_itoa(shlvl);
			return ;
		}
		tmp = tmp->next;
	}
	create_new_shlvl(data, shlvl);
}

void	set_env_var(t_ast *data, char *var_name, const char *var_value)
{
	t_env	*env;
	t_env	*new_env;

	env = data->env_list;
	while (env)
	{
		if (!ft_strcmp(env->key, var_name))
		{
			free(env->value);
			env->value = ft_strdup(var_value);
			return ;
		}
		env = env->next;
	}
	new_env = malloc(sizeof(t_env));
	if (!new_env)
		return ;
	new_env->key = ft_strdup(var_name);
	new_env->value = ft_strdup(var_value);
	new_env->next = data->env_list;
	data->env_list = new_env;
}

t_env	*find_envir_variable(t_ast *data, char *var_name, int len)
{
	t_env	*current;

	current = data->env_list;
	while (current)
	{
		if (current->key && ft_strncmp(current->key, var_name, len) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

static char	*checker(t_ast *data, char *cmd, char ***paths_ptr)
{
	t_env	*path_env;

	if (ft_strchr(cmd, '/'))
	{
		if (access(cmd, X_OK) == 0)
			return (ft_strdup(cmd));
		return (NULL);
	}
	path_env = find_envir_variable(data, "PATH", 4);
	if (!path_env || !path_env->value)
		return (NULL);
	*paths_ptr = ft_split(path_env->value, ':');
	if (!*paths_ptr)
		return (NULL);
	return (NULL);
}

char	*find_executable_path(t_ast *data, char *cmd)
{
	char	**paths;
	char	*full_path;
	char	*result;
	int		i;

	result = checker(data, cmd, &paths);
	if (result || !paths)
		return (result);
	i = -1;
	while (paths[++i])
	{
		full_path = ft_strjoin3(paths[i], "/", cmd);
		if (!full_path)
			continue ;
		if (access(full_path, X_OK) == 0)
		{
			free_2darray(paths);
			return (full_path);
		}
		free(full_path);
	}
	free_2darray(paths);
	return (NULL);
}

### END OF FILE: ./src/execution/env/env_utils.c ###


### START OF FILE: ./src/execution/execution/execute.c ###

#include "minishell.h"

int	execute_group(t_ast *data, t_ast *tree)
{
	pid_t	pid;
	int		status;
	int		ret;

	pid = fork();
	if (pid == 0)
	{
		ret = execute_tree(data, tree->left);
		exit(ret);
	}
	else if (pid < 0)
	{
		ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
		return (data->exit_status = 1);
	}
	waitpid(pid, &status, 0);
	if (WIFEXITED(status))
		data->exit_status = WEXITSTATUS(status);
	else
		data->exit_status = 1;
	return (data->exit_status);
}

int	execute_sequence(t_ast *data, t_ast *tree)
{
	execute_tree(data, tree->left);
	return (execute_tree(data, tree->right));
}

int	execute_tree(t_ast *data, t_ast *tree)
{
	if (tree->type == AST_AND || tree->type == AST_OR)
	{
		if (tree->type == AST_AND)
			return (execute_and(data, tree));
		else
			return (execute_or(data, tree));
	}
	else if (tree->type == AST_PIPELINE)
	{
		return (execute_pipe(data, tree));
	}
	else if (tree->type == AST_SUBSHELL)
	{
		return (execute_group(data, tree));
	}
	else if (tree->type == AST_COMMAND)
	{
		return (execute_word(data, tree));
	}
	return (0);
}

### END OF FILE: ./src/execution/execution/execute.c ###


### START OF FILE: ./src/execution/execution/execute_external.c ###

#include "minishell.h"
#include <errno.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int	execute_command(t_ast *data, t_ast *tree, int fd_inp, int fd_out)
{
	pid_t	pid;
	int		status;
	char	*cmd_path;
	char	**envp;
	int		i;

	pid = fork();
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		if (fd_inp != STDIN_FILENO)
		{
			if (dup2(fd_inp, STDIN_FILENO) == -1)
			{
				perror("minishell: dup2 input redirection");
				exit(1);
			}
			close(fd_inp);
		}
		if (fd_out != STDOUT_FILENO)
		{
			if (dup2(fd_out, STDOUT_FILENO) == -1)
			{
				perror("minishell: dup2 output redirection");
				exit(1);
			}
			close(fd_out);
		}
		cmd_path = find_executable_path(data, tree->cmd->args[0]);
		if (!cmd_path)
		{
			ft_putstr_fd("minishell: ", STDERR_FILENO);
			ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
			ft_putendl_fd(": command not found", STDERR_FILENO);
			exit(127);
		}
		envp = env(&(data->env_list));
		execve(cmd_path, tree->cmd->args, envp);
		perror("minishell: execve");
		free_2darray(envp);
		exit(1);
	}
	if (fd_inp != STDIN_FILENO)
		close(fd_inp);
	if (fd_out != STDOUT_FILENO)
		close(fd_out);
	waitpid(pid, &status, 0);
	i = -1;
	while (++i < data->heredoc_count)
	{
		unlink(data->heredoc_files[i]);
		free(data->heredoc_files[i]);
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}

### END OF FILE: ./src/execution/execution/execute_external.c ###


### START OF FILE: ./src/execution/execution/execute_pipe.c ###

#include "minishell.h"

int	execute_pipe(t_ast *data, t_ast *tree)
{
	int		fd[2];
	pid_t	left_pid;
	pid_t	right_pid;
	int		left_status;
	int		right_status;

	if (pipe(fd) == -1)
	{
		perror("minishell: pipe");
		return (data->exit_status = 1);
	}
	left_pid = fork();
	if (left_pid == 0)
	{
		close(fd[0]);
		dup2(fd[1], STDOUT_FILENO);
		close(fd[1]);
		exit(execute_tree(data, tree->left));
	}
	else if (left_pid < 0)
	{
		perror("minishell: fork");
		close(fd[0]);
		close(fd[1]);
		return (data->exit_status = 1);
	}
	right_pid = fork();
	if (right_pid == 0)
	{
		close(fd[1]);
		dup2(fd[0], STDIN_FILENO);
		close(fd[0]);
		exit(execute_tree(data, tree->right));
	}
	else if (right_pid < 0)
	{
		perror("minishell: fork");
		close(fd[0]);
		close(fd[1]);
		kill(left_pid, SIGTERM);
		return (data->exit_status = 1);
	}
	close(fd[0]);
	close(fd[1]);
	waitpid(left_pid, &left_status, 0);
	waitpid(right_pid, &right_status, 0);
	if (WIFEXITED(right_status))
		data->exit_status = WEXITSTATUS(right_status);
	else
		data->exit_status = 1;
	return (data->exit_status);
}

### END OF FILE: ./src/execution/execution/execute_pipe.c ###


### START OF FILE: ./src/execution/execution/execute_word.c ###

#include "minishell.h"

int	execute_word(t_ast *data, t_ast *tree)
{
	int		fd_in;
	int		fd_out;
	char	**expanded_args;
	char	**original_args;
	pid_t	pid;
	char	*cmd_path;
	char	**envp;
	int		status;

	fd_in = get_input_file(data, tree);
	fd_out = get_output_file(tree);
	if (fd_in < 0 || fd_out < 0)
	{
		if (fd_in > 0 && fd_in != STDIN_FILENO)
			close(fd_in);
		if (fd_out > 0 && fd_out != STDOUT_FILENO)
			close(fd_out);
		data->exit_status = 1;
		return (1);
	}
	expanded_args = expand_wildcards_in_args(tree->cmd->args);
	if (!expanded_args)
	{
		close(fd_in);
		close(fd_out);
		return (data->exit_status = 1);
	}
	original_args = tree->cmd->args;
	tree->cmd->args = expanded_args;
	if (handle_builtin(data, tree, fd_out))
	{
		tree->cmd->args = original_args;
		free_2darray(expanded_args);
		if (fd_in != STDIN_FILENO)
			close(fd_in);
		if (fd_out != STDOUT_FILENO)
			close(fd_out);
		return (data->exit_status);
	}
	pid = fork();
	if (pid < 0)
	{
		ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
		data->exit_status = 1;
	}
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		if (fd_in != STDIN_FILENO)
		{
			dup2(fd_in, STDIN_FILENO);
			close(fd_in);
		}
		if (fd_out != STDOUT_FILENO)
		{
			dup2(fd_out, STDOUT_FILENO);
			close(fd_out);
		}
		cmd_path = find_executable_path(data, tree->cmd->args[0]);
		if (!cmd_path)
		{
			ft_putstr_fd("minishell: ", STDERR_FILENO);
			ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
			ft_putendl_fd(": command not found", STDERR_FILENO);
			exit(127);
		}
		envp = env(&(data->env_list));
		if (!envp)
		{
			free(cmd_path);
			ft_putstr_fd("minishell: envp is NULL\n", STDERR_FILENO);
			exit(1);
		}
		execve(cmd_path, tree->cmd->args, envp);
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putendl_fd(strerror(errno), STDERR_FILENO);
		free(cmd_path);
		free_2darray(envp);
		exit(126);
	}
	else
	{
		g_child_pid = pid;
		waitpid(pid, &status, 0);
		g_child_pid = 0;
		if (WIFEXITED(status))
			data->exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			data->exit_status = 128 + WTERMSIG(status);
		else
			data->exit_status = 1;
	}
	tree->cmd->args = original_args;
	free_2darray(expanded_args);
	if (fd_in != STDIN_FILENO)
		close(fd_in);
	if (fd_out != STDOUT_FILENO)
		close(fd_out);
	return (data->exit_status);
}

### END OF FILE: ./src/execution/execution/execute_word.c ###


### START OF FILE: ./src/execution/execution/exec_handling.c ###

#include "../../include/minishell.h"

int	execute_and(t_ast *data, t_ast *tree)
{
	int	left_status;
	int	right_status;

	left_status = execute_tree(data, tree->left);
	if (left_status != 0)
	{
		data->exit_status = left_status;
		return (left_status);
	}
	right_status = execute_tree(data, tree->right);
	data->exit_status = right_status;
	return (right_status);
}

int	execute_or(t_ast *data, t_ast *tree)
{
	int	left_status;
	int	right_status;

	left_status = execute_tree(data, tree->left);
	if (left_status == 0)
	{
		data->exit_status = 0;
		return (0);
	}
	right_status = execute_tree(data, tree->right);
	data->exit_status = right_status;
	return (right_status);
}

### END OF FILE: ./src/execution/execution/exec_handling.c ###


### START OF FILE: ./src/execution/execution/expand_wildcard.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_wildcard.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/24 19:36:52 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/10 20:30:21 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"
#include <dirent.h>

int	match_pattern(const char *pattern, const char *text)
{
	if (!pattern || !text)
		return (0);
	while (*pattern)
	{
		if (*pattern == '*')
		{
			pattern++;
			while (*text && !match_pattern(pattern, text))
				text++;
		}
		else if (*pattern == '?' || *pattern == *text)
		{
			pattern++;
			text++;
		}
		else
		{
			return (0);
		}
	}
	return (*text == '\0');
}

static int	has_wildcard(const char *str)
{
	return (ft_strchr(str, '*') != NULL);
}

static void	split_pattern(const char *pattern, char **dir_part,
		char **file_part)
{
	char	*last_slash;

	last_slash = ft_strrchr(pattern, '/');
	if (last_slash)
	{
		*dir_part = ft_strndup(pattern, last_slash - pattern + 1);
		*file_part = ft_strdup(last_slash + 1);
	}
	else
	{
		*dir_part = ft_strdup(".");
		*file_part = ft_strdup(pattern);
	}
}

static char	*build_full_path(char *dir, const char *file)
{
	if (ft_strcmp(dir, ".") == 0)
		return (ft_strdup(file));
	if (dir[ft_strlen(dir) - 1] == '/')
		return (ft_strjoin(dir, file));
	return (ft_strjoin3(dir, "/", file));
}

static void	sort_matches(char **matches, int count)
{
	char	*temp;
	int		i;
	int		j;

	i = -1;
	while (++i < count - 1)
	{
		j = i;
		while (++j < count)
		{
			if (ft_strcmp(matches[i], matches[j]) > 0)
			{
				temp = matches[i];
				matches[i] = matches[j];
				matches[j] = temp;
			}
		}
	}
}

static int	is_hidden_file(char *pattern, const char *filename)
{
	return (filename[0] == '.' && (pattern[0] != '.' || ft_strcmp(pattern,
				".") == 0));
}

char	**expand_wildcard(char *pattern)
{
	char			*dir_part;
	char			*file_part;
	DIR				*dir;
	struct dirent	*entry;
	char			**result;
	char			**matches;
	int				count;
	char			*full_path;

	split_pattern(pattern, &dir_part, &file_part);
	if (!has_wildcard(file_part) && !has_wildcard(dir_part))
	{
		free(dir_part);
		free(file_part);
		result = ft_calloc(2, sizeof(char *));
		result[0] = ft_strdup(pattern);
		return (result);
	}
	dir = opendir(dir_part);
	if (!dir)
	{
		free(dir_part);
		free(file_part);
		return (NULL);
	}
	matches = NULL;
	count = 0;
	while ((entry = readdir(dir)) != NULL)
	{
		if (is_hidden_file(file_part, entry->d_name))
			continue ;
		if (match_pattern(file_part, entry->d_name))
		{
			full_path = build_full_path(dir_part, entry->d_name);
			matches = realloc(matches, (count + 1) * sizeof(char *));
			matches[count++] = full_path;
		}
	}
	closedir(dir);
	if (count == 0)
	{
		free(matches);
		matches = NULL;
	}
	else
	{
		sort_matches(matches, count);
		matches = realloc(matches, (count + 1) * sizeof(char *));
		matches[count] = NULL;
	}
	free(dir_part);
	free(file_part);
	return (matches);
}

char	**expand_wildcards_in_args(char **args)
{
	char	**new_args;
	int		new_count;
	int		j;
	char	**matches;
	int		i;

	i = -1;
	while (args[++i])
	{
		matches = expand_wildcard(args[i]);
		if (!matches)
		{
			new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
			new_args[new_count++] = ft_strdup(args[i]);
		}
		else
		{
			j = -1;
			while (matches[++j])
			{
				new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
				new_args[new_count++] = ft_strdup(matches[j]);
			}
			j = -1;
			while (matches[++j])
				free(matches[j]);
			free(matches);
		}
	}
	new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
	new_args[new_count] = NULL;
	return (new_args);
}

### END OF FILE: ./src/execution/execution/expand_wildcard.c ###


### START OF FILE: ./src/execution/signals/signals.c ###


#include "../../../include/minishell.h"

static void	sigint_handler(int sig)
{
	(void)sig;
	if (g_child_pid == 0)
	{
		ft_putstr_fd("\n", STDOUT_FILENO);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	}
	else
	{
		ft_putstr_fd("\n", STDOUT_FILENO);
		kill(g_child_pid, SIGINT);
	}
}

void	handle_signal(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;

	sa_int.sa_handler = sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, NULL);
}

void	handle_sigint(int signo)
{
	int	i;

	if (signo == SIGINT)
	{
		if (isatty(STDIN_FILENO))
		{
			i = write(1, "\n", 1);
			(void) i;
			if (g_child_pid == 42)
				g_child_pid = 44;
			if (g_child_pid != 0 && g_child_pid != 44)
			{
				kill(g_child_pid, SIGINT);
				g_child_pid++;
			}
			else
			{
				rl_on_new_line();
				rl_redisplay();
			}
		}
		else
			exit(EXIT_SUCCESS);
	}
}

void	handle_sigtstp_sigquit(int signo)
{
	if (signo == SIGTSTP || signo == SIGQUIT)
	{
		if (isatty(STDIN_FILENO))
		{
			if (g_child_pid == 0)
				rl_redisplay();
			else
			{
				kill(g_child_pid, signo);
				g_child_pid += 2;
			}
		}
	}
}

void	handle_c(int signo)
{
	handle_sigint(signo);
	handle_sigtstp_sigquit(signo);
}

int	handle_d(t_ast *data, char *line)
{
	(void)data;
	if (line == NULL)
	{
		rl_on_new_line();
		rl_redisplay();
	}
	if (ft_strlen(line) == 0)
	{
		ft_strdel(&line);
		return (1);
	}
	return (0);
}

### END OF FILE: ./src/execution/signals/signals.c ###


### START OF FILE: ./src/execution/utils/free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 12:54:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/08 14:45:33 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_token(t_token *token)
{
	t_token	*tmp;

	while (token)
	{
		tmp = token->next;
		free(token->value);
		free(token);
		token = tmp;
	}
}

void	free_heredoc_files(t_ast *data)
{
	int	i;

	if (!data->heredoc_files)
		return ;
	i = 0;
	while (i < data->heredoc_count)
	{
		if (data->heredoc_files[i])
		{
			unlink(data->heredoc_files[i]);
			free(data->heredoc_files[i]);
		}
		i++;
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
}

void	free_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->env_list)
		free_env_list(data->env_list);
	if (data->heredoc_files)
		free_heredoc_files(data);
	if (data)
		free_ast(data);
}

void	free_temp_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->token)
		free_token(data->token);
	free(data);
}

void	ft_strdel(char **as)
{
	if (as && *as)
	{
		free(*as);
		*as = NULL;
	}
}

### END OF FILE: ./src/execution/utils/free.c ###


### START OF FILE: ./src/execution/utils/free2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:04:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:04:56 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	free_2darray(char **array)
{
	int	i;

	i = -1;
	if (!array)
		return ;
	while (array[++i])
		ft_strdel(&array[i]);
	free(array);
}

### END OF FILE: ./src/execution/utils/free2.c ###


### START OF FILE: ./src/execution/utils/utils4.c ###


#include "../../include/minishell.h"

void	*ft_realloc(void *ptr, size_t oldsize, size_t newsize)
{
	char	*newptr;

	newptr = malloc(newsize);
	if (!newptr)
		return (NULL);
	if (ptr)
	{
		ft_memcpy(newptr, ptr, oldsize);
		free(ptr);
	}
	return (newptr);
}

char	*ft_strndup(const char *s, size_t n)
{
	char	*dup;
	size_t	len;
	size_t	i;

	len = 0;
	while (len < n && s[len])
		len++;
	dup = (char *)malloc(sizeof(char) * (len + 1));
	if (!dup)
		return (NULL);
	i = 0;
	while (i < len)
	{
		dup[i] = s[i];
		i++;
	}
	dup[len] = '\0';
	return (dup);
}

### END OF FILE: ./src/execution/utils/utils4.c ###


### START OF FILE: ./src/main.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/* +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 01:11:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 00:11:49 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

pid_t	g_child_pid = 0;

void	handle_input(char *input, t_env *env_list, int argc, char **argv)
{
	t_token			*tokens;
	char			*expandable;
	t_args			arg;
	t_ast			*ast;
	t_env			*env_copy;

	arg.exit_status = 0;
	if (*input)
	{
		add_history(input);
		arg.argc = argc - 1;
		arg.argv = argv;
		env_copy = deep_copy_env_list(env_list);
		if (!env_copy)
			return ;
		expandable = parse_env(input, env_copy, &arg);
		if (!expandable)
		{
			free_env_list(env_copy);
			return ;
		}
		tokens = tokenize(expandable);
		if (!tokens)
		{
			free_tokens(tokens);
			return ;
		}
		if (!validation(tokens))
			return ;
		free(expandable);
		free_env_list(env_copy);
		ast = parse_tokens(tokens);
		free_tokens(tokens);
		if (!ast)
		{
			free_ast(ast);
			return ;
		}
		else if (ast)
			ast->env_list = env_list;
		execute_tree(ast, ast);
		free_ast(ast);
	}
}

char	*generate_prompt(void)
{
	char		cwd[PATH_MAX];
	char		*str;

	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		str = ft_strjoin("minihell:", cwd);
		return (ft_strjoin(str, "$ "));
	}
	return (ft_strdup("minishell$ "));
}

int	main(int argc, char **argv, char **envp)
{
	t_env		*env_list;
	char		*input;
	char		*prompt;

	env_list = init_env_list(envp);
	handle_signal();
	incr_shell_lvl(env_list);
	while (1)
	{
		prompt = generate_prompt();
		input = readline(prompt);
		free(prompt);
		if (!input)
		{
			printf("exit\n");
			exit(1);
		}
		handle_input(input, env_list, argc, argv);
		free(input);
	}
	free_env_list(env_list);
	return (0);
}

### END OF FILE: ./src/main.c ###


### START OF FILE: ./src/parse/env/convert_env.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   convert_env.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 20:29:25 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:11:32 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

t_env	*create_copy_env_node(t_env *original)
{
	t_env	*env_node;

	env_node = malloc(sizeof(t_env));
	if (!env_node)
		return (NULL);
	env_node->key = NULL;
	env_node->next = NULL;
	env_node->value = NULL;
	if (original->key)
	{
		env_node->key = ft_strdup(original->key);
		if (!env_node->key)
		{
			free(env_node);
			return (NULL);
		}
	}
	if (original->value)
	{
		env_node->value = ft_strdup(original->value);
		if (!env_node->value)
			return (free(env_node->key), free(env_node), NULL);
	}
	return (env_node);
}

t_env	*deep_copy_env_list(t_env *env_list)
{
	t_env	*new_head;
	t_env	*new_curr;
	t_env	*new_node;
	t_env	*original;

	if (!env_list)
		return (NULL);
	new_head = NULL;
	new_curr = NULL;
	original = env_list;
	while (original)
	{
		new_node = create_copy_env_node(original);
		if (!new_node)
		{
			free_env_list(new_head);
			return (NULL);
		}
		if (!new_head)
			new_head = new_node;
		else
			new_curr->next = new_node;
		new_curr = new_node;
		original = original->next;
	}
	return (new_head);
}

char	*get_env_value(t_env *env_list, char *name)
{
	t_env		*current;

	current = env_list;
	while (current)
	{
		if (!ft_strcmp(current->key, name))
			return (current->value);
		current = current->next;
	}
	return (NULL);
}

t_env	*create_env_node(char *input)
{
	t_env		*new_node;
	char		*equal_sign;

	new_node = (t_env *)malloc(sizeof(t_env));
	if (!new_node)
		return (NULL);
	equal_sign = ft_strchr(input, '=');
	if (!equal_sign)
	{
		free(new_node);
		return (NULL);
	}
	new_node->key = ft_substr(input, 0, equal_sign - input);
	new_node->value = ft_strdup(equal_sign + 1);
	new_node->next = NULL;
	return (new_node);
}

t_env	*init_env_list(char **envp)
{
	t_env		*head;
	t_env		*current;
	int			i;
	t_env		*new_node;

	head = NULL;
	i = 0;
	while (envp[i])
	{
		new_node = create_env_node(envp[i]);
		if (!new_node)
		{
			free_env_list(new_node);
			return (NULL);
		}
		if (!head)
			head = new_node;
		else
			current->next = new_node;
		current = new_node;
		i++;
	}
	return (head);
}

### END OF FILE: ./src/parse/env/convert_env.c ###


### START OF FILE: ./src/parse/env/env_parsing.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_parsing.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 19:07:30 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:10:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static char	*handle_special_utils(char *input, char *str, int *i, t_args *arg)
{
	if (input[*i] == '$')
	{
		if (input[*i + 1] == '?')
		{
			str = ft_itoa(arg->exit_status);
			*i += 2;
		}
		else if (input[*i + 1] == '@')
		{
			str = join_arguments(arg);
			*i += 2;
		}
		else if (input[*i + 1] == '*')
		{
			str = join_arguments(arg);
			*i += 2;
		}
		else if (input[*i + 1] == '0')
		{
			str = ft_strdup(arg->argv[0]);
			i += 2;
		}
	}
	return (str);
}

static char	*handle_special_var(char *input, int *i, t_args *arg)
{
	char	*str;

	str = NULL;
	if (input[*i] == '$')
		str = handle_special_utils(input, str, i, arg);
	return (str);
}

static char	*get_env_name(char *input, int *i, t_args *arg)
{
	int		start;
	int		len;
	char	*name;
	char	*special;

	start = *i;
	special = handle_special_var(input, i, arg);
	if (special)
		return (special);
	len = 0;
	while (input[start + len] && (ft_isalnum(input[start + len])
			|| input[start + len] == '_'))
		len++;
	if (len == 0)
		return (NULL);
	name = ft_substr(input, start, len);
	*i = start + len;
	return (name);
}

static char	*handle_shlvl(t_env *env_list)
{
	char		*value;
	int			level;
	char		*new_value;

	value = get_env_value(env_list, "SHLVL");
	if (!value)
		level = 1;
	else
		level = ft_atoi(value) + 1;
	new_value = ft_itoa(level);
	return (new_value);
}

char	*env_expansion(char *input, int *i,
	t_env *env_list, t_args *arg)
{
	char		*value;
	char		*name;

	(*i)++;
	value = NULL;
	name = get_env_name(input, i, arg);
	if (!name)
		return (ft_strdup(""));
	if (!ft_strcmp(name, "SHLVL"))
	{
		value = handle_shlvl(env_list);
		free(name);
		return (value);
	}
	value = get_env_value(env_list, name);
	if (!value)
		value = ft_strdup("");
	else
		value = ft_strdup(value);
	free(name);
	return (value);
}

### END OF FILE: ./src/parse/env/env_parsing.c ###


### START OF FILE: ./src/parse/env/env_parsing_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_parsing_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/16 00:37:42 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:11:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

char	*join_arguments(t_args *arg)
{
	int			i;
	char		*result;

	result = ft_strdup("");
	i = 0;
	while (i < arg->argc)
	{
		result = ft_strjoin(result, arg->argv[i]);
		if (i < arg->argc - 1)
			result = ft_strjoin(result, " ");
		i++;
	}
	return (result);
}

static int	quotes(char	*input, int i, t_args *parse)
{
	if (input[i] == '"')
	{
		if (!parse->single_quotes)
		{
			parse->double_quotes = !parse->double_quotes;
			if (parse->double_quotes)
				parse->last_quotes = '"';
			else if (parse->last_quotes == '"')
				parse->last_quotes = 0;
		}
		return (1);
	}
	if (input[i] == '\'')
	{
		if (!parse->double_quotes)
		{
			parse->single_quotes = !parse->single_quotes;
			if (parse->single_quotes)
				parse->last_quotes = '\'';
			else if (parse->last_quotes)
				parse->last_quotes = 0;
		}
		return (1);
	}
	return (0);
}

static char	*handle_env_part(t_args *parse, int *i, t_env *env_list)
{
	char		*temp;

	if (parse->single_quotes || parse->last_quotes == '\'')
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free(temp);
		return (parse->result);
	}
	if (*i > parse->start)
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free (temp);
	}
	temp = env_expansion(parse->input, i, env_list, parse);
	parse->result = ft_strjoin(parse->result, temp);
	free(temp);
	return (parse->result);
}

static void	handle_remaining(t_args *parse, int *i)
{
	char		*temp;

	if (*i > parse->start)
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free(temp);
	}
}

char	*parse_env(char *input, t_env *env_list, t_args *arg)
{
	t_args		parse;
	int			i;

	i = 0;
	parse = (t_args){arg->argc, arg->argv, 0, input, 0, ft_strdup(""), 0, 0, 0};
	while (input[i])
	{
		if (quotes(input, i, &parse))
		{
			i++;
			continue ;
		}
		if (input[i] == '$' && input[i + 1] && input[i + 1] != ' '
			&& input[i + 1] != '"' && input[i + 1] != '\'')
		{
			parse.result = handle_env_part(&parse, &i, env_list);
			parse.start = i;
		}
		else
			i++;
		if (i > ft_strlen(input))
			i = ft_strlen(input);
	}
	handle_remaining(&parse, &i);
	return (parse.result);
}

### END OF FILE: ./src/parse/env/env_parsing_utils.c ###


### START OF FILE: ./src/parse/nodes/nodes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   nodes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 19:50:51 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 00:19:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	append_node(t_token **head, t_token *current_token)
{
	t_token		*temp;

	if (!head || !current_token)
		return ;
	if (*head == NULL)
	{
		*head = current_token;
		return ;
	}
	else
	{
		temp = *head;
		while (temp->next)
			temp = temp->next;
		temp->next = current_token;
	}
}

t_token	*create_node(char *str, t_token_type type)
{
	t_token		*node;

	node = malloc(sizeof(t_token));
	if (!node)
		return (NULL);
	node->value = ft_strdup(str);
	if (!node->value)
	{
		free(node);
		return (NULL);
	}
	node->type = type;
	node->expandable = 0;
	node->next = NULL;
	return (node);
}

### END OF FILE: ./src/parse/nodes/nodes.c ###


### START OF FILE: ./src/parse/stack/stack.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 01:07:35 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/04 16:45:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	initialize_stack(t_token *stack)
{
	if (stack)
		stack->top = NULL;
}

bool	is_empty(t_token *stack)
{
	return (!stack || !stack->top);
}

char	pop(t_token *stack)
{
	char		data;
	t_stack		*temp;

	if (!stack || !stack->top)
		return ('\0');
	temp = stack->top;
	data = temp->name;
	stack->top = temp->next;
	free(temp);
	return (data);
}

void	free_stack(t_token *stack)
{
	t_stack		*current;
	t_stack		*next;

	if (!stack || !stack->top)
		return ;
	current = stack->top;
	while (current)
	{
		next = current->next;
		free(current);
		current = next;
	}
	stack->top = NULL;
}

void	push(t_token *stack, char data)
{
	t_stack		*new_node;

	new_node = (t_stack *)malloc(sizeof(t_stack));
	if (!new_node)
		return ;
	new_node->name = data;
	new_node->next = stack->top;
	stack->top = new_node;
}

### END OF FILE: ./src/parse/stack/stack.c ###


### START OF FILE: ./src/parse/tokenize/tokenize.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 15:33:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/07 15:24:26 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	handle_operator(t_token **token, char *input, int *i)
{
	int		status;

	if (input[*i] == '(' || input[*i] == ')')
		return (return_parenthesis(token, input[*i]));
	status = handle_double_operator(token, input, i);
	if (status != 0)
		return (status);
	return (handle_single_operator(token, input[*i]));
}

int	tokenize_utils(t_token **token, char *input, int *i)
{
	int		status;

	status = 0;
	if (input[*i] == '\'' || input[*i] == '"')
		status = handle_quotes(token, input, i);
	else if (is_operator(input[*i]))
	{
		status = handle_operator(token, input, i);
		if (status == 0)
			status = handle_word(token, input, i);
	}
	else
		status = handle_word(token, input, i);
	return (status);
}

t_token	*finalize_token(t_token *token)
{
	t_token	*eof_token;

	eof_token = create_node("", TOKEN_EOF);
	if (!eof_token)
		return (free_tokens(token));
	append_node(&token, eof_token);
	return (token);
}

t_token	*tokenize(char *input)
{
	t_token	*token;
	int		i;
	int		status;

	if (!input)
		return (NULL);
	i = 0;
	token = NULL;
	status = -1;
	if (input == NULL)
		return (NULL);
	while (input[i])
	{
		if (ft_isspace(input[i]))
		{
			status = handle_whitespace(&token, input, &i);
			continue ;
		}
		status = tokenize_utils(&token, input, &i);
		if (status == -1)
			return (free_tokens(token));
		i++;
	}
	return (finalize_token(token));
}

### END OF FILE: ./src/parse/tokenize/tokenize.c ###


### START OF FILE: ./src/parse/tokenize/tokenize_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 23:25:01 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/14 20:22:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	handle_single_operator(t_token **token, char c)
{
	t_token		*current;

	if (c == '|')
		current = create_node("|", TOKEN_PIPE);
	else if (c == ' ')
		current = create_node(" ", TOKEN_WHITESPACE);
	else if (c == '<')
		current = create_node("<", TOKEN_REDIRECT_IN);
	else if (c == '>')
		current = create_node(">", TOKEN_REDIRECT_OUT);
	else if (c == '*')
		current = create_node("*", TOKEN_WILDCARD);
	else
		return (0);
	if (!current)
		return (-1);
	printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

static int	handle_double_operator_utils(t_token **current, char *input,
	int *i, char next_char)
{
	if (input[*i] == '<' && next_char == '<')
		*current = create_node("<<", TOKEN_HEREDOC);
	else if (input[*i] == '>' && next_char == '>')
		*current = create_node(">>", TOKEN_APPEND);
	else if (input[*i] == '&' && next_char == '&')
		*current = create_node("&&", TOKEN_AND);
	else if (input[*i] == '|' && next_char == '|')
		*current = create_node("||", TOKEN_OR);
	else
		return (0);
	if (!*current)
		return (-1);
	(*i)++;
	return (1);
}

int	handle_double_operator(t_token **head, char *input, int *i)
{
	t_token		*current;
	char		next_char;
	int			result;

	if (input[*i + 1] == '\0')
		return (0);
	next_char = input[*i + 1];
	if ((input[*i] == '&' && next_char == '&' && input[*i + 2] == '&')
		|| (input[*i] == '|' && next_char == '|' && input[*i + 2] == '|'))
	{
		report_error(ERR_SYNTAX, "invalid operator sequence");
		return (-1);
	}
	result = handle_double_operator_utils(&current, input, i, next_char);
	if (result == 1)
	{
		append_node(head, current);
		printf("%s\n", current->value);
	}
	return (result);
}

int	return_parenthesis(t_token **token, char c)
{
	t_token		*current;

	if (c == '(')
		current = create_node("(", TOKEN_PAREN_OPEN);
	else
		current = create_node(")", TOKEN_PAREN_CLOSE);
	if (!current)
		return (-1);
	printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

### END OF FILE: ./src/parse/tokenize/tokenize_utils.c ###


### START OF FILE: ./src/parse/tokenize/tokenize_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_utils_2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:12:02 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:17:53 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static int	get_quote_content(char *input, int *i,
	char quote_type, char **content)
{
	int		start;
	int		len;

	start = *i + 1;
	*i = start;
	while (input[*i] && input[*i] != quote_type)
		(*i)++;
	if (!input[*i])
	{
		report_error(ERR_SYNTAX, "Unmatched parenthesis");
		return (-1);
	}
	len = *i - start;
	*content = ft_substr(input, start, len);
	if (!*content)
		return (-1);
	return (0);
}

int	handle_quotes(t_token **token, char *input, int *i)
{
	t_token	*current;
	char	*content;
	char	quote_type;

	quote_type = input[*i];
	if (get_quote_content(input, i, quote_type, &content) == -1)
		return (-1);
	current = create_node(content, TOKEN_WORD);
	if (!current)
	{
		free(content);
		return (-1);
	}
	if (quote_type == '"')
	{
		current->expandable = 1;
		current->double_quotes = 1;
	}
	else if (quote_type == '\'')
		current->single_quotes = 1;
	printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

int	handle_word(t_token **token, char *input, int *i)
{
	int		start;
	char	*word;
	t_token	*current;

	start = *i;
	while (input[*i] && !ft_isspace(input[*i]) && !is_operator(input[*i])
		&& input[*i] != '\'' && input[*i] != '"')
		(*i)++;
	word = ft_substr(input, start, *i - start);
	if (!word)
		return (-1);
	current = create_node(word, TOKEN_WORD);
	free(word);
	if (!current)
		return (-1);
	current->expandable = 1;
	printf("Token: %s\n", current->value);
	append_node(token, current);
	(*i)--;
	return (1);
}

int	handle_whitespace(t_token **token, char *input, int *i)
{
	int		start;
	char	*whitespace;
	t_token	*curr;

	start = *i;
	while (input[*i] && ft_isspace(input[*i]))
		(*i)++;
	whitespace = ft_substr(input, start, *i - start);
	if (!whitespace)
		return (-1);
	curr = create_node(whitespace, TOKEN_WHITESPACE);
	free(whitespace);
	if (!curr)
		return (-1);
	printf("TOKEN: Whitespace\n");
	append_node(token, curr);
	return (1);
}

### END OF FILE: ./src/parse/tokenize/tokenize_utils_2.c ###


### START OF FILE: ./src/parse/utils/errors_free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors_free.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:21:04 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:49:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	free_env_list(t_env *env_list)
{
	t_env		*temp;

	while (env_list)
	{
		temp = env_list->next;
		free(env_list->key);
		free(env_list->value);
		free(env_list);
		env_list = temp;
	}
}

t_token	*free_tokens(t_token *token)
{
	t_token		*temp;

	while (token)
	{
		temp = token->next;
		free(token->value);
		free(token);
		token = temp;
	}
	return (NULL);
}

void	report_error(t_errors_code code, char *token)
{
	if (code == ERR_UNBALANCED_PAREN)
	{
		if (token)
			printf("minishell: syntax error near unexpected token `%s'\n",
				token);
		else
			printf("minishell: syntax error: unmatched parenthesis\n");
	}
	else if (code == ERR_SYNTAX)
	{
		if (token)
			printf("minishell: syntax error near unexpected `%s'\n", token);
		else
			printf("minishell: syntax error\n");
	}
	else if (code == ERR_UNEXPECTED_TOKEN)
		printf("minishell: syntax error near unexpected token `%s'\n", token);
	else if (code == ERR_MEMORY)
		printf("minishell: memory allocation failed\n");
	else if (code == ERR_PARSE)
		printf("minishell: parse error\n");
}

### END OF FILE: ./src/parse/utils/errors_free.c ###


### START OF FILE: ./src/parse/utils/utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 17:21:58 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 19:30:38 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	ft_isspace(int num)
{
	if (num == ' ' || num == '\n' || num == '\t'
		|| num == '\v' || num == '\f' || num == '\r')
		return (1);
	return (0);
}

int	is_operator(char c)
{
	if (c == '&' || c == '|' || c == '(' || c == ')'
		|| c == '>' || c == '<' || c == '*')
		return (1);
	return (0);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	int			i;

	i = 0;
	while (s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int	count_parenthesise_util(char *input)
{
	t_quotes	quotes;
	int			i;
	int			open_paren;
	int			close_paren;

	i = 0;
	open_paren = 0;
	close_paren = 0;
	quotes = (t_quotes){false, false};
	while (input[i] != '\0')
	{
		process_quotes(input[i], &quotes);
		if (!quotes.in_double_quotes && !quotes.in_single_quotes)
		{
			if (input[i] == '(')
				open_paren++;
			else if (input[i] == ')')
				close_paren++;
		}
		i++;
	}
	return (open_paren - close_paren);
}

int	count_parenthesis(t_token *tokens)
{
	int		count;
	int		total_count;

	if (!tokens)
		return (0);
	total_count = 0;
	while (tokens)
	{
		if (tokens->value)
		{
			count = count_parenthesise_util(tokens->value);
			total_count += count;
		}
		tokens = tokens->next;
	}
	return (total_count);
}

### END OF FILE: ./src/parse/utils/utils.c ###


### START OF FILE: ./src/parse/validation/commands/commands_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   commands_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:08:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/06 15:02:11 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	is_valid_command_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/'
		|| c == '$' || c == '*' || c == '?' || c == '~');
}

bool	is_command_or_arg_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/'
		|| c == '$' || c == '~' || c == '"' || c == '\'');
}

bool	is_valid_command_start(char c)
{
	return (ft_isalnum(c) || c == '.' || c == '/' || c == '$' || c == '?'
		|| c == '#' || c == '_' || c == '*' || c == '-');
}

bool	is_valid_flag_char(char c)
{
	return (ft_isalnum(c) || c == '_');
}
### END OF FILE: ./src/parse/validation/commands/commands_utils.c ###


### START OF FILE: ./src/parse/validation/commands/validate_commands.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_commands.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 01:08:32 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/06 15:03:46 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_commands_position(char *input, int i)
{
	int			pos;

	pos = i - 1;
	while (pos >= 0 && ft_isspace(input[pos]))
		pos--;
	if (pos < 0 || input[pos] == '|' || input[pos] == ';' || input[pos] == '('
		|| pos == '\n')
		return (true);
	if (pos > 0 && ((input[pos] == '&' && input[pos - 1] == '&')
			|| (input[pos] == '|' && input[pos - 1] == '|')))
		return (true);
	return (false);
}

static bool	check_commands_in_str(char *str, bool *in_cmd, bool *is_cmd_pos,
	int i)
{
	if (!*in_cmd && is_valid_command_char(str[i])
		&& !ft_isspace(str[i]))
	{
		*is_cmd_pos = ft_is_commands_position(str, i);
		if (*is_cmd_pos && !is_valid_command_start(str[i]))
		{
			report_error(ERR_SYNTAX, "invalid command");
			return (false);
		}
		*in_cmd = true;
	}
	else if (*in_cmd && (ft_isspace(str[i]) || str[i] == '('
			|| str[i] == ')' || ft_is_operator(str[i])
			|| ft_is_redirection(str[i])))
		*in_cmd = false;
	return (true);
}

bool	check_commands(char *str)
{
	int			i;
	t_quotes	quote;
	bool		in_commands;
	bool		is_cmd_pos;

	i = 0;
	quote = (t_quotes){false, false};
	in_commands = false;
	while (str && str[i])
	{
		process_quotes(str[i], &quote);
		if (!quote.in_single_quotes && !quote.in_double_quotes)
		{
			if (!check_commands_in_str(str, &in_commands, &is_cmd_pos, i))
				return (false);
		}
		i++;
	}
	if (quote.in_double_quotes || quote.in_single_quotes)
	{
		report_error(ERR_SYNTAX, "Unmatched quotes");
		return (false);
	}
	return (true);
}

bool	validate_commands(t_token *tokenize)
{
	t_token			*current;

	if (!tokenize)
		return (true);
	current = tokenize;
	while (current)
	{
		if (!check_commands(current->value))
			return (false);
		current = current->next;
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/commands/validate_commands.c ###


### START OF FILE: ./src/parse/validation/operators/operators_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operators_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:06:42 by ldurmish          #+#    #+#             */
/*   Updated: 2025/02/26 00:38:27 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_operator(char c)
{
	return (c == '|' || c == '&' || c == ';');
}

bool	ft_is_logical_op(char current, char next)
{
	return ((current == '&' && next == '&')
		|| (current == '|' && next == '|'));
}

### END OF FILE: ./src/parse/validation/operators/operators_utils.c ###


### START OF FILE: ./src/parse/validation/operators/validation_logical_operators.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_logical_operators.c                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/26 19:18:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 00:17:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	check_sequencing(t_token **curr, t_token **next)
{
	if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
		&& ft_strcmp((*next)->value, ";") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence &&;");
		return (false);
	}
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& ft_strcmp((*next)->value, ";") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence ||;");
		return (false);
	}
	if (ft_strcmp((*curr)->value, ";") == 0 && (*next)->type == TOKEN_OR
		&& ft_strcmp((*next)->value, "||") == 0)
	{
		report_error (ERR_SYNTAX, "invalid operator sequence ;||");
		return (false);
	}
	if (ft_strcmp((*curr)->value, ";") == 0 && (*next)->type == TOKEN_AND
		&& ft_strcmp((*next)->value, "&&") == 0)
		return (report_error(ERR_SYNTAX, "invalid operator sequence ;&&"),
			false);
	return (true);
}

static bool	check_tokens_utils(t_token **curr, t_token **next)
{
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& (*next)->type == TOKEN_OR && ft_strcmp((*next)->value, "|") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence |||");
		return (false);
	}
	if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
		&& (*next)->type == TOKEN_OR && ft_strcmp((*next)->value, "||") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence &&||");
		return (false);
	}
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& (*next)->type == TOKEN_AND && ft_strcmp((*next)->value, "&&") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence ||&&");
		return (false);
	}
	return (true);
}

bool	check_tokens(t_token **curr, t_token **next)
{
	if ((*next) && ((*next)->type == TOKEN_AND || (*next)->type == TOKEN_OR
			|| (*next)->type == TOKEN_PIPE))
	{
		if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
			&& (*next)->type == TOKEN_AND
			&& ft_strcmp((*next)->value, "&") == 0)
		{
			report_error(ERR_SYNTAX, "invalid operators sequence '&&&'");
			return (false);
		}
		if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
			&& (*next)->type == TOKEN_PIPE)
		{
			report_error(ERR_SYNTAX, "invalid operator '|||'");
			return (false);
		}
		if (!check_tokens_utils(curr, next))
			return (false);
		if (!check_sequencing(curr, next))
			return (false);
	}
	return (true);
}

bool	validate_logical_op(t_token *tokens)
{
	t_token		*next;
	t_token		*curr;

	curr = tokens;
	next = NULL;
	while (curr)
	{
		next = curr->next;
		if (curr->type == TOKEN_AND || curr->type == TOKEN_OR
			|| curr->type == TOKEN_PIPE)
		{
			if (!check_tokens(&curr, &next))
				return (false);
		}
		curr = curr->next;
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/operators/validation_logical_operators.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:19:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 02:21:29 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_redirect_after_paren(char *next_input, t_token *token, int *j)
{
	if (next_input[*j] && ft_is_redirection(next_input[*j]))
	{
		if (next_input[*j] && next_input[*j] == next_input[*j + 1])
			*j += 2;
		else
			*j += 1;
		while (next_input[*j] && ft_isspace(next_input[*j]))
			(*j)++;
		if (!next_input[*j] || is_valid_command_char(next_input[*j]))
		{
			report_error(ERR_SYNTAX, "redirection without filename");
			free_stack(token);
			return (false);
		}
	}
	return (true);
}

bool	check_commands_after_paren(char *input, int *j)
{
	bool	found_operator;
	int		k;

	if (input[*j] && is_command_or_arg_char(input[*j]))
	{
		found_operator = false;
		k = 0;
		while (k < *j)
		{
			if (ft_is_operator(input[k]) || input[*j] == '|'
				|| (input[k + 1] && ft_is_logical_op(input[k], input[k + 1])))
			{
				found_operator = true;
				break ;
			}
			k++;
		}
		if (!found_operator)
		{
			report_error(ERR_SYNTAX, "missing operator between"
				"parenthesis and commands");
			return (false);
		}
	}
	return (true);
}

bool	check_op_after_paren(char *input, t_token *token, int *j)
{
	if (*j > 0 || !input[*j + 1] || input[*j] != input[*j + 1])
	{
		report_error(ERR_SYNTAX, "incomplete logical operator");
		free_stack(token);
		return (false);
	}
	*j += 2;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j] || !is_valid_command_char(input[*j]))
	{
		report_error(ERR_SYNTAX, "operator without syntax");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	logical_op_after_paren(char *input, t_token *token, int *j)
{
	if (!input[*j])
		return (false);
	if (input[*j] == '&')
		return (check_op_after_paren(input, token, j));
	else if (input[*j] == '|')
	{
		if (input[*j + 1] && input[*j + 1] == '|')
			return (check_op_after_paren(input, token, j));
		else
		{
			(*j)++;
			while (input[*j] && ft_isspace(input[*j]))
				(*j)++;
			if (!input[*j] || !is_valid_command_char(input[*j]))
			{
				report_error(ERR_SYNTAX, "pipe without command");
				free_stack(token);
				return (false);
			}
		}
	}
	return (true);
}

bool	check_next_token(t_token *next)
{
	t_token			*next_token;
	char			*next_input;
	int				j;

	if (!next || !next->next)
		return (true);
	next_token = next->next;
	if (!next->value)
		return (report_error(ERR_SYNTAX, "null token after parenthesis"),
			false);
	next_input = next_token->value;
	j = 0;
	while (next_input[j] && ft_isspace(next_input[j]))
		j++;
	if (!next_input[j])
		return (true);
	if (!check_redirect_after_paren(next_input, next_token, &j))
		return (false);
	else if (!check_commands_after_paren(next_input, &j))
		return (false);
	else if (!logical_op_after_paren(next_input, next_token, &j))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 11:49:59 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 16:27:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	if_there_is_filename(char *input, int *j, t_token *token)
{
	int			k;
	t_token		*next;

	if (!input[*j] || !is_valid_command_char(input[*j]))
	{
		if (!input[*j] && token->next)
		{
			next = token->next;
			k = 0;
			while (input[k] && ft_isspace(input[k]))
				k++;
			if (!next->value[k] || !is_valid_command_char(input[k]))
			{
				report_error(ERR_SYNTAX, "redirect without filename");
				return (free_stack(token), false);
			}
		}
	}
	return (true);
}

bool	it_is_redirect(char *input, int *i, int *j, t_token *token)
{
	if (ft_is_redirection(input[*i + 1]))
	{
		*j = *i + 1;
		if (input[*j + 1] && input[*j] == input[*j + 1])
			*j += 2;
		else
			*j += 1;
		while (input[*j] && ft_isspace(input[*j]))
			(*j)++;
		if (!if_there_is_filename(input, j, token))
			return (false);
		else
		{
			report_error(ERR_SYNTAX, "redirection without filename");
			return (free_stack(token), false);
		}
	}
	return (true);
}

bool	it_is_operator(char *input, int *i, int *j, t_token *token)
{
	if (input[*i + 1] == '&' || input[*i + 1] == '|')
	{
		if (!input[*i + 2])
		{
			if (!it_is_log_or_pipe(input, i, token))
				return (false);
		}
		else if (input[*i + 2] == input[*i + 3])
		{
			if (!it_is_logical_op(input, i, j, token))
				return (false);
		}
		else if (input[*i + 1] && input[*i + 2] != '|')
		{
			if (!it_is_pipe(input, i, j, token))
				return (false);
		}
	}
	return (true);
}

bool	check_after_close_paren(char *input, int *i, t_token *token)
{
	int			j;

	j = 0;
	if (!it_is_redirect(input, i, &j, token))
		return (false);
	else if (!it_is_operator(input, i, &j, token))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren_utils.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren_utils_1.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 14:58:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/11 19:57:06 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	it_is_pipe(char *input, int *i, int *j, t_token *token)
{
	int		k;
	t_token	*next;

	*j = *i + 2;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j])
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "pipe without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(next->value[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
			return (report_error(ERR_SYNTAX, "pipe withou command"),
				free_stack(token), false);
	}
	else if (!is_valid_command_char(input[*j]))
		return (report_error(ERR_SYNTAX, "invalid token after pipe"),
			free_stack(token), false);
	return (true);
}

bool	it_is_logical_op(char *input, int *i, int *j, t_token *token)
{
	t_token	*next;
	int		k;

	*j = *i + 3;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j])
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "operator without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(next->value[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
			return (report_error(ERR_SYNTAX, "operator withoud command"),
				free_stack(token), false);
	}
	else if (!is_valid_command_char(input[*j]))
		return (report_error(ERR_SYNTAX, "invalid token after operator"),
			free_stack(token), false);
	return (true);
}

bool	it_is_log_or_pipe(char *input, int *i, t_token *token)
{
	int		k;
	t_token	*next;

	if (input[*i + 1] == '|')
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "pipe without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(input[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
		{
			report_error(ERR_SYNTAX, "operator without command");
			return (free_stack(token), false);
		}
	}
	else if (!token->next || token->next->value[0] != input[*i + 1])
		return (report_error(ERR_SYNTAX, "incomplete logical operator"),
			free_stack(token), false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren_utils_1.c ###


### START OF FILE: ./src/parse/validation/parenthesis/find_match_paren.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_match_paren.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 15:18:18 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 15:48:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static int	process_paren_char(char c, t_quotes *quote_type, int *paren_count)
{
	process_quotes(c, quote_type);
	if (!quote_type->in_double_quotes && !quote_type->in_single_quotes)
	{
		if (c == '(')
			(*paren_count)++;
		else if (c == ')')
			(*paren_count)--;
	}
	return (*paren_count);
}

static int	scan_token_paren(t_token *curr, char *input, int *total_pos,
	int start_pos)
{
	t_quotes	quote_type;
	int			paren_count;
	int			j;

	paren_count = 1;
	j = start_pos;
	quote_type = (t_quotes){false, false};
	while (curr)
	{
		input = curr->value;
		while (input[j] != '\0')
		{
			if (process_paren_char(input[j], &quote_type, &paren_count) == 0)
				return (*total_pos + j);
			j++;
		}
		*total_pos += ft_strlen(curr->value);
		j = 0;
		curr = curr->next;
	}
	return (-1);
}

int	find_matching_paren(t_token *token, char *input, int start_pos)
{
	t_token		*curr;
	int			total_pos;

	curr = token;
	total_pos = 0;
	while (curr && start_pos >= ft_strlen(curr->value))
	{
		start_pos -= ft_strlen(curr->value);
		curr = curr->next;
	}
	return (scan_token_paren(curr, input, &total_pos, start_pos));
}

### END OF FILE: ./src/parse/validation/parenthesis/find_match_paren.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 01:24:50 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:15:48 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	validate_open_paren(char *input, int i, t_token *token)
{
	if (i == 0)
		return (true);
	if (i > 0)
	{
		if (is_command_or_arg_char(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "missing operator or space before '(");
			return (free_stack(token), false);
		}
		if (ft_is_redirection(input[i - 1]) || ft_is_wildcard(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "invalid token before the '('");
			return (false);
		}
		if (!valid_before_open_paren(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "invalid token before '('");
			return (false);
		}
	}
	if (input[i + 1] && !is_valid_after_open_paren(input[i + 1]))
		return (report_error(ERR_SYNTAX, "invalid token after '('"), false);
	return (true);
}

static bool	validate_command_paren(char *input, int i, t_paren *command)
{
	command->j = i - 1;
	while (command->j >= 0 && ft_isspace(input[command->j]))
		command->j--;
	if (command->j >= 0 && is_command_or_arg_char(input[command->j]))
	{
		while (command->j >= 0 && is_command_or_arg_char(input[command->j]))
			command->j--;
		command->has_cmd_before = true;
	}
	if (command->has_cmd_before)
	{
		command->j++;
		command->has_operator = false;
		while (command->j < i && !command->has_operator)
		{
			if (ft_is_operator(input[command->j]))
				command->has_operator = true;
			command->j++;
		}
		if (!command->has_operator)
			return (false);
	}
	return (true);
}

int	check_matching_paren(char *input, int i, t_token *token, int start)
{
	t_token		*next_token;
	int			end_pos;

	if (i + 1 >= (int)ft_strlen(input))
	{
		start = 0;
		next_token = token->next;
		if (!next_token)
		{
			report_error(ERR_SYNTAX, "unmatched parenthesis");
			return (-1);
		}
		end_pos = find_matching_paren(next_token, next_token->value, start);
		if (end_pos != -1)
			return (end_pos + ft_strlen(input));
	}
	else
	{
		start = i + 1;
		end_pos = find_matching_paren(token, input, start);
		return (end_pos);
	}
	return (-1);
}

static int	process_open_paren(t_token *token, char *input, int i,
	t_paren *commands)
{
	int			start_pos;
	int			end_pos;

	if (i > 0 && !validate_command_paren(input, i, commands))
	{
		report_error(ERR_SYNTAX, "invalid command before parenthesis");
		return (free_stack(token), false);
	}
	if (!validate_open_paren(input, i, token))
		return (-1);
	start_pos = 0;
	end_pos = check_matching_paren(input, i, token, start_pos);
	if (end_pos == -1)
		return (report_error(ERR_SYNTAX, "unclosed parenthesis"), false);
	if (end_pos == i + 1)
		return (report_error(ERR_SYNTAX, "empty parenthesis"), false);
	if (!validate_paren_content(input, start_pos, end_pos, token))
		return (false);
	push(token, '(');
	commands->has_content = true;
	commands->last_op = ')';
	commands->has_commands = false;
	return (end_pos);
}

bool	check_parenthesis(t_token *token, char *input, int i,
	t_paren *commands)
{
	int			new_pos;

	if (!commands->quote.in_single_quotes
		&& !commands->quote.in_double_quotes)
	{
		if (!commands->has_commands && is_valid_command_char(input[i]))
			commands->has_commands = true;
		else if (commands->has_commands && ft_isspace(input[i]))
			commands->has_commands = false;
		if (input[i] == '(')
		{
			new_pos = process_open_paren(token, input, i, commands);
			if (new_pos <= 0)
				return (false);
			i = new_pos;
		}
		else if (input[i] == ')')
		{
			if (!process_close_paren(input, i, token, commands))
				return (false);
		}
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_content.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_content.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 00:53:16 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:51:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

t_nest	check_paren_in_token(t_state *state, int end, char *input)
{
	t_nest			result;

	result = (t_nest){false, state->token, state->pos};
	while (state->pos < end && input[state->pos])
	{
		process_quotes(input[state->pos], &state->quote);
		if (!state->quote.in_double_quotes && !state->quote.in_single_quotes)
		{
			if (input[state->pos] == '(')
				state->paren_count++;
			else if (input[state->pos] == ')')
			{
				state->paren_count--;
				if (state->paren_count == 0)
				{
					result.success = true;
					result.position = state->pos;
					return (result);
				}
			}
		}
		state->pos++;
	}
	return (result);
}

t_nest	check_paren_in_multiple_token(t_state *state, char *input,
	t_token *curr)
{
	t_nest				result;

	result = (t_nest){false, curr, state->pos};
	while (input[state->pos] && state->paren_count > 0)
	{
		process_quotes(input[state->pos], &state->quote);
		if (!state->quote.in_double_quotes && !state->quote.in_single_quotes)
		{
			if (input[state->pos] == '(')
				state->paren_count++;
			else if (input[state->pos] == ')')
			{
				state->paren_count--;
				if (state->paren_count == 0)
					return ((t_nest){true, curr, state->pos});
			}
		}
		state->pos++;
	}
	return (result);
}

t_nest	validate_nested_paren(char *input, int start, int end,
	t_token *start_token)
{
	t_nest				result;
	t_state				state;
	t_token				*curr;

	result = (t_nest){false, start_token, start};
	state = (t_state){{false, false}, start_token, start + 1, 1};
	result = check_paren_in_token(&state, end, input);
	if (result.success)
		return (result);
	curr = state.token->next;
	while (curr && state.paren_count > 0)
	{
		state.pos = 0;
		input = curr->value;
		result = check_paren_in_multiple_token(&state, input, curr);
		if (result.success)
			return (result);
		curr = curr->next;
	}
	report_error(ERR_SYNTAX, "unbalanced parenthesis");
	return (result);
}

bool	handle_paren(char *input, t_open_paren *paren, int *end,
	t_token **curr)
{
	t_nest				result;

	result = validate_nested_paren(input, paren->i, *end, *curr);
	if (!result.success)
		return (false);
	if (result.token != *curr)
	{
		*curr = result.token;
		input = (*curr)->value;
		*end = ft_strlen(input);
		paren->i = result.position + 1;
	}
	else
		paren->i = result.position + 1;
	paren->has_commands = true;
	paren->expecting_commands = false;
	return (true);
}

bool	validate_paren_content(char *input, int start, int end,
	t_token *token)
{
	t_open_paren		paren;
	char				*curent_input;
	t_token				*curr;

	paren = (t_open_paren){false, true, start};
	curent_input = input;
	curr = token;
	while (paren.i < end)
	{
		if (skip_whitespaces(input, &paren.i, end))
			break ;
		if (curent_input[paren.i] == '(')
		{
			if (!handle_paren(input, &paren, &end, &curr))
				return (false);
			continue ;
		}
		if (op_paren(input, &paren, token) || pipe_paren(input, &paren, token)
			|| seq_paren(input, &paren, token))
			continue ;
		if (!validate_redirect_or_command(input, &paren, end, token))
			return (false);
	}
	return (validate_paren_content_utils(&paren, token));
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_content.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 21:09:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/09 00:24:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	valid_before_open_paren(char c)
{
	return (ft_isspace(c) || c == '|' || c == '&' || c == '('
		|| c == ';' || c == '\0');
}

bool	is_valid_after_open_paren(char c)
{
	return (ft_isalnum(c) || c == '(' || c == '$');
}

bool	is_valid_close_paren(char c)
{
	return (ft_isspace(c) || c == '|' || c == '&' || c == ')' || c == ';'
		|| c == '\0');
}

bool	skip_whitespaces(char *input, int *i, int end)
{
	while (*i < end && ft_isspace(input[*i]))
		(*i)++;
	return (*i >= end);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils_1.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 23:59:21 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/10 16:19:47 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	validate_redirect_or_command(char *input, t_open_paren *paren,
	int end, t_token *token)
{
	if (validate_redirect_in_paren(input, paren, end, token))
		return (true);
	if (is_valid_command_char(input[paren->i]))
	{
		while (paren->i < end && is_valid_command_char(input[paren->i]))
			paren->i++;
		paren->has_commands = true;
		paren->expecting_commands = false;
	}
	else
	{
		report_error(ERR_SYNTAX, "invalid syntax near character");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	seq_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (input[paren->i] == ';')
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "sequence without preceding commands");
			free_stack(token);
			return (false);
		}
		paren->i++;
		paren->has_commands = false;
		paren->expecting_commands = true;
		return (true);
	}
	return (false);
}

bool	pipe_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (input[paren->i] == '|' && input[paren->i + 1] != '|')
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "pipe without preceding commands");
			free_stack(token);
			return (false);
		}
		paren->i++;
		paren->expecting_commands = true;
		paren->has_commands = false;
		return (true);
	}
	return (false);
}

bool	op_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (ft_is_logical_op(input[paren->i], input[paren->i + 1]))
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "operator without preceding command");
			free_stack(token);
			return (false);
		}
		paren->i += 2;
		paren->expecting_commands = true;
		paren->has_commands = false;
		return (true);
	}
	return (false);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_1.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils_2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 02:26:37 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 16:57:15 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	validate_redirect_in_paren(char *input, t_open_paren *paren, int end,
	t_token *token)
{
	if (ft_is_redirection(input[paren->i]))
	{
		if (paren->i + 1 < end && input[paren->i] == input[paren->i + 1])
			paren->i += 2;
		else
			paren->i++;
		while (paren->i < end && ft_isspace(input[paren->i]))
			paren->i++;
		if (paren->i >= end || !is_valid_command_char(input[paren->i]))
		{
			report_error(ERR_SYNTAX, "redirection without filenamd");
			free_stack(token);
			return (false);
		}
		while (paren->i < end && is_valid_command_char(input[paren->i]))
			paren->i++;
	}
	return (true);
}

bool	validate_paren_content_utils(t_open_paren *paren, t_token *token)
{
	if (paren->expecting_commands && !paren->has_commands)
	{
		report_error(ERR_SYNTAX, "missing command after operator");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	check_closed_paren(char *input, int i, t_token *token)
{
	if (!ft_isspace(input[i + 1]) && !is_valid_close_paren(input[i + 1])
		&& !ft_is_redirection(input[i + 1]) && !ft_is_wildcard(input[i + 1]))
	{
		report_error(ERR_SYNTAX, "invalid token after ')'");
		return (free_stack(token), false);
	}
	if (ft_is_redirection_op(input[i], input[i + 1]))
		return (true);
	if (ft_is_wildcard(input[i + 1]) && !ft_isspace(input[i + 1]))
	{
		report_error(ERR_SYNTAX, "missing space after ')'");
		return (free_stack(token), false);
	}
	return (true);
}

bool	process_close_paren(char *input, int i, t_token *token,
	t_paren *command)
{
	if (is_empty(token))
	{
		report_error(ERR_UNEXPECTED_TOKEN, ")");
		return (free_stack(token), false);
	}
	if (!command->has_content)
	{
		report_error(ERR_SYNTAX, "empty parenthesis");
		return (free_stack(token), false);
	}
	if (input[i + 1])
	{
		if (is_command_or_arg_char(input[i + 1]))
		{
			report_error(ERR_SYNTAX, "missing operator or space after ')'");
			return (free_stack(token), false);
		}
		if (!check_closed_paren(input, i, token))
			return (false);
	}
	else if (!check_next_token(token->next))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_2.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_validation.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_validation.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/23 17:59:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/07 15:42:09 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

void	process_quotes(char c, t_quotes *quote)
{
	if (c == '"' && !quote->in_single_quotes)
		quote->in_double_quotes = !quote->in_double_quotes;
	else if (c == '\'' && !quote->in_double_quotes)
		quote->in_single_quotes = !quote->in_single_quotes;
}

bool	parenthesis(t_token *token, char *input, t_paren *commands)
{
	int			i;

	i = 0;
	while (input[i] != '\0')
	{
		process_quotes(input[i], &commands->quote);
		if (!check_parenthesis(token, input, i, commands))
			return (false);
		i++;
	}
	return (true);
}

bool	parenthesis_utils(t_token *tokenize)
{
	char		*input;
	t_token		*stack;
	t_paren		commands;

	stack = tokenize;
	commands = (t_paren){false, false, '\0', false, 0, false, (t_quotes){false, false}};
	initialize_stack(stack);
	while (stack && stack->value)
	{
		input = stack->value;
		if (stack->single_quotes == 1)
			return (true);
		else if (stack->double_quotes == 1)
			return (true);
		if (!parenthesis(stack, input, &commands))
			return (false);
		stack = stack->next;
	}
	if (!is_empty(stack))
		return (report_error(ERR_UNEXPECTED_TOKEN, ")"),
			free_stack(stack), false);
	free_stack(stack);
	free(stack);
	return (true);
}

bool	check_count_paren(t_token *tokenize)
{
	int		paren_count;

	paren_count = count_parenthesis(tokenize);
	if (paren_count != 0)
	{
		if (paren_count > 0)
			report_error(ERR_UNEXPECTED_TOKEN, ")");
		else
			report_error(ERR_UNEXPECTED_TOKEN, "(");
		return (false);
	}
	if (!parenthesis_utils(tokenize))
		return (false);
	return (true);
}

bool	validation_parenthesis(t_token *tokenize)
{
	if (!tokenize)
		return (true);
	if (!check_count_paren(tokenize))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_validation.c ###


### START OF FILE: ./src/parse/validation/pipes/pipes_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 00:23:14 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/15 18:52:41 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	is_operator_token(t_token *prev)
{
	if (!prev)
		return (false);
	return (prev->type == TOKEN_REDIRECT_IN || prev->type == TOKEN_REDIRECT_OUT
		|| prev->type == TOKEN_APPEND || prev->type == TOKEN_HEREDOC
		|| prev->type == TOKEN_AND || prev->type == TOKEN_OR
		|| prev->type == TOKEN_PIPE);
}

bool	has_whitespace_between(t_token *first, t_token *second)
{
	t_token		*curr;

	curr = first->next;
	while (curr && curr != second)
	{
		if (curr->type == TOKEN_WORD && is_only_whitespaces(curr->value))
			return (true);
		curr = curr->next;
	}
	return (false);
}

bool	is_only_whitespaces(char *str)
{
	int			i;

	i = 0;
	if (!str)
		return (false);
	while (str[i] != '\0')
	{
		if (!ft_isspace(str[i]))
			return (false);
		i++;
	}
	return (true);
}

bool	return_pipes_mssg(bool *expecting_cmd)
{
	if (*expecting_cmd)
	{
		report_error(ERR_SYNTAX, "missing command after pipes");
		return (false);
	}
	return (true);
}

bool	check_redirection_before_pipe(t_token *curr, t_token *head)
{
	t_token		*check;
	t_token		*last_redir;
	bool		has_filename;

	check = head;
	while (check != curr)
	{
		if ((check->type == TOKEN_APPEND || check->type == TOKEN_REDIRECT_OUT)
			&& check->next == curr)
			return (true);
		check = check->next;
	}
	check = head;
	last_redir = NULL;
	has_filename = false;
	while (check != curr)
	{
		if (check->type == TOKEN_APPEND || check->type == TOKEN_REDIRECT_IN
			|| check->type == TOKEN_REDIRECT_OUT
			|| check->type == TOKEN_HEREDOC)
		{
			if (check->next == curr)
			{
				last_redir = NULL;
			}
			last_redir = check;
			has_filename = false;
		}
		else if (last_redir && check->type == TOKEN_WORD
			&& !is_only_whitespaces(check->value))
			has_filename = true;
		check = check->next;
	}
	if (last_redir && !has_filename)
		return (report_error(ERR_SYNTAX, "missing filename before pipes"),
			false);
	return (true);
}

### END OF FILE: ./src/parse/validation/pipes/pipes_utils.c ###


### START OF FILE: ./src/parse/validation/pipes/validation_pipes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_pipes.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 19:22:21 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:31:46 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_pipe_followed_by_logical(t_token *curr)
{
	t_token		*next;

	next = curr->next;
	while (next && next->type == TOKEN_WORD && is_only_whitespaces(next->value))
		next = next->next;
	if (next && (next->type == TOKEN_AND || next->type == TOKEN_OR))
	{
		if (next->type == TOKEN_AND && ft_strcmp(next->value, "&&") == 0)
			report_error(ERR_SYNTAX, "invalid operator sequence '|&&'");
		else if (next->type == TOKEN_OR && ft_strcmp(next->value, "||") == 0)
			report_error(ERR_SYNTAX, "invalid opeartor sequence '|||'");
		else
			report_error(ERR_SYNTAX, "invalid operator sequence");
		return (false);
	}
	return (true);
}

bool	check_operator_before_pipe(t_token *prev, t_token *curr)
{
	t_token		*check;
	bool		has_word;

	if (!is_operator_token(prev))
		return (true);
	if (prev->type == TOKEN_REDIRECT_OUT && ft_strcmp(prev->value, ">") == 0
		&& !has_whitespace_between(prev, curr))
		return (true);
	if (prev->type == TOKEN_APPEND && ft_strcmp(prev->value, ">>") == 0
		&& !has_whitespace_between(prev, curr))
		return (true);
	check = prev->next;
	has_word = false;
	while (check && check != curr)
	{
		if (check->type == TOKEN_WORD && !is_only_whitespaces(check->value))
		{
			has_word = true;
			break ;
		}
		check = check->next;
	}
	if (!has_word)
		return (report_error(ERR_SYNTAX, "token '|'"), false);
	return (true);
}

bool	validate_pipe_position(t_token *prev, t_token *curr, t_token *head)
{
	t_token		*next;

	if (!check_redirection_before_pipe(curr, head))
		return (false);
	if (curr->next == NULL)
	{
		report_error(ERR_UNEXPECTED_TOKEN, "'|'");
		return (false);
	}
	if (!check_pipe_followed_by_logical(curr))
		return (false);
	next = curr->next;
	while (next && next->type == TOKEN_WORD && is_only_whitespaces(next->value))
		next = next->next;
	if (next && next->type == TOKEN_PIPE)
		return (report_error(ERR_UNEXPECTED_TOKEN, "'|'"), false);
	if (!check_operator_before_pipe(prev, curr))
		return (false);
	return (true);
}

bool	has_expecting_command(t_token *curr, bool *expecting_command)
{
	t_token		*next;

	if (curr->type == TOKEN_WORD && is_only_whitespaces(curr->value))
		return (true);
	else if (curr->type == TOKEN_WORD && !is_only_whitespaces(curr->value))
		*expecting_command = false;
	else if (curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_REDIRECT_OUT
		|| curr->type == TOKEN_APPEND || curr->type == TOKEN_HEREDOC)
	{
		next = curr->next;
		if (!next)
			return (report_error(ERR_SYNTAX, "newline"), false);
		while (next && next->type == TOKEN_WORD
			&& is_only_whitespaces(next->value))
			next = next->next;
		if (next->type == TOKEN_WORD && !is_only_whitespaces(next->value))
			*expecting_command = false;
	}
	else if (curr->type == TOKEN_AND || curr->type == TOKEN_OR
		|| curr->type == TOKEN_PIPE)
	{
		report_error(ERR_SYNTAX, "missing command");
		return (false);
	}
	return (true);
}

bool	pipes(t_token *tokenize)
{
	t_pipe		pipe;

	pipe = (t_pipe){tokenize, NULL, tokenize, false};
	while (pipe.curr)
	{
		if (pipe.curr->type == TOKEN_WORD
			&& is_only_whitespaces(pipe.curr->value))
		{
			pipe.prev = pipe.curr;
			pipe.curr = pipe.curr->next;
			continue ;
		}
		if (pipe.curr->type == TOKEN_PIPE)
		{
			if (!validate_pipe_position(pipe.prev, pipe.curr, pipe.head))
				return (false);
			pipe.expecting_command = true;
		}
		else if (pipe.expecting_command
			&& !has_expecting_command(pipe.curr, &pipe.expecting_command))
			return (false);
		pipe.prev = pipe.curr;
		pipe.curr = pipe.curr->next;
	}
	return (return_pipes_mssg(&pipe.expecting_command));
}

### END OF FILE: ./src/parse/validation/pipes/validation_pipes.c ###


### START OF FILE: ./src/parse/validation/quotes/validation_quotes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_quotes.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 09:57:00 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/03 12:04:07 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	check_quotes(t_quotes *quote)
{
	if (quote->in_double_quotes || quote->in_single_quotes)
	{
		report_error(ERR_SYNTAX, "Unmtached %c quote detected");
		return (false);
	}
	return (true);
}

bool	validation_quotes(t_token *tokens)
{
	t_token		*curr;
	t_quotes	quote;
	int			i;
	char		*value;

	curr = tokens;
	quote = (t_quotes){false, false};
	while (curr)
	{
		if (curr->type == TOKEN_WORD)
		{
			value = curr->value;
			i = 0;
			while (value && value[i])
			{
				process_quotes(value[i], &quote);
				i++;
			}
		}
		curr = curr->next;
	}
	if (!check_quotes(&quote))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/quotes/validation_quotes.c ###


### START OF FILE: ./src/parse/validation/redirections/redirections_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:12:46 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:23:31 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_redirection(char c)
{
	return (c == '<' || c == '>');
}

bool	ft_is_redirection_op(char curr, char next)
{
	return ((curr == '>' && curr == '>') || (curr == '<' && next == '<'));
}

bool	check_after_redirection(t_token **curr)
{
	if (((*curr)->type == TOKEN_REDIRECT_OUT || (*curr)->type == TOKEN_APPEND
			|| (*curr)->type == TOKEN_REDIRECT_IN
			|| (*curr)->type == TOKEN_HEREDOC) && (*curr)->next
		&& ((*curr)->next->type == TOKEN_OR
			|| (*curr)->next->type == TOKEN_AND))
		return (report_error(ERR_UNEXPECTED_TOKEN, (*curr)->next->value),
			false);
	return (true);
}

bool	validate_next_redirect(t_token **next, t_token **curr)
{
	while (*next && (*next)->type == TOKEN_WHITESPACE)
		*next = (*next)->next;
	if (!*next || ((*next)->type != TOKEN_WORD
			&& (*next)->type != TOKEN_PROCESSED))
	{
		if (!*next)
			report_error(ERR_UNEXPECTED_TOKEN, "newline");
		else
			report_error(ERR_UNEXPECTED_TOKEN, (*curr)->value);
		return (false);
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/redirections/redirections_utils.c ###


### START OF FILE: ./src/parse/validation/redirections/validate_redirection.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_redirection.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/15 13:11:15 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:22:54 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_redirection(t_token **next)
{
	if (*next && ((*next)->type == TOKEN_APPEND
			|| (*next)->type == TOKEN_REDIRECT_IN
			|| (*next)->type == TOKEN_HEREDOC
			|| (*next)->type == TOKEN_REDIRECT_OUT))
	{
		report_error(ERR_UNEXPECTED_TOKEN, (*next)->value);
		return (false);
	}
	else if (*next && ((*next)->type == TOKEN_AND || (*next)->type == TOKEN_OR))
	{
		report_error(ERR_UNEXPECTED_TOKEN, (*next)->value);
		return (false);
	}
	return (true);
}

bool	check_adjacent_redirection(t_token **curr)
{
	if ((*curr)->type == TOKEN_REDIRECT_IN && (*curr)->next
		&& (*curr)->next->type == TOKEN_REDIRECT_OUT)
	{
		(*curr)->type = TOKEN_READWRITE;
		free((*curr)->value);
		(*curr)->value = ft_strdup("<>");
		(*curr)->next->type = TOKEN_PROCESSED;
		return (true);
	}
	return (true);
}

bool	validate_redirection_spaces(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr != NULL)
	{
		if (curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_APPEND
			|| curr->type == TOKEN_REDIRECT_OUT || curr->type == TOKEN_HEREDOC)
		{
			next = curr->next;
			if (next && next->type == TOKEN_WHITESPACE)
			{
				next = next->next;
				if (!check_redirection(&next))
					return (false);
			}
		}
		if (!check_after_redirection(&curr))
			return (false);
		curr = curr->next;
	}
	return (true);
}

bool	validate_redirection_combinations(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr && curr->next)
	{
		if (curr->type == TOKEN_HEREDOC || curr->type == TOKEN_REDIRECT_OUT
			|| curr->type == TOKEN_APPEND || curr->type == TOKEN_REDIRECT_OUT)
		{
			next = curr->next;
			while (next && next->type == TOKEN_WHITESPACE)
				next = next->next;
			if (next && (next->type == TOKEN_REDIRECT_OUT
					|| next->type == TOKEN_APPEND
					|| next->type == TOKEN_REDIRECT_IN
					|| next->type == TOKEN_HEREDOC))
			{
				report_error(ERR_UNEXPECTED_TOKEN, next->value);
				return (false);
			}
		}
		curr = curr->next;
	}
	return (validate_redirection_spaces(tokenize));
}

bool	validate_redirection(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr != NULL)
	{
		if (curr->type == TOKEN_PROCESSED)
		{
			curr = curr->next;
			continue ;
		}
		if (curr->type == TOKEN_APPEND || curr->type == TOKEN_REDIRECT_IN
			|| curr->type == TOKEN_REDIRECT_OUT || curr->type == TOKEN_HEREDOC)
		{
			if (!check_adjacent_redirection(&curr))
				return (false);
			next = curr->next;
			if (!validate_next_redirect(&next, &curr))
				return (true);
		}
		curr = curr->next;
	}
	return (validate_redirection_combinations(tokenize));
}

### END OF FILE: ./src/parse/validation/redirections/validate_redirection.c ###


### START OF FILE: ./src/parse/validation/validation.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 16:01:41 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:52:05 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

bool	validation_utils(t_token *tokenize)
{
	if (!pipes(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validate_redirection(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	return (true);
}

bool	validation(t_token *tokenize)
{
	if (!validate_logical_op(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validate_commands(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_parenthesis(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_quotes(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_utils(tokenize))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/validation.c ###


### START OF FILE: ./src/parse/validation/wildcards/wildcards_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wildcards_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 20:29:29 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/03 20:31:18 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_wildcard(char c)
{
	return (c == '*' || c == '?');
}

### END OF FILE: ./src/parse/validation/wildcards/wildcards_utils.c ###


### START OF FILE: ./src/tree/parse_commands.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_commands.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/22 17:53:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 00:08:51 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*init_command_node(t_token *start, int word_count)
{
	t_ast		*node;

	node = create_ast_node(AST_COMMAND, start);
	if (!node)
		return (NULL);
	node->cmd = create_command_struct();
	if (!node->cmd)
	{
		free(node);
		return (NULL);
	}
	node->cmd->args = malloc(sizeof(char *) * (word_count + 1));
	if (!node->cmd->args)
	{
		free(node->cmd);
		free(node);
		return (NULL);
	}
	return (node);
}

t_ast	*create_command_node(t_token *start, int word_count)
{
	t_ast		*node;
	t_token		*curr;
	int			i;

	node = init_command_node(start, word_count);
	if (!node)
		return (NULL);
	curr = start;
	i = 0;
	while (i < word_count)
	{
		skip_tree_whitespaces(&curr);
		if (curr && curr->type == TOKEN_WORD)
		{
			node->cmd->args[i] = ft_strdup(curr->value);
			curr = curr->next;
			i++;
		}
		else
			break ;
	}
	node->cmd->args[i] = NULL;
	return (node);
}

### END OF FILE: ./src/tree/parse_commands.c ###


### START OF FILE: ./src/tree/parse_redir.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_redir.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/21 22:06:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 22:15:23 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_type	get_redir_type(t_token *tokens)
{
	if (!tokens)
		return (0);
	if (tokens->type == TOKEN_APPEND)
		return (AST_REDIR_APPEND);
	else if (tokens->type == TOKEN_HEREDOC)
		return (AST_REDIR_HERDOC);
	else if (tokens->type == TOKEN_REDIRECT_IN)
		return (AST_REDIR_IN);
	else if (tokens->type == TOKEN_REDIRECT_OUT)
		return (AST_REDIR_OUT);
	return (0);
}

t_ast	*create_redir(t_token **token, t_ast *cmd_node)
{
	t_token		*curr;
	t_ast		*node;

	curr = *token;
	if (!curr)
		return (NULL);
	node = create_ast_node(get_redir_type(curr), curr);
	if (!node)
		return (NULL);
	node->operator_type = curr->type;
	node->left = cmd_node;
	if (curr->next)
		curr = curr->next;
	else
		return (node);
	skip_tree_whitespaces(&curr);
	*token = curr;
	return (node);
}

t_ast	*create_right_node(t_token **token)
{
	t_ast		*right_node;
	t_token		*curr;

	curr = *token;
	right_node = create_ast_node(AST_COMMAND, curr);
	if (!right_node)
		return (NULL);
	right_node->cmd = create_command_struct();
	if (!right_node)
	{
		free(right_node);
		return (NULL);
	}
	right_node->cmd->args = malloc(sizeof(char *) * 2);
	if (!right_node->cmd->args)
	{
		free(right_node);
		return (NULL);
	}
	right_node->cmd->args[0] = ft_strdup(curr->value);
	right_node->cmd->args[1] = NULL;
	*token = curr->next;
	return (right_node);
}

t_ast	*parse_redirection(t_token **tokens, t_ast *cmd_node)
{
	t_ast		*node;
	t_token		*curr;

	if (!tokens || !*tokens || !cmd_node)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	if (get_redir_type(curr) == 0)
		return (NULL);
	node = create_redir(&curr, cmd_node);
	if (!node || !curr || curr->type != TOKEN_WORD)
	{
		free(node);
		return (NULL);
	}
	node->right = create_right_node(&curr);
	if (!node->right)
	{
		free(node);
		return (NULL);
	}
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	return (node);
}

### END OF FILE: ./src/tree/parse_redir.c ###


### START OF FILE: ./src/tree/tree.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 15:32:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 20:06:32 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*parse_command(t_token **tokens)
{
	t_token		*current;

	if (!tokens || !*tokens)
		return (NULL);
	current = *tokens;
	skip_tree_whitespaces(&current);
	*tokens = current;
	if (current->type == TOKEN_PAREN_OPEN)
		return (parse_subshell(tokens));
	return (parse_simple_commands(tokens));
}

t_ast	*parse_pipeline(t_token **tokens)
{
	t_ast		*left;
	t_token		*curr;

	if (!tokens || !*tokens)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	left = parse_command(tokens);
	if (!left)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	while (curr && curr->type == TOKEN_PIPE)
	{
		left = parse_pipeline_node(left, tokens);
		if (!left)
			return (NULL);
		curr = *tokens;
		skip_tree_whitespaces(&curr);
		*tokens = curr;
	}
	return (left);
}

t_ast	*init_logic_node(t_ast *left, t_token **tokens)
{
	t_ast_type	node_type;
	t_token		*curr;
	t_ast		*node;

	curr = *tokens;
	if (curr->type == TOKEN_AND)
		node_type = AST_AND;
	else if (curr->type == TOKEN_OR)
		node_type = AST_OR;
	else
		return (NULL);
	node = create_ast_node(node_type, curr);
	if (!node)
		return (free_ast(left), NULL);
	node->left = left;
	if (curr->next)
		curr = curr->next;
	else
		return (NULL);
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	node->right = parse_pipeline(tokens);
	if (!node->right)
		return (free_ast(left), NULL);
	return (node);
}

t_ast	*parse_logic_sequence(t_token **tokens)
{
	t_ast		*left;
	t_ast		*node;
	t_token		*current;

	current = *tokens;
	skip_tree_whitespaces(&current);
	*tokens = current;
	left = parse_pipeline(tokens);
	if (!left)
		return (NULL);
	current = *tokens;
	skip_tree_whitespaces(&current);
	*tokens = current;
	while (current && (current->type == TOKEN_AND || current->type == TOKEN_OR))
	{
		node = init_logic_node(left, tokens);
		if (!node)
			return (NULL);
		left = node;
		current = *tokens;
		skip_tree_whitespaces(&current);
		*tokens = current;
	}
	return (left);
}

t_ast	*parse_tokens(t_token *tokens)
{
	t_token		*curr;
	t_ast		*root;

	if (!tokens)
		return (NULL);
	curr = tokens;
	skip_tree_whitespaces(&curr);
	root = parse_command_line(&curr);
	skip_tree_whitespaces(&curr);
	if (curr && curr->type != TOKEN_EOF)
	{
		free_ast(root);
		return (NULL);
	}
	return (root);
}

### END OF FILE: ./src/tree/tree.c ###


### START OF FILE: ./src/tree/tree_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/18 21:23:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 17:02:45 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*parse_pipeline_node(t_ast *left, t_token **tokens)
{
	t_token		*curr;
	t_ast		*node;

	curr = *tokens;
	node = create_ast_node(AST_PIPELINE, curr);
	if (!node)
	{
		free_ast(left);
		return (NULL);
	}
	node->left = left;
	if (curr->next)
		curr = curr->next;
	else
		return (node);
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	node->right = parse_command_line(tokens);
	if (!node->right)
	{
		free_ast(left);
		return (NULL);
	}
	return (node);
}

void	skip_tree_whitespaces(t_token **tokens)
{
	while (*tokens && (*tokens)->type == TOKEN_WHITESPACE)
		*tokens = (*tokens)->next;
}

t_ast	*create_ast_node(t_ast_type type, t_token *token)
{
	t_ast		*node;

	node = malloc(sizeof(t_ast));
	if (!node)
		return (NULL);
	node->type = type;
	node->left = NULL;
	node->right = NULL;
	node->cmd = NULL;
	node->operator_type = 0;
	node->token = token;
	return (node);
}

t_ast	*parse_command_line(t_token **tokens)
{
	return (parse_logic_sequence(tokens));
}

void	free_ast(t_ast *node)
{
	int			i;

	if (!node)
		return ;
	free_ast(node->left);
	free_ast(node->right);
	if (node->cmd)
	{
		if (node->cmd->args)
		{
			i = -1;
			while (node->cmd->args[++i])
				free(node->cmd->args[i]);
			free(node->cmd->args[i]);
		}
		if (node->cmd->infile)
			free(node->cmd->infile);
		if (node->cmd->outfile)
			free(node->cmd->outfile);
		if (node->cmd->heredoc_delim)
			free(node->cmd->heredoc_delim);
		free(node->cmd);
	}
}

### END OF FILE: ./src/tree/tree_utils.c ###


### START OF FILE: ./src/tree/tree_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree_utils_1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 17:45:55 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 17:22:02 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_commands	*create_command_struct(void)
{
	t_commands		*cmd;

	cmd = malloc(sizeof(t_commands));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->infile = NULL;
	cmd->outfile = NULL;
	cmd->heredoc_delim = NULL;
	cmd->append = 0;
	cmd->is_builtin = 0;
	return (cmd);
}

t_ast	*init_subshell_node(t_token **tokens)
{
	t_token		*curr;
	t_ast		*node;

	if (!tokens || !*tokens)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	if (curr->type != TOKEN_PAREN_OPEN)
		return (NULL);
	node = create_ast_node(AST_SUBSHELL, curr);
	if (!node)
		return (NULL);
	*tokens = curr->next;
	skip_tree_whitespaces(tokens);
	return (node);
}

t_ast	*parse_subshell(t_token **tokens)
{
	t_ast		*node;
	t_token		*curr;

	node = init_subshell_node(tokens);
	if (!node)
		return (NULL);
	node->left = parse_command_line(tokens);
	if (!node->left)
	{
		free(node);
		return (NULL);
	}
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	if (!curr || curr->type != TOKEN_PAREN_CLOSE)
	{
		free_ast(node);
		return (NULL);
	}
	*tokens = curr->next;
	return (node);
}

t_ast	*parse_command_words(t_token **tokens)
{
	t_ast		*cmd_node;
	t_token		*curr;
	t_token		*start;
	int			word_count;

	if (!tokens || !*tokens)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	start = curr;
	word_count = 0;
	while (curr && curr->type == TOKEN_WORD)
	{
		word_count++;
		curr = curr->next;
		skip_tree_whitespaces(&curr);
	}
	if (word_count == 0)
		return (NULL);
	cmd_node = create_command_node(start, word_count);
	if (!cmd_node)
		return (NULL);
	*tokens = curr;
	return (cmd_node);
}

t_ast	*parse_simple_commands(t_token **tokens)
{
	t_ast		*redir_node;
	t_ast		*cmd_node;
	t_token		*curr;

	cmd_node = parse_command_words(tokens);
	if (!cmd_node)
		return (NULL);
	curr = *tokens;
	while (curr && (curr->type == TOKEN_APPEND
			|| curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_HEREDOC
			|| curr->type == TOKEN_REDIRECT_OUT))
	{
		redir_node = parse_redirection(tokens, cmd_node);
		if (!redir_node)
		{
			free_ast(cmd_node);
			return (NULL);
		}
		cmd_node = redir_node;
		curr = *tokens;
		skip_tree_whitespaces(&curr);
		*tokens = curr;
	}
	return (cmd_node);
}

### END OF FILE: ./src/tree/tree_utils_1.c ###
