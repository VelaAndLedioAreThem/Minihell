

### START OF FILE: ./include/minishell.h ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   minishell.h                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 01:04:11 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/25 16:31:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/* ************************************************************************** */

#ifndef MINISHELL_H
# define MINISHELL_H

# include <stdio.h>
# include <stdlib.h>
# include <unistd.h>
# include <fcntl.h>
# include <sys/types.h>
# include <sys/wait.h>
# include <sys/stat.h>
# include <signal.h>
# include <dirent.h>
# include <string.h>
# include <errno.h>
# include <termios.h>
# include <curses.h>
# include <term.h>
# include <sys/ioctl.h>
# include <readline/readline.h>
# include <readline/history.h>
# include "../libft/include/libft.h"
# define TOKEN_PROCESSED 42
# define TOKEN_READWRITE 43

// Parsing struct 
typedef enum e_token_type
{
	TOKEN_WORD,
	TOKEN_PIPE,
	TOKEN_REDIRECT_IN,
	TOKEN_REDIRECT_OUT,
	TOKEN_APPEND,
	TOKEN_HEREDOC,
	TOKEN_AND,
	TOKEN_OR,
	TOKEN_PAREN_OPEN,
	TOKEN_PAREN_CLOSE,
	TOKEN_EOF,
	TOKEN_WILDCARD,
	TOKEN_WHITESPACE
}	t_token_type;

typedef enum e_ast_type
{
	AST_COMMAND,
	AST_PIPELINE,
	AST_REDIR_IN,
	AST_REDIR_OUT,
	AST_REDIR_APPEND,
	AST_REDIR_HERDOC,
	AST_AND,
	AST_OR,
	AST_SUBSHELL,
	AST_EOF
}	t_ast_type;

// Erorrs Messages
typedef enum e_errors_code
{
	ERR_NONE,
	ERR_UNBALANCED_PAREN,
	ERR_SYNTAX,
	ERR_UNEXPECTED_TOKEN,
	ERR_MEMORY,
	ERR_PARSE
}	t_errors_code;

typedef enum e_flag_state
{
	FLAG_NONE,
	FLAG_SINGLE_DASH,
	FLAG_DOUBLE_DASH
}	t_flag_state;

typedef struct s_env
{
	char			*key;
	char			*value;
	struct s_env	*next;
}	t_env;

typedef struct s_quote
{
	bool			in_single_quotes;
	bool			in_double_quotes;
}	t_quotes;

// Parenthesis struct
typedef struct s_open_paren
{
	bool			has_commands;
	bool			expecting_commands;
	int				i;
}	t_open_paren;

typedef struct s_paren
{
	bool			has_commands;
	bool			has_content;
	char			last_op;
	bool			has_cmd_before;
	int				j;
	bool			has_operator;
	t_quotes		quote;
}	t_paren;

// Commands struct
typedef struct s_cmd
{
	bool		in_commands;
	bool		is_cmd_pos;
}	t_cmd;

typedef struct s_stack
{
	char			name;
	struct s_stack	*next;
}	t_stack;

typedef struct s_token
{
	char			*value;
	t_token_type	type;
	int				expandable;
	int				double_quotes;
	int				single_quotes;
	t_stack			*top;
	struct s_token	*next;
}	t_token;

typedef struct s_pipe
{
	t_token		*curr;
	t_token		*prev;
	t_token		*head;
	bool		expecting_command;
}	t_pipe;

typedef struct s_nest
{
	bool			success;
	t_token			*token;
	int				position;
}	t_nest;

typedef struct s_state
{
	t_quotes		quote;
	t_token			*token;
	int				pos;
	int				paren_count;
}	t_state;


typedef struct s_command
{
	char			**args;
	char			*infile;
	char			*outfile;
	char			*heredoc_delim;
	int				append;
	int				is_builtin;
}	t_commands;

typedef struct s_args
{
	int				argc;
	char			**argv;
	int				exit_status;
	char			*input;
	int				start;
	char			*result;
	int				single_quotes;
	int				double_quotes;
	int				last_quotes;
}	t_args;

// Main struct
typedef struct s_ast
{
	t_ast_type		type;
	struct s_ast	*left;
	struct s_ast	*right;
	long int		exit_status;
	t_commands		*cmd;
	int				operator_type;
	t_token			*token;
	char			**heredoc_files; // Array of temp file paths
	int				heredoc_count;   // Number of heredoc temp files
	t_env          *env_list;  // Add this line

}	t_ast;

typedef int (*t_builtin_func)(t_ast *data, t_ast *tree, int fd_out);

typedef struct s_builtin {
    const char      *name;
    t_builtin_func  func;
} t_builtin;
typedef struct s_signal {
	struct sigaction    	sa_new;
	struct sigaction    	sa_old;
	volatile sig_atomic_t 	sigint;
} t_signal;
// Execution function prototypes
extern pid_t g_child_pid;  // Header declaration
/* helpers.h */
void	print_export_error(char *arg);
void	print_unset_error(char *name);
char	*get_export_name(char *arg, char *eq);
void	update_existing_env(t_env *env, char *eq, char *name);
int		create_new_env(t_ast *d, char *n, char *eq);
int		handle_cd_home(t_ast *data, char **path, char *old_pwd);
void	handle_cd_error(char *path, char *old_pwd);
char	*get_cd_path(t_ast, char *arg, char *oldpwd);
void	update_pwd_vars(t_ast,char *oldpwd);
void	free_data(t_ast *data);
void	ft_strdel(char **as);
char	*find_executable_path(t_ast *data, char *cmd);
char **expand_wildcards_in_args(char **args);
int get_output_file(t_ast *tree);
int get_input_file(t_ast *data, t_ast *tree);
char **env(t_env **lst);
int execute_or(t_ast *data, t_ast *tree);
int execute_and(t_ast *data, t_ast *tree);
int execute_pipe(t_ast *data, t_ast *tree);
int handle_builtin(t_ast *data, t_ast *tree, int fd_out);
int execute_word(t_ast *data, t_ast *tree);
char	*ft_strndup(const char *s, size_t n);
char *ft_strjoin3(const char *s1, const char *s2, const char *s3);
int execute_export(t_ast *data, t_ast *tree, int fd_out);
int create_heredoc_temp_file(char *delimiter, t_ast *data);
int execute_unset(t_ast *data, t_ast *tree);
void print_env_list(t_env *env_list, int fd_out);
int execute_cd(t_ast *data, char *path);
void set_env_var(t_ast *data, char *var_name, const char *var_value);
int execute_pwd(t_ast *data, int fd_out);
int execute_echo(char *args[], int fd_out);
int execute_exit(t_ast *data, t_ast *tree);

// Tokenization functions
t_token		*create_node(char *str, t_token_type type);
t_token		*tokenize(char *input);
void		append_node(t_token **token, t_token *current_token);
int			is_operator(char c);
int			return_parenthesis(t_token **token, char c);
int			handle_double_operator(t_token **head, char *input, int *i);
int			handle_single_operator(t_token **token, char c);
int			handle_word(t_token **token, char *input, int *i);
int			handle_quotes(t_token **token, char *input, int *i);
int			handle_whitespace(t_token **token, char *input, int *i);
// Environmental variables
t_env		*init_env_list(char **envp);
char		*gen_env_value(t_env *env_list, char *key);
char		*parse_env(char *input, t_env *env_list, t_args *arg);
char		*get_env_value(t_env *env_list, char *name);
char		*join_arguments(t_args *arg);
char		*env_expansion(char *input, int *i, t_env *env_list, t_args *arg);
t_env		*deep_copy_env_list(t_env *env_list);
// Validation
bool		validation(t_token *tokens);
bool		validation_parenthesis(t_token *tokenize);

// Parenthesis
bool		check_parenthesis(t_token *token, char *input, int i,
				t_paren *commands);
void		process_quotes(char c, t_quotes *quote);
bool		valid_before_open_paren(char c);
bool		is_valid_after_open_paren(char c);
int			find_matching_paren(t_token *token, char *input, int start_pos);
bool		validate_paren_content(char *input, int start_pos, int end_pos,
				t_token *token);
t_nest		validate_nested_paren(char *input, int start, int end,
				t_token *token);
bool		op_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		pipe_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		seq_paren(char *input, t_open_paren *paren,
				t_token *token);
bool		validate_redirect_in_paren(char *input, t_open_paren *paren,
				int end, t_token *token);
bool		validate_redirect_or_command(char *input, t_open_paren *paren,
				int end, t_token *token);
bool		validate_paren_content_utils(t_open_paren *paren, t_token *token);
bool		is_valid_close_paren(char c);
bool		process_close_paren(char *input, int i, t_token *token,
				t_paren *command);
bool		skip_whitespaces(char *input, int *i, int end);
bool		check_next_token(t_token *next);
bool		check_after_close_paren(char *input, int *i, t_token *token);
bool		it_is_log_or_pipe(char *input, int *i, t_token *token);
bool		it_is_logical_op(char *input, int *i, int *j, t_token *token);
bool		it_is_pipe(char *input, int *i, int *j, t_token *token);

// Operators
bool		ft_is_operator(char c);
bool		ft_is_logical_op(char current, char next);
bool		validate_logical_op(t_token *tokens);

// Quotes
bool		validation_quotes(t_token *tokens);

// Redirections
bool		ft_is_redirection(char c);
bool		ft_is_redirection_op(char current, char next);
bool		validate_next_redirect(t_token **next, t_token **curr);

//Commands
bool		ft_is_commands_position(char *input, int i);
bool		validate_commands(t_token *tokenize);
bool		is_valid_command_start(char c);
bool		is_valid_command_char(char c);
bool		is_command_or_arg_char(char c);
bool		is_valid_flag_char(char c);
bool		process_flag(char *str, int i,
				t_flag_state *flag_state);

// Wildcards
bool		ft_is_wildcard(char c);

// Pipes
bool		pipes(t_token *tokenize);
bool		is_operator_token(t_token *prev);
bool		has_whitespace_between(t_token *prev, t_token *curr);
bool		is_only_whitespaces(char *str);
bool		return_pipes_mssg(bool *expecting_cmd);
bool		check_redirection_before_pipe(t_token *curr, t_token *head);

// Redirect
bool		validate_redirection(t_token *tokenize);
bool		check_after_redirection(t_token **curr);

// Stack operations
void		push(t_token *stack, char data);
void		initialize_stack(t_token *stack);
char		pop(t_token *stack);
bool		is_empty(t_token *stack);

// Errors and Free functions
void		free_env_list(t_env *env_list);
t_token		*free_tokens(t_token *token);
void		report_error(t_errors_code code, char *token);
void		free_stack(t_token *token);

// Binary Tree
t_ast		*parse_tokens(t_token *tokens);
t_ast		*parse_command_line(t_token **curr);
t_ast		*parse_logic_sequence(t_token **tokens);
t_ast		*create_ast_node(t_ast_type type, t_token *token);
void		free_ast(t_ast *node);
t_ast		*parse_simple_commands(t_token **tokens);
t_commands	*create_command_struct(void);
t_ast		*create_command_node(t_token *start, int word_count);
void		skip_tree_whitespaces(t_token **tokens);
t_ast		*parse_redirection(t_token **tokens, t_ast *cmd_node);
t_ast		*parse_subshell(t_token **tokens);
t_ast		*parse_pipeline_node(t_ast *left, t_token **tokens);

// Utils functions
int			ft_strcmp(const char *s1, const char *s2);
int			count_parenthesis(t_token *tokens);
int			ft_isspace(int num);

void	clear_data(t_env **data, char **envp);
void	handle_signal(void);
void	free_2darray(char **array);
int execute_tree(t_ast *data,t_ast *tree);



#endif

### END OF FILE: ./include/minishell.h ###


### START OF FILE: ./src/execution/builtins/builtins.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: user <user@student.42.fr>                  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/00/00 00:00:00 by user              #+#    #+#             */
/*   Updated: 2023/00/00 00:00:00 by user             ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

static int	builtin_export(t_ast *data, t_ast *tree, int fd_out)
{
	if (!tree->cmd->args[1])
		print_env_list(data->env_list, fd_out);
	else
		execute_export(data, tree, fd_out);
	return (1);
}

static int	builtin_unset(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_unset(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_env(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	print_env_list(data->env_list, fd_out);
	return (1);
}

int	execute_home(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "HOME");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	return (0);
}

int	execute_oldpwd(t_ast *data, char *path, char *oldpwd)
{
	path = get_env_value(data->env_list, "OLDPWD");
	if (!path)
	{
		ft_putendl_fd("minishell: cd: OLDPWD not set", STDERR_FILENO);
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	ft_putendl_fd(path, STDOUT_FILENO);
	return (0);
}

static int	builtin_cd(t_ast *data, t_ast *tree, int fd_out)
{
	char	*path;
	char	*oldpwd;

	(void)fd_out;
	path = tree->cmd->args[1];
	oldpwd = getcwd(NULL, 0);
	if (!path || !ft_strcmp(path, "~"))
	{
		execute_home(data, path, oldpwd);
	}
	else if (!ft_strcmp(path, "-"))
	{
		execute_oldpwd(data, path, oldpwd);
	}
	if (execute_cd(data, path))
	{
		free(oldpwd);
		return (data->exit_status = 1, 1);
	}
	set_env_var(data, "OLDPWD", oldpwd);
	free(oldpwd);
	return (1);
}

static int	builtin_pwd(t_ast *data, t_ast *tree, int fd_out)
{
	(void)tree;
	if (execute_pwd(data, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_echo(t_ast *data, t_ast *tree, int fd_out)
{
	if (execute_echo(tree->cmd->args, fd_out))
		return (data->exit_status = 1, 1);
	return (1);
}

static int	builtin_exit(t_ast *data, t_ast *tree, int fd_out)
{
	(void)fd_out;
	if (execute_exit(data, tree))
		return (data->exit_status = 1, 1);
	return (1);
}

static const t_builtin	g_builtins[] = {
{"export", builtin_export},
{"unset", builtin_unset},
{"env", builtin_env},
{"cd", builtin_cd},
{"pwd", builtin_pwd},
{"echo", builtin_echo},
{"exit", builtin_exit},
	{NULL, NULL}
};

int	handle_builtin(t_ast *data, t_ast *tree, int fd_out)
{
	int	i;

	i = 0;
	if (!tree->cmd->args || !tree->cmd->args[0])
		return (0);
	while (g_builtins[i].name)
	{
		if (!ft_strcmp(tree->cmd->args[0], g_builtins[i].name))
			return (g_builtins[i].func(data, tree, fd_out));
		i++;
	}
	return (0);
}

### END OF FILE: ./src/execution/builtins/builtins.c ###


### START OF FILE: ./src/execution/builtins/builtins_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   builtins_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:17:20 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:17:20 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>
#include <errno.h>
#include <string.h>

bool	is_valid_identifier(const char *name)
{
	if (!name || !*name || ft_isdigit(*name))
		return (false);
	while (*name)
	{
		if (!ft_isalnum(*name) && *name != '_')
			return (false);
		name++;
	}
	return (true);
}

t_env	*get_env_node(t_env *env_list, const char *name)
{
	t_env	*current;

	current = env_list;
	while (current)
	{
		if (strcmp(current->key, name) == 0)
			return (current);
		current = current->next;
	}
	return (NULL);
}

static void	update_env_var(t_ast *data, const char *key, const char *value)
{
	t_env	*env;
	t_env	*new_env;

	env = get_env_node(data->env_list, key);
	if (env)
	{
		free(env->value);
		env->value = ft_strdup(value);
	}
	else
	{
		new_env = malloc(sizeof(t_env));
		new_env->key = ft_strdup(key);
		new_env->value = ft_strdup(value);
		new_env->next = data->env_list;
		data->env_list = new_env;
	}
}

int	execute_pwd(t_ast *data, int fd_out)
{
	char	*cwd;

	(void)data;
	cwd = getcwd(NULL, 0);
	if (!cwd)
	{
		ft_putendl_fd("minishell: pwd: error retrieving current directory",
			STDERR_FILENO);
		return (1);
	}
	ft_putendl_fd(cwd, fd_out);
	free(cwd);
	return (0);
}

int	execute_echo(char *args[], int fd_out)
{
	int	i;
	int	n_flag;

	i = 1;
	n_flag = 1;
	if (args[1] && !ft_strcmp(args[1], "-n"))
	{
		n_flag = 0;
		i++;
	}
	while (args[i])
	{
		ft_putstr_fd(args[i], fd_out);
		if (args[i + 1])
			ft_putstr_fd(" ", fd_out);
		i++;
	}
	if (n_flag)
		ft_putendl_fd("", fd_out);
	return (0);
}

static int	handle_pwd_errors(char *old_pwd, int error_code)
{
	free(old_pwd);
	ft_putendl_fd(" error retrieving current directory", STDERR_FILENO);
	return (error_code);
}

static int	update_directory(t_ast *data, char *path, char *old_pwd)
{
	char	*new_pwd;

	if (chdir(path) != 0)
	{
		ft_putstr_fd("minishell: cd: ", STDERR_FILENO);
		ft_putendl_fd(strerror(errno), STDERR_FILENO);
		free(old_pwd);
		return (1);
	}
	new_pwd = getcwd(NULL, 0);
	if (!new_pwd)
		return (handle_pwd_errors(old_pwd, 1));
	update_env_var(data, "OLDPWD", old_pwd);
	update_env_var(data, "PWD", new_pwd);
	free(old_pwd);
	free(new_pwd);
	return (0);
}

int	execute_cd(t_ast *data, char *path)
{
	char	*old_pwd;
	t_env	*home;

	old_pwd = getcwd(NULL, 0);
	if (!old_pwd)
		return (handle_pwd_errors(NULL, 1));
	if (!path)
	{
		home = get_env_node(data->env_list, "HOME");
		if (!home || !home->value)
		{
			ft_putendl_fd("minishell: cd: HOME not set", STDERR_FILENO);
			free(old_pwd);
			return (1);
		}
		path = home->value;
	}
	return (update_directory(data, path, old_pwd));
}

static int	handle_export_error(char *arg)
{
	ft_putstr_fd("minishell: export: `", STDERR_FILENO);
	ft_putstr_fd(arg, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}

static void	update_env_variable(t_env *env, char *name, char *eq)
{
	if (eq)
	{
		free(env->value);
		env->value = ft_strdup(eq + 1);
	}
	free(name);
}

int	create_new_env(t_ast *d, char *n, char *eq)
{
	t_env	*env;

	env = malloc(sizeof(t_env));
	if (!env)
		return (free(n), 1);
	env->key = n;
	if (eq)
		env->value = ft_strdup(eq + 1);
	else
		env->value = ft_strdup("");
	env->next = d->env_list;
	d->env_list = env;
	return (0);
}

static int	process_export_arg(t_ast *data, char *arg)
{
	char	*eq;
	char	*name;
	t_env	*env;

	eq = ft_strchr(arg, '=');
	if (eq)
		name = ft_substr(arg, 0, eq - arg);
	else
		name = ft_strdup(arg);
	if (!name || !is_valid_identifier(name))
		return (free(name), handle_export_error(arg));
	env = get_env_node(data->env_list, name);
	if (env)
		update_env_variable(env, name, eq);
	else if (create_new_env(data, name, eq))
		return (1);
	return (0);
}

int	execute_export(t_ast *data, t_ast *tree, int fd_out)
{
	int		i;
	int		status;

	(void)fd_out;
	i = 1;
	status = 0;
	while (tree->cmd->args[i])
	{
		if (process_export_arg(data, tree->cmd->args[i]))
			status = 1;
		i++;
	}
	return (status);
}

static int	handle_unset_error(char *name)
{
	ft_putstr_fd("minishell: unset: `", STDERR_FILENO);
	ft_putstr_fd(name, STDERR_FILENO);
	ft_putendl_fd("': not a valid identifier", STDERR_FILENO);
	return (1);
}

static void	remove_env_node(t_ast *data, t_env *prev, t_env *curr)
{
	if (prev)
		prev->next = curr->next;
	else
		data->env_list = curr->next;
	free(curr->key);
	free(curr->value);
	free(curr);
}

static int	process_unset_arg(t_ast *data, char *name)
{
	t_env	*prev;
	t_env	*curr;

	if (!is_valid_identifier(name))
		return (handle_unset_error(name));
	prev = NULL;
	curr = data->env_list;
	while (curr)
	{
		if (!ft_strcmp(curr->key, name))
		{
			remove_env_node(data, prev, curr);
			break ;
		}
		prev = curr;
		curr = curr->next;
	}
	return (0);
}

int	execute_unset(t_ast *data, t_ast *tree)
{
	int	i;

	i = 1;
	while (tree->cmd->args[i])
	{
		process_unset_arg(data, tree->cmd->args[i]);
		i++;
	}
	return (0);
}

int	execute_exit(t_ast *data, t_ast *tree)
{
	int	status;

	status = 0;
	if (tree->cmd->args[1])
		status = ft_atoi(tree->cmd->args[1]);
	free_data(data);
	exit (status);
	return (0);
}

### END OF FILE: ./src/execution/builtins/builtins_utils.c ###


### START OF FILE: ./src/execution/builtins/heredoc_utils.c ###

#include "minishell.h"


static	void	handle_sigint(int sig, siginfo_t *info, void *context)
{
	(void)sig;
	(void)info;
	(void)context;
	ioctl(STDIN_FILENO, TIOCSTI, "\n");
}

static void	configure_signals(t_signal *sig)
{
	sig->sa_new.sa_sigaction = handle_sigint;
	sigemptyset(&sig->sa_new.sa_mask);
	sig->sa_new.sa_flags = SA_SIGINFO;
	sigaction(SIGINT, &sig->sa_new, &sig->sa_old);
}

static int	process_input_loop(int fd, char *delimiter, t_signal *sig)
{
	char	*line;
	int		result;

	result = 0;
	while (!sig->sigint)
	{
		line = readline("> ");
		if (!line)
		{
			ft_putstr_fd("minishell: warning: here-doc delimited by EOF\n", 2);
			break ;
		}
		if (ft_strcmp(line, delimiter) == 0)
		{
			free(line);
			break ;
		}
		dprintf(fd, "%s\n", line);
		free(line);
	}
	if (sig->sigint)
		result = -1;
	return (result);
}

int	create_heredoc_temp_file(char *delimiter, t_ast *data)
{
	t_signal	sig;
	char		*tmpname;
	int			fd;

	tmpname = "/tmp/minishell_heredoc_XXXXXX";
	fd = mkstemp(tmpname);
	if (fd < 0)
		return (-1);
	configure_signals(&sig);
	data->heredoc_files = realloc(data->heredoc_files,
			sizeof(char *) * (data->heredoc_count + 1));
	data->heredoc_files[data->heredoc_count] = ft_strdup(tmpname);
	data->heredoc_count++;
	if (process_input_loop(fd, delimiter, &sig) == -1)
		return (-1);
	sigaction(SIGINT, &sig.sa_old, NULL);
	close(fd);
	return (open(tmpname, O_RDONLY));
}

### END OF FILE: ./src/execution/builtins/heredoc_utils.c ###


### START OF FILE: ./src/execution/builtins/redirection_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirection_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/05/20 12:42:00 by user              #+#    #+#             */
/*   Updated: 2025/04/08 12:47:30 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"
#include <fcntl.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

static void	print_error(char *filename, char *error_msg)
{
	ft_putstr_fd("minishell: ", STDERR_FILENO);
	ft_putstr_fd(filename, STDERR_FILENO);
	ft_putstr_fd(": ", STDERR_FILENO);
	ft_putendl_fd(error_msg, STDERR_FILENO);
}

static int	open_regular_input(char *last_red_inp)
{
	int	fd;

	fd = open(last_red_inp, O_RDONLY);
	if (fd < 0)
	{
		print_error(last_red_inp, strerror(errno));
		return (-1);
	}
	return (fd);
}
/* ==================== INPUT FILE HANDLING ==================== */

static void	handle_redir_in(t_ast *node, char **last_red_inp)
{
	if (node->type == AST_REDIR_IN)
		*last_red_inp = node->token->value;
}

static int	hh(t_ast *node, t_ast *data, char **delim, int *fd)
{
	if (node->type == AST_REDIR_HERDOC) 
	{
		*delim = node->token->value;
		*fd = create_heredoc_temp_file(*delim, data);
		if (*fd < 0)
			return (-1);
	}
	return (0);
}

int	get_input_file(t_ast *data, t_ast *tree)
{
	t_ast	*curr;
	char	*last_red_inp;
	char	*lhd;
	int		fd;

	curr = tree;
	last_red_inp = NULL;
	lhd = NULL;
	fd = STDIN_FILENO;
	while (curr)
	{
		handle_redir_in(curr, &last_red_inp);
		if (curr->type == AST_EOF && hh(curr, data, &lhd, &fd) == -1)
			return (-1);
		if (curr->left)
		{
			fd = get_input_file(data, curr->left);
			if (fd == -1)
				return (-1);
		}
		curr = curr->right;
	}
	if (!lhd && last_red_inp)
		fd = open_regular_input(last_red_inp);
	return (fd);
}


static void	find_last_output_redirection(t_ast *curr, char **file, int *type)
{
	while (curr)
	{
		if (curr->type == AST_REDIR_OUT || curr->type == AST_REDIR_APPEND)
		{
			*file = curr->token->value;
			*type = curr->type;
		}
		curr = curr->right;
	}
}

static int	open_output_file(char *filename, int redir_type)
{
	int	flags;
	int	fd;

	flags = O_WRONLY | O_CREAT;
	if (redir_type == AST_REDIR_OUT)
		flags |= O_TRUNC;
	else if (redir_type == AST_REDIR_APPEND)
		flags |= O_APPEND;
	fd = open(filename, flags, 0644);
	if (fd < 0)
		print_error(filename, strerror(errno));
	return (fd);
}

int	get_output_file(t_ast *tree)
{
	char	*last_file;
	int		redir_type;
	int		fd;

	last_file = NULL;
	redir_type = -1;
	fd = STDOUT_FILENO;
	find_last_output_redirection(tree->right, &last_file, &redir_type);
	if (last_file)
	{
		fd = open_output_file(last_file, redir_type);
		if (fd < 0)
			return (-1);
	}
	return (fd);
}

### END OF FILE: ./src/execution/builtins/redirection_utils.c ###


### START OF FILE: ./src/execution/execution/execute.c ###

#include "minishell.h"


int execute_group(t_ast *data, t_ast *tree)
{
    pid_t pid;
    int status;

    pid = fork();
    if (pid == 0)
    {
        int ret = execute_tree(data, tree->left);
        exit(ret);
    }
    else if (pid < 0)
    {
        ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
        return (data->exit_status = 1);
    }
    waitpid(pid, &status, 0);
    if (WIFEXITED(status))
        data->exit_status = WEXITSTATUS(status);
    else
        data->exit_status = 1;
    return data->exit_status;
}


int execute_sequence(t_ast *data, t_ast *tree)
{
    execute_tree(data, tree->left);
    return execute_tree(data, tree->right);
}

int execute_tree(t_ast *data,t_ast *tree)
{
    if (tree->type == AST_AND || tree->type == 	AST_OR)
    {
        if (tree->type == AST_AND)
            return execute_and(data, tree);
        else
            return execute_or(data, tree);
    }
    else if (tree->type == AST_PIPELINE)
    {
        return execute_pipe(data, tree);
    }
    else if (tree->type == AST_SUBSHELL)
    {
        return execute_group(data, tree);
    }
    else if (tree->type == AST_COMMAND)
    {
        return execute_word(data, tree);
    }
    return 0;
}

### END OF FILE: ./src/execution/execution/execute.c ###


### START OF FILE: ./src/execution/execution/execute_external.c ###

#include "minishell.h"
#include <errno.h>
#include <stdlib.h>
#include <sys/wait.h>
#include <unistd.h>

int	execute_command(t_ast *data, t_ast *tree, int fd_inp, int fd_out)
{
	pid_t	pid;
	int		status;
	char	*cmd_path;
	char	**envp;

	pid = fork();
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		if (fd_inp != STDIN_FILENO)
		{
			if (dup2(fd_inp, STDOUT_FILENO) == -1)
			{
				perror("minishell: dup2 input redirection");
				exit(1);
			}
			close(fd_inp);
		}
		if (fd_out != STDOUT_FILENO)
		{
			if (dup2(fd_out, STDOUT_FILENO) == -1)
			{
				perror("minishell: dup2 output redirection");
				exit(1);
			}
			close(fd_out);
		}
		cmd_path = find_executable_path(data, tree->cmd->args[0]);
		if (!cmd_path)
		{
			ft_putstr_fd("minishell: ", STDERR_FILENO);
			ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
			ft_putendl_fd(": command not found", STDERR_FILENO);
			exit(127);
		}
		envp = env(&(data->env_list));
		execve(cmd_path, tree->cmd->args, envp);
		perror("minishell: execve");
		free_2darray(envp);
		exit(1);
	}
	if (fd_inp != STDIN_FILENO)
		close(fd_inp);
	if (fd_out != STDOUT_FILENO)
		close(fd_out);
	waitpid(pid, &status, 0);
	for (int i = 0; i < data->heredoc_count; i++)
	{
		unlink(data->heredoc_files[i]);
		free(data->heredoc_files[i]);
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
	if (WIFEXITED(status))
		return (WEXITSTATUS(status));
	return (1);
}

### END OF FILE: ./src/execution/execution/execute_external.c ###


### START OF FILE: ./src/execution/execution/execute_pipe.c ###

#include "minishell.h"

int execute_pipe(t_ast *data, t_ast *tree)
{
	int fd[2];
	pid_t left_pid, right_pid;
	int left_status, right_status;

	if (pipe(fd) == -1)
	{
		perror("minishell: pipe");
		return (data->exit_status = 1);
	}
	left_pid = fork();
	if (left_pid == 0)
	{
		close(fd[0]);
		dup2(fd[1], STDOUT_FILENO);
		close(fd[1]);
		exit(execute_tree(data, tree->left));
	}
	else if (left_pid < 0)
	{
		perror("minishell: fork");
		close(fd[0]);
		close(fd[1]);
		return (data->exit_status = 1);
	}
	right_pid = fork();
	if (right_pid == 0)
	{
		close(fd[1]);
		dup2(fd[0], STDIN_FILENO);
		close(fd[0]);
		exit(execute_tree(data, tree->right));
	}
	else if (right_pid < 0)
	{
		perror("minishell: fork");
		close(fd[0]);
		close(fd[1]);
		kill(left_pid, SIGTERM); 
		return (data->exit_status = 1);
	}
	close(fd[0]);
	close(fd[1]);
	waitpid(left_pid, &left_status, 0);
	waitpid(right_pid, &right_status, 0);
	if (WIFEXITED(right_status))
		data->exit_status = WEXITSTATUS(right_status);
	else
		data->exit_status = 1;
	return (data->exit_status);
}
### END OF FILE: ./src/execution/execution/execute_pipe.c ###


### START OF FILE: ./src/execution/execution/execute_word.c ###

#include "minishell.h"

int	execute_word(t_ast *data, t_ast *tree)
{
	int		fd_in;
	int		fd_out;
	char	**expanded_args;
	char	**original_args;
	pid_t	pid;
	char	*cmd_path;
	char	**envp;
	int     status;

	fd_in = get_input_file(data, tree);
	fd_out = get_output_file(tree);
	if (fd_in < 0 || fd_out < 0)
	{
		if (fd_in > 0 && fd_in != STDIN_FILENO)
			close(fd_in);
		if (fd_out > 0 && fd_out != STDOUT_FILENO)
			close(fd_out);
		data->exit_status = 1;
		return (1);
	}
	expanded_args = expand_wildcards_in_args(tree->cmd->args);
	if (!expanded_args)
	{
		close(fd_in);
		close(fd_out);
		return (data->exit_status = 1);
	}
	original_args = tree->cmd->args;
	tree->cmd->args = expanded_args;
	if (handle_builtin(data, tree, fd_out))
	{
		tree->cmd->args = original_args;
		free_2darray(expanded_args);
		if (fd_in != STDIN_FILENO)
			close(fd_in);
		if (fd_out != STDOUT_FILENO)
			close(fd_out);
		return (data->exit_status);
	}
	pid = fork();
	if (pid < 0)
	{
		ft_putendl_fd("minishell: fork failed", STDERR_FILENO);
		data->exit_status = 1;
	}
	if (pid == 0)
	{
		signal(SIGINT, SIG_DFL);
		signal(SIGQUIT, SIG_DFL);
		if (fd_in != STDIN_FILENO)
		{
			dup2(fd_in, STDIN_FILENO);
			close(fd_in);
		}
		if (fd_out != STDOUT_FILENO)
		{
			dup2(fd_out, STDOUT_FILENO);
			close(fd_out);
		}
		cmd_path = find_executable_path(data, tree->cmd->args[0]);
		if (!cmd_path)
		{
			ft_putstr_fd("minishell: ", STDERR_FILENO);
			ft_putstr_fd(tree->cmd->args[0], STDERR_FILENO);
			ft_putendl_fd(": command not found", STDERR_FILENO);
			exit(127);
		}
		envp = env(&(data->env_list));
		execve(cmd_path, tree->cmd->args, envp);
		ft_putstr_fd("minishell: ", STDERR_FILENO);
		ft_putendl_fd(strerror(errno), STDERR_FILENO);
		free(cmd_path);
		free_2darray(envp);
		exit(126);
	}
	else
	{
		g_child_pid = pid;
		waitpid(pid, &status, 0);
		g_child_pid = 0; 
		if (WIFEXITED(status))
			data->exit_status = WEXITSTATUS(status);
		else if (WIFSIGNALED(status))
			data->exit_status = 128 + WTERMSIG(status);
		else
			data->exit_status = 1;
	}
	tree->cmd->args = original_args;
	free_2darray(expanded_args);
	if (fd_in != STDIN_FILENO)
		close(fd_in);
	if (fd_out != STDOUT_FILENO)
		close(fd_out);
	return (data->exit_status);
}

### END OF FILE: ./src/execution/execution/execute_word.c ###


### START OF FILE: ./src/execution/execution/exec_handling.c ###

#include "../../include/minishell.h"

int	execute_and(t_ast *data, t_ast *tree)
{
	int	left_status;
	int	right_status;

	left_status = execute_tree(data, tree->left);
	if (left_status != 0)
	{
		data->exit_status = left_status;
		return (left_status);
	}
	right_status = execute_tree(data, tree->right);
	data->exit_status = right_status;
	return (right_status);
}

int	execute_or(t_ast *data, t_ast *tree)
{
	int	left_status;
	int	right_status;

	left_status = execute_tree(data, tree->left);
	if (left_status == 0)
	{
		data->exit_status = 0;
		return (0);
	}
	right_status = execute_tree(data, tree->right);
	data->exit_status = right_status;
	return (right_status);
}

### END OF FILE: ./src/execution/execution/exec_handling.c ###


### START OF FILE: ./src/execution/execution/expand_wildcard.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   expand_wildcard.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: marvin <marvin@student.42.fr>              +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/24 19:36:52 by vszpiech          #+#    #+#             */
/*   Updated: 2025/04/07 17:58:30 by marvin           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"
#include <dirent.h>

int	match_pattern(const char *pattern, const char *text)
{
	if (!pattern || !text)
		return (0);
	while (*pattern)
	{
		if (*pattern == '*')
		{
			pattern++;
			while (*text && !match_pattern(pattern, text))
				text++;
		}
		else if (*pattern == '?' || *pattern == *text)
		{
			pattern++;
			text++;
		}
		else
		{
			return (0);
		}
	}
	return (*text == '\0');
}

static int	has_wildcard(const char *str)
{
	return (ft_strchr(str, '*') != NULL);
}

static void	split_pattern(const char *pattern, char **dir_part,
		char **file_part)
{
	char	*last_slash;

	last_slash = ft_strrchr(pattern, '/');
	if (last_slash)
	{
		*dir_part = ft_strndup(pattern, last_slash - pattern + 1);
		*file_part = ft_strdup(last_slash + 1);
	}
	else
	{
		*dir_part = ft_strdup(".");
		*file_part = ft_strdup(pattern);
	}
}

static char	*build_full_path(char *dir, const char *file)
{
	if (ft_strcmp(dir, ".") == 0)
		return (ft_strdup(file));
	if (dir[ft_strlen(dir) - 1] == '/')
		return (ft_strjoin(dir, file));
	return (ft_strjoin3(dir, "/", file));
}

static void	sort_matches(char **matches, int count)
{
	char	*temp;

	int i, j;
	for (i = 0; i < count - 1; i++)
	{
		for (j = i + 1; j < count; j++)
		{
			if (ft_strcmp(matches[i], matches[j]) > 0)
			{
				temp = matches[i];
				matches[i] = matches[j];
				matches[j] = temp;
			}
		}
	}
}

static int	is_hidden_file(char *pattern, const char *filename)
{
	return (filename[0] == '.' && (pattern[0] != '.' || ft_strcmp(pattern,
				".") == 0));
}

char	**expand_wildcard(char *pattern)
{
	char			*dir_part;
	char			*file_part;
	DIR				*dir;
	struct dirent	*entry;
	char			**result;
	char			**matches;
	int				count;
	char			*full_path;

	split_pattern(pattern, &dir_part, &file_part);
	if (!has_wildcard(file_part) && !has_wildcard(dir_part))
	{
		free(dir_part);
		free(file_part);
		result = ft_calloc(2, sizeof(char *));
		result[0] = ft_strdup(pattern);
		return (result);
	}
	dir = opendir(dir_part);
	if (!dir)
	{
		free(dir_part);
		free(file_part);
		return (NULL);
	}
	matches = NULL;
	count = 0;
	while ((entry = readdir(dir)) != NULL)
	{
		if (is_hidden_file(file_part, entry->d_name))
			continue ;
		if (match_pattern(file_part, entry->d_name))
		{
			full_path = build_full_path(dir_part, entry->d_name);
			matches = realloc(matches, (count + 1) * sizeof(char *));
			matches[count++] = full_path;
		}
	}
	closedir(dir);
	if (count == 0)
	{
		free(matches);
		matches = NULL;
	}
	else
	{
		sort_matches(matches, count);
		matches = realloc(matches, (count + 1) * sizeof(char *));
		matches[count] = NULL;
	}
	free(dir_part);
	free(file_part);
	return (matches);
}

char	**expand_wildcards_in_args(char **args)
{
	char **new_args = NULL;
	int new_count = 0;

	for (int i = 0; args[i]; i++)
	{
		char **matches = expand_wildcard(args[i]);
		if (!matches)
		{
			new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
			new_args[new_count++] = ft_strdup(args[i]);
		}
		else
		{
			for (int j = 0; matches[j]; j++)
			{
				new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
				new_args[new_count++] = ft_strdup(matches[j]);
			}
			for (int j = 0; matches[j]; j++)
				free(matches[j]);
			free(matches);
		}
	}
	new_args = realloc(new_args, (new_count + 1) * sizeof(char *));
	new_args[new_count] = NULL;
	return (new_args);
}
### END OF FILE: ./src/execution/execution/expand_wildcard.c ###


### START OF FILE: ./src/execution/signals/signals.c ###


#include "../../../include/minishell.h"

static void sigint_handler(int sig) {
	(void)sig;
	if (g_child_pid == 0) {
		ft_putstr_fd("\n", STDOUT_FILENO);
		rl_on_new_line();
		rl_replace_line("", 0);
		rl_redisplay();
	} else {
		ft_putstr_fd("\n", STDOUT_FILENO);
		kill(g_child_pid, SIGINT);
	}
}
void	handle_signal(void)
{
	struct sigaction	sa_int;
	struct sigaction	sa_quit;
	sa_int.sa_handler = sigint_handler;
	sigemptyset(&sa_int.sa_mask);
	sa_int.sa_flags = SA_RESTART;
	sigaction(SIGINT, &sa_int, NULL);
	sa_quit.sa_handler = SIG_IGN;
	sigemptyset(&sa_quit.sa_mask);
	sa_quit.sa_flags = 0;
	sigaction(SIGQUIT, &sa_quit, NULL);
}
void	handle_sigint(int signo)
{
	if (signo == SIGINT)
	{
		if (isatty(STDIN_FILENO))
		{
			int i = write(1, "\n", 1);
			(void) i;
			if (g_child_pid == 42)
				g_child_pid = 44;
			if (g_child_pid != 0 && g_child_pid != 44)
			{
				kill(g_child_pid, SIGINT);
				g_child_pid++;
			}
			else
			{
				rl_on_new_line();
				rl_redisplay();
			}
		}
		else
			exit(EXIT_SUCCESS);
	}
}

void	handle_sigtstp_sigquit(int signo)
{
	if (signo == SIGTSTP || signo == SIGQUIT)
	{
		if (isatty(STDIN_FILENO))
		{
			if (g_child_pid == 0)
				rl_redisplay();
			else
			{
				kill(g_child_pid, signo);
				g_child_pid += 2;
			}
		}
	}
}

void	handle_c(int signo)
{
	handle_sigint(signo);
	handle_sigtstp_sigquit(signo);
}

int	handle_d(t_ast *data, char *line)
{
	(void)data;
	if (line == NULL)
	{
		rl_on_new_line();
		rl_redisplay();
	}
	if (ft_strlen(line) == 0)
	{
		ft_strdel(&line);
		return (1);
	}
	return (0);
}

### END OF FILE: ./src/execution/signals/signals.c ###


### START OF FILE: ./src/execution/utils/asterisk_utils.c ###

#include "minishell.h"


int is_only_asterisks(char *str)
{
    int i = 0;
    if (!str)
        return 0;
    while (str[i])
    {
        if (str[i] != '*')
            return 0;
        i++;
    }
    return 1;
}

### END OF FILE: ./src/execution/utils/asterisk_utils.c ###


### START OF FILE: ./src/execution/utils/env_utils.c ###

#include "../../include/minishell.h"
#include <stdlib.h>
#include <unistd.h>

char *ft_strjoin3(const char *s1, const char *s2, const char *s3)
{
    char *tmp = ft_strjoin(s1, s2);
    char *res = ft_strjoin(tmp, s3);
    free(tmp);
    return res;
}


void print_env_list(t_env *env_list, int fd_out)
{
    while (env_list)
    {
        ft_putstr_fd(env_list->key, fd_out);      
        ft_putstr_fd("=", fd_out);
        ft_putendl_fd(env_list->value ? env_list->value : "", fd_out);
        env_list = env_list->next;
    }
}

char **env(t_env **lst)
{
    t_env *tmp = *lst;
    int count = 0;
    
    while (tmp) {
        count++;
        tmp = tmp->next;
    }

    char **envp = malloc((count + 1) * sizeof(char *));
    tmp = *lst;
    int i = 0;
    while (tmp) {
        envp[i++] = ft_strjoin3(tmp->key, "=", tmp->value);
        tmp = tmp->next;
    }
    envp[i] = NULL;
    return envp;
}

void incr_shell_lvl(t_ast *data)
{
    char *shlvl_str = get_env_value(data->env_list, "SHLVL");
    int shlvl = 0;
    
    if (shlvl_str)
        shlvl = ft_atoi(shlvl_str);
    shlvl++;

    t_env *tmp = data->env_list;
    while (tmp)
    {
        if (!ft_strcmp(tmp->key, "SHLVL"))
        {
            free(tmp->value);
            tmp->value = ft_itoa(shlvl);
            return;
        }
        tmp = tmp->next;
    }
    t_env *new_env = malloc(sizeof(t_env));
    if (new_env)
    {
        new_env->key = ft_strdup("SHLVL");
        new_env->value = ft_itoa(shlvl);
        new_env->next = data->env_list;
        data->env_list = new_env;
    }
}
void set_env_var(t_ast *data, char *var_name, const char *var_value)
{
    t_env *env = data->env_list;
    while (env)
    {
        if (!ft_strcmp(env->key, var_name))
        {
            free(env->value);
            env->value = ft_strdup(var_value);
            return;
        }
        env = env->next;
    }
    t_env *new_env = malloc(sizeof(t_env));
    if (!new_env)
        return;
    new_env->key = ft_strdup(var_name);
    new_env->value = ft_strdup(var_value);
    new_env->next = data->env_list;
    data->env_list = new_env;
}

void	free_paths(char **paths, char **original_paths)
{
	paths = original_paths;
	while (*paths)
	{
		ft_strdel(paths);
		paths++;
	}
	free(original_paths);
}
char *duplicate_cmd_and_free_paths(char *cmd, char **paths)
{
    char *result = ft_strdup(cmd);
    free_paths(paths, paths);
    return result;
}

t_env *find_envir_variable(t_ast *data, char *var_name, int len)
{
    t_env *current;

    current = data->env_list;
    while (current)
    {
        if (current->key && ft_strncmp(current->key, var_name, len) == 0)
            return (current);
        current = current->next;
    }
    return (NULL);
}

char *find_executable_path(t_ast *data, char *cmd)
{
    if (ft_strchr(cmd, '/')) {
        if (access(cmd, X_OK) == 0)
            return ft_strdup(cmd);
        return NULL;
    }

    t_env *path_env = find_envir_variable(data, "PATH", 4);
    if (!path_env || !path_env->value)
        return NULL;

    char **paths = ft_split(path_env->value, ':');
    char **original_paths = paths;

    while (*paths)
    {
        char *full_path = ft_strjoin3(*paths, "/", cmd);
        if (access(full_path, X_OK) == 0)
        {
            char **temp = original_paths;
            while (*temp)
            {
                if (temp != paths)
                    free(*temp);
                temp++;
            }
            free(original_paths);
            return full_path;
        }
        free(full_path);
        paths++;
    }

    free_paths(original_paths, original_paths);
    return NULL;
}
### END OF FILE: ./src/execution/utils/env_utils.c ###


### START OF FILE: ./src/execution/utils/free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 12:54:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 12:54:56 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "minishell.h"

void	free_token(t_token *token)
{
	t_token	*tmp;

	while (token)
	{
		tmp = token->next;
		free(token->value);
		free(token);
		token = tmp;
	}
}

void	free_heredoc_files(t_ast *data)
{
	int	i;

	if (!data->heredoc_files)
		return ;
	i = 0;
	while (i < data->heredoc_count)
	{
		if (data->heredoc_files[i])
		{
			unlink(data->heredoc_files[i]);
			free(data->heredoc_files[i]);
		}
		i++;
	}
	free(data->heredoc_files);
	data->heredoc_files = NULL;
	data->heredoc_count = 0;
}
void	free_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->env_list)
		free_env_list(data->env_list);
	if (data->heredoc_files)
		free_heredoc_files(data);
	if (data)
		free_ast(data);
}

void	free_temp_data(t_ast *data)
{
	if (!data)
		return ;
	if (data->token)
		free_token(data->token);
	free(data);
}



void	ft_strdel(char **as)
{
	if (as && *as)
	{
		free(*as);
		*as = NULL;
	}
}
### END OF FILE: ./src/execution/utils/free.c ###


### START OF FILE: ./src/execution/utils/free2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free2.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/25 13:04:56 by vszpiech          #+#    #+#             */
/*   Updated: 2025/03/25 13:04:56 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

void	free_2darray(char **array)
{
	int	i;

	i = -1;
	if (!array)
		return ;
	while (array[++i])
		ft_strdel(&array[i]);
	free(array);
}

### END OF FILE: ./src/execution/utils/free2.c ###


### START OF FILE: ./src/execution/utils/utils4.c ###


#include "../../include/minishell.h"


void *ft_realloc(void *ptr, size_t old_size, size_t new_size) {
    void *new_ptr = malloc(new_size);
    if (!new_ptr)
        return NULL;

    if (ptr) {
        size_t copy_size = old_size < new_size ? old_size : new_size;
        memcpy(new_ptr, ptr, copy_size);
        free(ptr);
    }

    return new_ptr;
}

char	*ft_strndup(const char *s, size_t n)
{
	char	*dup;
	size_t	len;
	size_t	i;

	len = 0;
	while (len < n && s[len])
		len++;
	dup = (char *)malloc(sizeof(char) * (len + 1));
	if (!dup)
		return (NULL);
	i = 0;
	while (i < len)
	{
		dup[i] = s[i];
		i++;
	}
	dup[len] = '\0';
	return (dup);
}

### END OF FILE: ./src/execution/utils/utils4.c ###


### START OF FILE: ./src/main.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/* +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 01:11:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 00:11:49 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/minishell.h"

pid_t g_child_pid = 0;  // Single definition

void	handle_input(char *input, t_env *env_list, int argc, char **argv)
{
	t_token			*tokens;
	char			*expandable;
	t_args			arg;
	t_ast			*ast;
	t_env			*env_copy;

	arg.exit_status = 0;
	if (*input)
	{
		add_history(input);
		arg.argc = argc - 1;
		arg.argv = argv;
		env_copy = deep_copy_env_list(env_list);
		if (!env_copy)
			return ;
		expandable = parse_env(input, env_copy, &arg);
		if (!expandable)
		{
			free_env_list(env_copy);
			return ;
		}
		tokens = tokenize(expandable);
		if (!tokens)
		{
			free_tokens(tokens);
			return ;
		}
		if (!validation(tokens))
			return ;
		free(expandable);
		free_env_list(env_copy);
		ast = parse_tokens(tokens);
		free_tokens(tokens);
		if (!ast)
		{
			free_ast(ast);
			return ;
		}
		else if (ast)
			ast->env_list = env_list;
        execute_tree(ast, ast);
        free_ast(ast);
	}
}

char	*generate_prompt(void)
{
	char		cwd[PATH_MAX];
	char		*str;

	if (getcwd(cwd, sizeof(cwd)) != NULL)
	{
		str = ft_strjoin("minihell:", cwd);
		return (ft_strjoin(str, "$ "));
	}
	return (ft_strdup("minishell$ "));
}

int main(int argc, char **argv, char **envp)
{
	t_env		*env_list;
	char		*input;
	char		*prompt;

	env_list = init_env_list(envp);
	handle_signal();
	while (1)
	{
		prompt = generate_prompt();
		input = readline(prompt);
		free(prompt);
		if (!input)
		{
			printf("exit\n");
			exit(1);
		}
		handle_input(input, env_list, argc, argv);
		free(input);
	}
	free_env_list(env_list);
	return (0);
}

### END OF FILE: ./src/main.c ###


### START OF FILE: ./src/parse/env/convert_env.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   convert_env.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 20:29:25 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:11:32 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

t_env	*create_copy_env_node(t_env *original)
{
	t_env	*env_node;

	env_node = malloc(sizeof(t_env));
	if (!env_node)
		return (NULL);
	env_node->key = NULL;
	env_node->next = NULL;
	env_node->value = NULL;
	if (original->key)
	{
		env_node->key = ft_strdup(original->key);
		if (!env_node->key)
		{
			free(env_node);
			return (NULL);
		}
	}
	if (original->value)
	{
		env_node->value = ft_strdup(original->value);
		if (!env_node->value)
			return (free(env_node->key), free(env_node), NULL);
	}
	return (env_node);
}

t_env	*deep_copy_env_list(t_env *env_list)
{
	t_env	*new_head;
	t_env	*new_curr;
	t_env	*new_node;
	t_env	*original;

	if (!env_list)
		return (NULL);
	new_head = NULL;
	new_curr = NULL;
	original = env_list;
	while (original)
	{
		new_node = create_copy_env_node(original);
		if (!new_node)
		{
			free_env_list(new_head);
			return (NULL);
		}
		if (!new_head)
			new_head = new_node;
		else
			new_curr->next = new_node;
		new_curr = new_node;
		original = original->next;
	}
	return (new_head);
}

char	*get_env_value(t_env *env_list, char *name)
{
	t_env		*current;

	current = env_list;
	while (current)
	{
		if (!ft_strcmp(current->key, name))
			return (current->value);
		current = current->next;
	}
	return (NULL);
}

t_env	*create_env_node(char *input)
{
	t_env		*new_node;
	char		*equal_sign;

	new_node = (t_env *)malloc(sizeof(t_env));
	if (!new_node)
		return (NULL);
	equal_sign = ft_strchr(input, '=');
	if (!equal_sign)
	{
		free(new_node);
		return (NULL);
	}
	new_node->key = ft_substr(input, 0, equal_sign - input);
	new_node->value = ft_strdup(equal_sign + 1);
	new_node->next = NULL;
	return (new_node);
}

t_env	*init_env_list(char **envp)
{
	t_env		*head;
	t_env		*current;
	int			i;
	t_env		*new_node;

	head = NULL;
	i = 0;
	while (envp[i])
	{
		new_node = create_env_node(envp[i]);
		if (!new_node)
		{
			free_env_list(new_node);
			return (NULL);
		}
		if (!head)
			head = new_node;
		else
			current->next = new_node;
		current = new_node;
		i++;
	}
	return (head);
}

### END OF FILE: ./src/parse/env/convert_env.c ###


### START OF FILE: ./src/parse/env/env_parsing.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_parsing.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 19:07:30 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:10:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static char	*handle_special_utils(char *input, char *str, int *i, t_args *arg)
{
	if (input[*i] == '$')
	{
		if (input[*i + 1] == '?')
		{
			str = ft_itoa(arg->exit_status);
			*i += 2;
		}
		else if (input[*i + 1] == '@')
		{
			str = join_arguments(arg);
			*i += 2;
		}
		else if (input[*i + 1] == '*')
		{
			str = join_arguments(arg);
			*i += 2;
		}
		else if (input[*i + 1] == '0')
		{
			str = ft_strdup(arg->argv[0]);
			i += 2;
		}
	}
	return (str);
}

static char	*handle_special_var(char *input, int *i, t_args *arg)
{
	char	*str;

	str = NULL;
	if (input[*i] == '$')
		str = handle_special_utils(input, str, i, arg);
	return (str);
}

static char	*get_env_name(char *input, int *i, t_args *arg)
{
	int		start;
	int		len;
	char	*name;
	char	*special;

	start = *i;
	special = handle_special_var(input, i, arg);
	if (special)
		return (special);
	len = 0;
	while (input[start + len] && (ft_isalnum(input[start + len])
			|| input[start + len] == '_'))
		len++;
	if (len == 0)
		return (NULL);
	name = ft_substr(input, start, len);
	*i = start + len;
	return (name);
}

static char	*handle_shlvl(t_env *env_list)
{
	char		*value;
	int			level;
	char		*new_value;

	value = get_env_value(env_list, "SHLVL");
	if (!value)
		level = 1;
	else
		level = ft_atoi(value) + 1;
	new_value = ft_itoa(level);
	return (new_value);
}

char	*env_expansion(char *input, int *i,
	t_env *env_list, t_args *arg)
{
	char		*value;
	char		*name;

	(*i)++;
	value = NULL;
	name = get_env_name(input, i, arg);
	if (!name)
		return (ft_strdup(""));
	if (!ft_strcmp(name, "SHLVL"))
	{
		value = handle_shlvl(env_list);
		free(name);
		return (value);
	}
	value = get_env_value(env_list, name);
	if (!value)
		value = ft_strdup("");
	else
		value = ft_strdup(value);
	free(name);
	return (value);
}

### END OF FILE: ./src/parse/env/env_parsing.c ###


### START OF FILE: ./src/parse/env/env_parsing_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   env_parsing_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/16 00:37:42 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 18:11:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

char	*join_arguments(t_args *arg)
{
	int			i;
	char		*result;

	result = ft_strdup("");
	i = 0;
	while (i < arg->argc)
	{
		result = ft_strjoin(result, arg->argv[i]);
		if (i < arg->argc - 1)
			result = ft_strjoin(result, " ");
		i++;
	}
	return (result);
}

static int	quotes(char	*input, int i, t_args *parse)
{
	if (input[i] == '"')
	{
		if (!parse->single_quotes)
		{
			parse->double_quotes = !parse->double_quotes;
			if (parse->double_quotes)
				parse->last_quotes = '"';
			else if (parse->last_quotes == '"')
				parse->last_quotes = 0;
		}
		return (1);
	}
	if (input[i] == '\'')
	{
		if (!parse->double_quotes)
		{
			parse->single_quotes = !parse->single_quotes;
			if (parse->single_quotes)
				parse->last_quotes = '\'';
			else if (parse->last_quotes)
				parse->last_quotes = 0;
		}
		return (1);
	}
	return (0);
}

static char	*handle_env_part(t_args *parse, int *i, t_env *env_list)
{
	char		*temp;

	if (parse->single_quotes || parse->last_quotes == '\'')
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free(temp);
		return (parse->result);
	}
	if (*i > parse->start)
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free (temp);
	}
	temp = env_expansion(parse->input, i, env_list, parse);
	parse->result = ft_strjoin(parse->result, temp);
	free(temp);
	return (parse->result);
}

static void	handle_remaining(t_args *parse, int *i)
{
	char		*temp;

	if (*i > parse->start)
	{
		temp = ft_substr(parse->input, parse->start, *i - parse->start);
		parse->result = ft_strjoin(parse->result, temp);
		free(temp);
	}
}

char	*parse_env(char *input, t_env *env_list, t_args *arg)
{
	t_args		parse;
	int			i;

	i = 0;
	parse = (t_args){arg->argc, arg->argv, 0, input, 0, ft_strdup(""), 0, 0, 0};
	while (input[i])
	{
		if (quotes(input, i, &parse))
		{
			i++;
			continue ;
		}
		if (input[i] == '$' && input[i + 1] && input[i + 1] != ' '
			&& input[i + 1] != '"' && input[i + 1] != '\'')
		{
			parse.result = handle_env_part(&parse, &i, env_list);
			parse.start = i;
		}
		else
			i++;
		if (i > ft_strlen(input))
			i = ft_strlen(input);
	}
	handle_remaining(&parse, &i);
	return (parse.result);
}

### END OF FILE: ./src/parse/env/env_parsing_utils.c ###


### START OF FILE: ./src/parse/nodes/nodes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   nodes.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 19:50:51 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 00:19:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	append_node(t_token **head, t_token *current_token)
{
	t_token		*temp;

	if (!head || !current_token)
		return ;
	if (*head == NULL)
	{
		*head = current_token;
		return ;
	}
	else
	{
		temp = *head;
		while (temp->next)
			temp = temp->next;
		temp->next = current_token;
	}
}

t_token	*create_node(char *str, t_token_type type)
{
	t_token		*node;

	node = malloc(sizeof(t_token));
	if (!node)
		return (NULL);
	node->value = ft_strdup(str);
	if (!node->value)
	{
		free(node);
		return (NULL);
	}
	node->type = type;
	node->expandable = 0;
	node->next = NULL;
	return (node);
}

### END OF FILE: ./src/parse/nodes/nodes.c ###


### START OF FILE: ./src/parse/stack/stack.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   stack.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/22 01:07:35 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/04 16:45:17 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	initialize_stack(t_token *stack)
{
	if (stack)
		stack->top = NULL;
}

bool	is_empty(t_token *stack)
{
	return (!stack || !stack->top);
}

char	pop(t_token *stack)
{
	char		data;
	t_stack		*temp;

	if (!stack || !stack->top)
		return ('\0');
	temp = stack->top;
	data = temp->name;
	stack->top = temp->next;
	free(temp);
	return (data);
}

void	free_stack(t_token *stack)
{
	t_stack		*current;
	t_stack		*next;

	if (!stack || !stack->top)
		return ;
	current = stack->top;
	while (current)
	{
		next = current->next;
		free(current);
		current = next;
	}
	stack->top = NULL;
}

void	push(t_token *stack, char data)
{
	t_stack		*new_node;

	new_node = (t_stack *)malloc(sizeof(t_stack));
	if (!new_node)
		return ;
	new_node->name = data;
	new_node->next = stack->top;
	stack->top = new_node;
}

### END OF FILE: ./src/parse/stack/stack.c ###


### START OF FILE: ./src/parse/tokenize/tokenize.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 15:33:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/07 15:24:26 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	handle_operator(t_token **token, char *input, int *i)
{
	int		status;

	if (input[*i] == '(' || input[*i] == ')')
		return (return_parenthesis(token, input[*i]));
	status = handle_double_operator(token, input, i);
	if (status != 0)
		return (status);
	return (handle_single_operator(token, input[*i]));
}

int	tokenize_utils(t_token **token, char *input, int *i)
{
	int		status;

	status = 0;
	if (input[*i] == '\'' || input[*i] == '"')
		status = handle_quotes(token, input, i);
	else if (is_operator(input[*i]))
	{
		status = handle_operator(token, input, i);
		if (status == 0)
			status = handle_word(token, input, i);
	}
	else
		status = handle_word(token, input, i);
	return (status);
}

t_token	*finalize_token(t_token *token)
{
	t_token	*eof_token;

	eof_token = create_node("", TOKEN_EOF);
	if (!eof_token)
		return (free_tokens(token));
	append_node(&token, eof_token);
	return (token);
}

t_token	*tokenize(char *input)
{
	t_token	*token;
	int		i;
	int		status;

	if (!input)
		return (NULL);
	i = 0;
	token = NULL;
	status = -1;
	if (input == NULL)
		return (NULL);
	while (input[i])
	{
		if (ft_isspace(input[i]))
		{
			status = handle_whitespace(&token, input, &i);
			continue ;
		}
		status = tokenize_utils(&token, input, &i);
		if (status == -1)
			return (free_tokens(token));
		i++;
	}
	return (finalize_token(token));
}

### END OF FILE: ./src/parse/tokenize/tokenize.c ###


### START OF FILE: ./src/parse/tokenize/tokenize_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 23:25:01 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/14 20:22:50 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	handle_single_operator(t_token **token, char c)
{
	t_token		*current;

	if (c == '|')
		current = create_node("|", TOKEN_PIPE);
	else if (c == ' ')
		current = create_node(" ", TOKEN_WHITESPACE);
	else if (c == '<')
		current = create_node("<", TOKEN_REDIRECT_IN);
	else if (c == '>')
		current = create_node(">", TOKEN_REDIRECT_OUT);
	else if (c == '*')
		current = create_node("*", TOKEN_WILDCARD);
	else
		return (0);
	if (!current)
		return (-1);
	//printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

static int	handle_double_operator_utils(t_token **current, char *input,
	int *i, char next_char)
{
	if (input[*i] == '<' && next_char == '<')
		*current = create_node("<<", TOKEN_HEREDOC);
	else if (input[*i] == '>' && next_char == '>')
		*current = create_node(">>", TOKEN_APPEND);
	else if (input[*i] == '&' && next_char == '&')
		*current = create_node("&&", TOKEN_AND);
	else if (input[*i] == '|' && next_char == '|')
		*current = create_node("||", TOKEN_OR);
	else
		return (0);
	if (!*current)
		return (-1);
	(*i)++;
	return (1);
}

int	handle_double_operator(t_token **head, char *input, int *i)
{
	t_token		*current;
	char		next_char;
	int			result;

	if (input[*i + 1] == '\0')
		return (0);
	next_char = input[*i + 1];
	if ((input[*i] == '&' && next_char == '&' && input[*i + 2] == '&')
		|| (input[*i] == '|' && next_char == '|' && input[*i + 2] == '|'))
	{
		report_error(ERR_SYNTAX, "invalid operator sequence");
		return (-1);
	}
	result = handle_double_operator_utils(&current, input, i, next_char);
	if (result == 1)
	{
		append_node(head, current);
		printf("%s\n", current->value);
	}
	return (result);
}

int	return_parenthesis(t_token **token, char c)
{
	t_token		*current;

	if (c == '(')
		current = create_node("(", TOKEN_PAREN_OPEN);
	else
		current = create_node(")", TOKEN_PAREN_CLOSE);
	if (!current)
		return (-1);
	//printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

### END OF FILE: ./src/parse/tokenize/tokenize_utils.c ###


### START OF FILE: ./src/parse/tokenize/tokenize_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tokenize_utils_2.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:12:02 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:17:53 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

static int	get_quote_content(char *input, int *i,
	char quote_type, char **content)
{
	int		start;
	int		len;

	start = *i + 1;
	*i = start;
	while (input[*i] && input[*i] != quote_type)
		(*i)++;
	if (!input[*i])
	{
		report_error(ERR_SYNTAX, "Unmatched parenthesis");
		return (-1);
	}
	len = *i - start;
	*content = ft_substr(input, start, len);
	if (!*content)
		return (-1);
	return (0);
}

int	handle_quotes(t_token **token, char *input, int *i)
{
	t_token	*current;
	char	*content;
	char	quote_type;

	quote_type = input[*i];
	if (get_quote_content(input, i, quote_type, &content) == -1)
		return (-1);
	current = create_node(content, TOKEN_WORD);
	if (!current)
	{
		free(content);
		return (-1);
	}
	if (quote_type == '"')
	{
		current->expandable = 1;
		current->double_quotes = 1;
	}
	else if (quote_type == '\'')
		current->single_quotes = 1;
	//printf("Token: %s\n", current->value);
	append_node(token, current);
	return (1);
}

int	handle_word(t_token **token, char *input, int *i)
{
	int		start;
	char	*word;
	t_token	*current;

	start = *i;
	while (input[*i] && !ft_isspace(input[*i]) && !is_operator(input[*i])
		&& input[*i] != '\'' && input[*i] != '"')
		(*i)++;
	word = ft_substr(input, start, *i - start);
	if (!word)
		return (-1);
	current = create_node(word, TOKEN_WORD);
	free(word);
	if (!current)
		return (-1);
	current->expandable = 1;
	//printf("Token: %s\n", current->value);
	append_node(token, current);
	(*i)--;
	return (1);
}

int	handle_whitespace(t_token **token, char *input, int *i)
{
	int		start;
	char	*whitespace;
	t_token	*curr;

	start = *i;
	while (input[*i] && ft_isspace(input[*i]))
		(*i)++;
	whitespace = ft_substr(input, start, *i - start);
	if (!whitespace)
		return (-1);
	curr = create_node(whitespace, TOKEN_WHITESPACE);
	free(whitespace);
	if (!curr)
		return (-1);
	//printf("TOKEN: Whitespace\n");
	append_node(token, curr);
	return (1);
}

### END OF FILE: ./src/parse/tokenize/tokenize_utils_2.c ###


### START OF FILE: ./src/parse/utils/errors_free.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   errors_free.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/14 13:21:04 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/18 23:49:57 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

void	free_env_list(t_env *env_list)
{
	t_env		*temp;

	while (env_list)
	{
		temp = env_list->next;
		free(env_list->key);
		free(env_list->value);
		free(env_list);
		env_list = temp;
	}
}

t_token	*free_tokens(t_token *token)
{
	t_token		*temp;

	while (token)
	{
		temp = token->next;
		free(token->value);
		free(token);
		token = temp;
	}
	return (NULL);
}

void	report_error(t_errors_code code, char *token)
{
	if (code == ERR_UNBALANCED_PAREN)
	{
		if (token)
			printf("minishell: syntax error near unexpected token `%s'\n",
				token);
		else
			printf("minishell: syntax error: unmatched parenthesis\n");
	}
	else if (code == ERR_SYNTAX)
	{
		if (token)
			printf("minishell: syntax error near unexpected `%s'\n", token);
		else
			printf("minishell: syntax error\n");
	}
	else if (code == ERR_UNEXPECTED_TOKEN)
		printf("minishell: syntax error near unexpected token `%s'\n", token);
	else if (code == ERR_MEMORY)
		printf("minishell: memory allocation failed\n");
	else if (code == ERR_PARSE)
		printf("minishell: parse error\n");
}

### END OF FILE: ./src/parse/utils/errors_free.c ###


### START OF FILE: ./src/parse/utils/utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   utils.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: vszpiech <vszpiech@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/13 17:21:58 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 19:30:38 by vszpiech         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

int	ft_isspace(int num)
{
	if (num == ' ' || num == '\n' || num == '\t'
		|| num == '\v' || num == '\f' || num == '\r')
		return (1);
	return (0);
}

int	is_operator(char c)
{
	if (c == '&' || c == '|' || c == '(' || c == ')'
		|| c == '>' || c == '<' || c == '*')
		return (1);
	return (0);
}

int	ft_strcmp(const char *s1, const char *s2)
{
	int			i;

	i = 0;
	while (s1[i] == s2[i] && s1[i] != '\0' && s2[i] != '\0')
		i++;
	return ((unsigned char)s1[i] - (unsigned char)s2[i]);
}

int	count_parenthesise_util(char *input)
{
	t_quotes	quotes;
	int			i;
	int			open_paren;
	int			close_paren;

	i = 0;
	open_paren = 0;
	close_paren = 0;
	quotes = (t_quotes){false, false};
	while (input[i] != '\0')
	{
		process_quotes(input[i], &quotes);
		if (!quotes.in_double_quotes && !quotes.in_single_quotes)
		{
			if (input[i] == '(')
				open_paren++;
			else if (input[i] == ')')
				close_paren++;
		}
		i++;
	}
	return (open_paren - close_paren);
}

int	count_parenthesis(t_token *tokens)
{
	int		count;
	int		total_count;

	if (!tokens)
		return (0);
	total_count = 0;
	while (tokens)
	{
		if (tokens->value)
		{
			count = count_parenthesise_util(tokens->value);
			total_count += count;
		}
		tokens = tokens->next;
	}
	return (total_count);
}

### END OF FILE: ./src/parse/utils/utils.c ###


### START OF FILE: ./src/parse/validation/commands/commands_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   commands_utils.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:08:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/06 15:02:11 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	is_valid_command_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/'
		|| c == '$' || c == '*' || c == '?' || c == '~');
}

bool	is_command_or_arg_char(char c)
{
	return (ft_isalnum(c) || c == '_' || c == '-' || c == '.' || c == '/'
		|| c == '$' || c == '~' || c == '"' || c == '\'');
}

bool	is_valid_command_start(char c)
{
	return (ft_isalnum(c) || c == '.' || c == '/' || c == '$' || c == '?'
		|| c == '#' || c == '_' || c == '*' || c == '-');
}

bool	is_valid_flag_char(char c)
{
	return (ft_isalnum(c) || c == '_');
}
### END OF FILE: ./src/parse/validation/commands/commands_utils.c ###


### START OF FILE: ./src/parse/validation/commands/validate_commands.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_commands.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 01:08:32 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/06 15:03:46 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_commands_position(char *input, int i)
{
	int			pos;

	pos = i - 1;
	while (pos >= 0 && ft_isspace(input[pos]))
		pos--;
	if (pos < 0 || input[pos] == '|' || input[pos] == ';' || input[pos] == '('
		|| pos == '\n')
		return (true);
	if (pos > 0 && ((input[pos] == '&' && input[pos - 1] == '&')
			|| (input[pos] == '|' && input[pos - 1] == '|')))
		return (true);
	return (false);
}

static bool	check_commands_in_str(char *str, bool *in_cmd, bool *is_cmd_pos,
	int i)
{
	if (!*in_cmd && is_valid_command_char(str[i])
		&& !ft_isspace(str[i]))
	{
		*is_cmd_pos = ft_is_commands_position(str, i);
		if (*is_cmd_pos && !is_valid_command_start(str[i]))
		{
			report_error(ERR_SYNTAX, "invalid command");
			return (false);
		}
		*in_cmd = true;
	}
	else if (*in_cmd && (ft_isspace(str[i]) || str[i] == '('
			|| str[i] == ')' || ft_is_operator(str[i])
			|| ft_is_redirection(str[i])))
		*in_cmd = false;
	return (true);
}

bool	check_commands(char *str)
{
	int			i;
	t_quotes	quote;
	bool		in_commands;
	bool		is_cmd_pos;

	i = 0;
	quote = (t_quotes){false, false};
	in_commands = false;
	while (str && str[i])
	{
		process_quotes(str[i], &quote);
		if (!quote.in_single_quotes && !quote.in_double_quotes)
		{
			if (!check_commands_in_str(str, &in_commands, &is_cmd_pos, i))
				return (false);
		}
		i++;
	}
	if (quote.in_double_quotes || quote.in_single_quotes)
	{
		report_error(ERR_SYNTAX, "Unmatched quotes");
		return (false);
	}
	return (true);
}

bool	validate_commands(t_token *tokenize)
{
	t_token			*current;

	if (!tokenize)
		return (true);
	current = tokenize;
	while (current)
	{
		if (!check_commands(current->value))
			return (false);
		current = current->next;
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/commands/validate_commands.c ###


### START OF FILE: ./src/parse/validation/operators/operators_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   operators_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:06:42 by ldurmish          #+#    #+#             */
/*   Updated: 2025/02/26 00:38:27 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_operator(char c)
{
	return (c == '|' || c == '&' || c == ';');
}

bool	ft_is_logical_op(char current, char next)
{
	return ((current == '&' && next == '&')
		|| (current == '|' && next == '|'));
}

### END OF FILE: ./src/parse/validation/operators/operators_utils.c ###


### START OF FILE: ./src/parse/validation/operators/validation_logical_operators.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_logical_operators.c                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/26 19:18:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 00:17:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	check_sequencing(t_token **curr, t_token **next)
{
	if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
		&& ft_strcmp((*next)->value, ";") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence &&;");
		return (false);
	}
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& ft_strcmp((*next)->value, ";") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence ||;");
		return (false);
	}
	if (ft_strcmp((*curr)->value, ";") == 0 && (*next)->type == TOKEN_OR
		&& ft_strcmp((*next)->value, "||") == 0)
	{
		report_error (ERR_SYNTAX, "invalid operator sequence ;||");
		return (false);
	}
	if (ft_strcmp((*curr)->value, ";") == 0 && (*next)->type == TOKEN_AND
		&& ft_strcmp((*next)->value, "&&") == 0)
		return (report_error(ERR_SYNTAX, "invalid operator sequence ;&&"),
			false);
	return (true);
}

static bool	check_tokens_utils(t_token **curr, t_token **next)
{
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& (*next)->type == TOKEN_OR && ft_strcmp((*next)->value, "|") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence |||");
		return (false);
	}
	if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
		&& (*next)->type == TOKEN_OR && ft_strcmp((*next)->value, "||") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence &&||");
		return (false);
	}
	if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
		&& (*next)->type == TOKEN_AND && ft_strcmp((*next)->value, "&&") == 0)
	{
		report_error(ERR_SYNTAX, "invalid operator sequence ||&&");
		return (false);
	}
	return (true);
}

bool	check_tokens(t_token **curr, t_token **next)
{
	if ((*next) && ((*next)->type == TOKEN_AND || (*next)->type == TOKEN_OR
			|| (*next)->type == TOKEN_PIPE))
	{
		if ((*curr)->type == TOKEN_AND && ft_strcmp((*curr)->value, "&&") == 0
			&& (*next)->type == TOKEN_AND
			&& ft_strcmp((*next)->value, "&") == 0)
		{
			report_error(ERR_SYNTAX, "invalid operators sequence '&&&'");
			return (false);
		}
		if ((*curr)->type == TOKEN_OR && ft_strcmp((*curr)->value, "||") == 0
			&& (*next)->type == TOKEN_PIPE)
		{
			report_error(ERR_SYNTAX, "invalid operator '|||'");
			return (false);
		}
		if (!check_tokens_utils(curr, next))
			return (false);
		if (!check_sequencing(curr, next))
			return (false);
	}
	return (true);
}

bool	validate_logical_op(t_token *tokens)
{
	t_token		*next;
	t_token		*curr;

	curr = tokens;
	next = NULL;
	while (curr)
	{
		next = curr->next;
		if (curr->type == TOKEN_AND || curr->type == TOKEN_OR
			|| curr->type == TOKEN_PIPE)
		{
			if (!check_tokens(&curr, &next))
				return (false);
		}
		curr = curr->next;
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/operators/validation_logical_operators.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/10 16:19:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 02:21:29 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_redirect_after_paren(char *next_input, t_token *token, int *j)
{
	if (next_input[*j] && ft_is_redirection(next_input[*j]))
	{
		if (next_input[*j] && next_input[*j] == next_input[*j + 1])
			*j += 2;
		else
			*j += 1;
		while (next_input[*j] && ft_isspace(next_input[*j]))
			(*j)++;
		if (!next_input[*j] || is_valid_command_char(next_input[*j]))
		{
			report_error(ERR_SYNTAX, "redirection without filename");
			free_stack(token);
			return (false);
		}
	}
	return (true);
}

bool	check_commands_after_paren(char *input, int *j)
{
	bool	found_operator;
	int		k;

	if (input[*j] && is_command_or_arg_char(input[*j]))
	{
		found_operator = false;
		k = 0;
		while (k < *j)
		{
			if (ft_is_operator(input[k]) || input[*j] == '|'
				|| (input[k + 1] && ft_is_logical_op(input[k], input[k + 1])))
			{
				found_operator = true;
				break ;
			}
			k++;
		}
		if (!found_operator)
		{
			report_error(ERR_SYNTAX, "missing operator between"
				"parenthesis and commands");
			return (false);
		}
	}
	return (true);
}

bool	check_op_after_paren(char *input, t_token *token, int *j)
{
	if (*j > 0 || !input[*j + 1] || input[*j] != input[*j + 1])
	{
		report_error(ERR_SYNTAX, "incomplete logical operator");
		free_stack(token);
		return (false);
	}
	*j += 2;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j] || !is_valid_command_char(input[*j]))
	{
		report_error(ERR_SYNTAX, "operator without syntax");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	logical_op_after_paren(char *input, t_token *token, int *j)
{
	if (!input[*j])
		return (false);
	if (input[*j] == '&')
		return (check_op_after_paren(input, token, j));
	else if (input[*j] == '|')
	{
		if (input[*j + 1] && input[*j + 1] == '|')
			return (check_op_after_paren(input, token, j));
		else
		{
			(*j)++;
			while (input[*j] && ft_isspace(input[*j]))
				(*j)++;
			if (!input[*j] || !is_valid_command_char(input[*j]))
			{
				report_error(ERR_SYNTAX, "pipe without command");
				free_stack(token);
				return (false);
			}
		}
	}
	return (true);
}

bool	check_next_token(t_token *next)
{
	t_token			*next_token;
	char			*next_input;
	int				j;

	if (!next || !next->next)
		return (true);
	next_token = next->next;
	if (!next->value)
		return (report_error(ERR_SYNTAX, "null token after parenthesis"),
			false);
	next_input = next_token->value;
	j = 0;
	while (next_input[j] && ft_isspace(next_input[j]))
		j++;
	if (!next_input[j])
		return (true);
	if (!check_redirect_after_paren(next_input, next_token, &j))
		return (false);
	else if (!check_commands_after_paren(next_input, &j))
		return (false);
	else if (!logical_op_after_paren(next_input, next_token, &j))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 11:49:59 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 16:27:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	if_there_is_filename(char *input, int *j, t_token *token)
{
	int			k;
	t_token		*next;

	if (!input[*j] || !is_valid_command_char(input[*j]))
	{
		if (!input[*j] && token->next)
		{
			next = token->next;
			k = 0;
			while (input[k] && ft_isspace(input[k]))
				k++;
			if (!next->value[k] || !is_valid_command_char(input[k]))
			{
				report_error(ERR_SYNTAX, "redirect without filename");
				return (free_stack(token), false);
			}
		}
	}
	return (true);
}

bool	it_is_redirect(char *input, int *i, int *j, t_token *token)
{
	if (ft_is_redirection(input[*i + 1]))
	{
		*j = *i + 1;
		if (input[*j + 1] && input[*j] == input[*j + 1])
			*j += 2;
		else
			*j += 1;
		while (input[*j] && ft_isspace(input[*j]))
			(*j)++;
		if (!if_there_is_filename(input, j, token))
			return (false);
		else
		{
			report_error(ERR_SYNTAX, "redirection without filename");
			return (free_stack(token), false);
		}
	}
	return (true);
}

bool	it_is_operator(char *input, int *i, int *j, t_token *token)
{
	if (input[*i + 1] == '&' || input[*i + 1] == '|')
	{
		if (!input[*i + 2])
		{
			if (!it_is_log_or_pipe(input, i, token))
				return (false);
		}
		else if (input[*i + 2] == input[*i + 3])
		{
			if (!it_is_logical_op(input, i, j, token))
				return (false);
		}
		else if (input[*i + 1] && input[*i + 2] != '|')
		{
			if (!it_is_pipe(input, i, j, token))
				return (false);
		}
	}
	return (true);
}

bool	check_after_close_paren(char *input, int *i, t_token *token)
{
	int			j;

	j = 0;
	if (!it_is_redirect(input, i, &j, token))
		return (false);
	else if (!it_is_operator(input, i, &j, token))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren_utils.c ###


### START OF FILE: ./src/parse/validation/parenthesis/close_paren_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   close_paren_utils_1.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/11 14:58:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/11 19:57:06 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	it_is_pipe(char *input, int *i, int *j, t_token *token)
{
	int		k;
	t_token	*next;

	*j = *i + 2;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j])
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "pipe without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(next->value[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
			return (report_error(ERR_SYNTAX, "pipe withou command"),
				free_stack(token), false);
	}
	else if (!is_valid_command_char(input[*j]))
		return (report_error(ERR_SYNTAX, "invalid token after pipe"),
			free_stack(token), false);
	return (true);
}

bool	it_is_logical_op(char *input, int *i, int *j, t_token *token)
{
	t_token	*next;
	int		k;

	*j = *i + 3;
	while (input[*j] && ft_isspace(input[*j]))
		(*j)++;
	if (!input[*j])
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "operator without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(next->value[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
			return (report_error(ERR_SYNTAX, "operator withoud command"),
				free_stack(token), false);
	}
	else if (!is_valid_command_char(input[*j]))
		return (report_error(ERR_SYNTAX, "invalid token after operator"),
			free_stack(token), false);
	return (true);
}

bool	it_is_log_or_pipe(char *input, int *i, t_token *token)
{
	int		k;
	t_token	*next;

	if (input[*i + 1] == '|')
	{
		if (!token->next)
		{
			report_error(ERR_SYNTAX, "pipe without command");
			return (free_stack(token), false);
		}
		next = token->next;
		k = 0;
		while (next->value[k] && ft_isspace(input[k]))
			k++;
		if (!next->value[k] || !is_valid_command_char(next->value[k]))
		{
			report_error(ERR_SYNTAX, "operator without command");
			return (free_stack(token), false);
		}
	}
	else if (!token->next || token->next->value[0] != input[*i + 1])
		return (report_error(ERR_SYNTAX, "incomplete logical operator"),
			free_stack(token), false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/close_paren_utils_1.c ###


### START OF FILE: ./src/parse/validation/parenthesis/find_match_paren.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   find_match_paren.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 15:18:18 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 15:48:55 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static int	process_paren_char(char c, t_quotes *quote_type, int *paren_count)
{
	process_quotes(c, quote_type);
	if (!quote_type->in_double_quotes && !quote_type->in_single_quotes)
	{
		if (c == '(')
			(*paren_count)++;
		else if (c == ')')
			(*paren_count)--;
	}
	return (*paren_count);
}

static int	scan_token_paren(t_token *curr, char *input, int *total_pos,
	int start_pos)
{
	t_quotes	quote_type;
	int			paren_count;
	int			j;

	paren_count = 1;
	j = start_pos;
	quote_type = (t_quotes){false, false};
	while (curr)
	{
		input = curr->value;
		while (input[j] != '\0')
		{
			if (process_paren_char(input[j], &quote_type, &paren_count) == 0)
				return (*total_pos + j);
			j++;
		}
		*total_pos += ft_strlen(curr->value);
		j = 0;
		curr = curr->next;
	}
	return (-1);
}

int	find_matching_paren(t_token *token, char *input, int start_pos)
{
	t_token		*curr;
	int			total_pos;

	curr = token;
	total_pos = 0;
	while (curr && start_pos >= ft_strlen(curr->value))
	{
		start_pos -= ft_strlen(curr->value);
		curr = curr->next;
	}
	return (scan_token_paren(curr, input, &total_pos, start_pos));
}

### END OF FILE: ./src/parse/validation/parenthesis/find_match_paren.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 01:24:50 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:15:48 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	validate_open_paren(char *input, int i, t_token *token)
{
	if (i == 0)
		return (true);
	if (i > 0)
	{
		if (is_command_or_arg_char(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "missing operator or space before '(");
			return (free_stack(token), false);
		}
		if (ft_is_redirection(input[i - 1]) || ft_is_wildcard(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "invalid token before the '('");
			return (false);
		}
		if (!valid_before_open_paren(input[i - 1]))
		{
			report_error(ERR_SYNTAX, "invalid token before '('");
			return (false);
		}
	}
	if (input[i + 1] && !is_valid_after_open_paren(input[i + 1]))
		return (report_error(ERR_SYNTAX, "invalid token after '('"), false);
	return (true);
}

static bool	validate_command_paren(char *input, int i, t_paren *command)
{
	command->j = i - 1;
	while (command->j >= 0 && ft_isspace(input[command->j]))
		command->j--;
	if (command->j >= 0 && is_command_or_arg_char(input[command->j]))
	{
		while (command->j >= 0 && is_command_or_arg_char(input[command->j]))
			command->j--;
		command->has_cmd_before = true;
	}
	if (command->has_cmd_before)
	{
		command->j++;
		command->has_operator = false;
		while (command->j < i && !command->has_operator)
		{
			if (ft_is_operator(input[command->j]))
				command->has_operator = true;
			command->j++;
		}
		if (!command->has_operator)
			return (false);
	}
	return (true);
}

int	check_matching_paren(char *input, int i, t_token *token, int start)
{
	t_token		*next_token;
	int			end_pos;

	if (i + 1 >= (int)ft_strlen(input))
	{
		start = 0;
		next_token = token->next;
		if (!next_token)
		{
			report_error(ERR_SYNTAX, "unmatched parenthesis");
			return (-1);
		}
		end_pos = find_matching_paren(next_token, next_token->value, start);
		if (end_pos != -1)
			return (end_pos + ft_strlen(input));
	}
	else
	{
		start = i + 1;
		end_pos = find_matching_paren(token, input, start);
		return (end_pos);
	}
	return (-1);
}

static int	process_open_paren(t_token *token, char *input, int i,
	t_paren *commands)
{
	int			start_pos;
	int			end_pos;

	if (i > 0 && !validate_command_paren(input, i, commands))
	{
		report_error(ERR_SYNTAX, "invalid command before parenthesis");
		return (free_stack(token), false);
	}
	if (!validate_open_paren(input, i, token))
		return (-1);
	start_pos = 0;
	end_pos = check_matching_paren(input, i, token, start_pos);
	if (end_pos == -1)
		return (report_error(ERR_SYNTAX, "unclosed parenthesis"), false);
	if (end_pos == i + 1)
		return (report_error(ERR_SYNTAX, "empty parenthesis"), false);
	if (!validate_paren_content(input, start_pos, end_pos, token))
		return (false);
	push(token, '(');
	commands->has_content = true;
	commands->last_op = ')';
	commands->has_commands = false;
	return (end_pos);
}

bool	check_parenthesis(t_token *token, char *input, int i,
	t_paren *commands)
{
	int			new_pos;

	if (!commands->quote.in_single_quotes
		&& !commands->quote.in_double_quotes)
	{
		if (!commands->has_commands && is_valid_command_char(input[i]))
			commands->has_commands = true;
		else if (commands->has_commands && ft_isspace(input[i]))
			commands->has_commands = false;
		if (input[i] == '(')
		{
			new_pos = process_open_paren(token, input, i, commands);
			if (new_pos <= 0)
				return (false);
			i = new_pos;
		}
		else if (input[i] == ')')
		{
			if (!process_close_paren(input, i, token, commands))
				return (false);
		}
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_content.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_content.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/08 00:53:16 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:51:11 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

t_nest	check_paren_in_token(t_state *state, int end, char *input)
{
	t_nest			result;

	result = (t_nest){false, state->token, state->pos};
	while (state->pos < end && input[state->pos])
	{
		process_quotes(input[state->pos], &state->quote);
		if (!state->quote.in_double_quotes && !state->quote.in_single_quotes)
		{
			if (input[state->pos] == '(')
				state->paren_count++;
			else if (input[state->pos] == ')')
			{
				state->paren_count--;
				if (state->paren_count == 0)
				{
					result.success = true;
					result.position = state->pos;
					return (result);
				}
			}
		}
		state->pos++;
	}
	return (result);
}

t_nest	check_paren_in_multiple_token(t_state *state, char *input,
	t_token *curr)
{
	t_nest				result;

	result = (t_nest){false, curr, state->pos};
	while (input[state->pos] && state->paren_count > 0)
	{
		process_quotes(input[state->pos], &state->quote);
		if (!state->quote.in_double_quotes && !state->quote.in_single_quotes)
		{
			if (input[state->pos] == '(')
				state->paren_count++;
			else if (input[state->pos] == ')')
			{
				state->paren_count--;
				if (state->paren_count == 0)
					return ((t_nest){true, curr, state->pos});
			}
		}
		state->pos++;
	}
	return (result);
}

t_nest	validate_nested_paren(char *input, int start, int end,
	t_token *start_token)
{
	t_nest				result;
	t_state				state;
	t_token				*curr;

	result = (t_nest){false, start_token, start};
	state = (t_state){{false, false}, start_token, start + 1, 1};
	result = check_paren_in_token(&state, end, input);
	if (result.success)
		return (result);
	curr = state.token->next;
	while (curr && state.paren_count > 0)
	{
		state.pos = 0;
		input = curr->value;
		result = check_paren_in_multiple_token(&state, input, curr);
		if (result.success)
			return (result);
		curr = curr->next;
	}
	report_error(ERR_SYNTAX, "unbalanced parenthesis");
	return (result);
}

bool	handle_paren(char *input, t_open_paren *paren, int *end,
	t_token **curr)
{
	t_nest				result;

	result = validate_nested_paren(input, paren->i, *end, *curr);
	if (!result.success)
		return (false);
	if (result.token != *curr)
	{
		*curr = result.token;
		input = (*curr)->value;
		*end = ft_strlen(input);
		paren->i = result.position + 1;
	}
	else
		paren->i = result.position + 1;
	paren->has_commands = true;
	paren->expecting_commands = false;
	return (true);
}

bool	validate_paren_content(char *input, int start, int end,
	t_token *token)
{
	t_open_paren		paren;
	char				*curent_input;
	t_token				*curr;

	paren = (t_open_paren){false, true, start};
	curent_input = input;
	curr = token;
	while (paren.i < end)
	{
		if (skip_whitespaces(input, &paren.i, end))
			break ;
		if (curent_input[paren.i] == '(')
		{
			if (!handle_paren(input, &paren, &end, &curr))
				return (false);
			continue ;
		}
		if (op_paren(input, &paren, token) || pipe_paren(input, &paren, token)
			|| seq_paren(input, &paren, token))
			continue ;
		if (!validate_redirect_or_command(input, &paren, end, token))
			return (false);
	}
	return (validate_paren_content_utils(&paren, token));
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_content.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/24 21:09:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/09 00:24:21 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	valid_before_open_paren(char c)
{
	return (ft_isspace(c) || c == '|' || c == '&' || c == '('
		|| c == ';' || c == '\0');
}

bool	is_valid_after_open_paren(char c)
{
	return (ft_isalnum(c) || c == '(' || c == '$');
}

bool	is_valid_close_paren(char c)
{
	return (ft_isspace(c) || c == '|' || c == '&' || c == ')' || c == ';'
		|| c == '\0');
}

bool	skip_whitespaces(char *input, int *i, int end)
{
	while (*i < end && ft_isspace(input[*i]))
		(*i)++;
	return (*i >= end);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils_1.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 23:59:21 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/10 16:19:47 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	validate_redirect_or_command(char *input, t_open_paren *paren,
	int end, t_token *token)
{
	if (validate_redirect_in_paren(input, paren, end, token))
		return (true);
	if (is_valid_command_char(input[paren->i]))
	{
		while (paren->i < end && is_valid_command_char(input[paren->i]))
			paren->i++;
		paren->has_commands = true;
		paren->expecting_commands = false;
	}
	else
	{
		report_error(ERR_SYNTAX, "invalid syntax near character");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	seq_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (input[paren->i] == ';')
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "sequence without preceding commands");
			free_stack(token);
			return (false);
		}
		paren->i++;
		paren->has_commands = false;
		paren->expecting_commands = true;
		return (true);
	}
	return (false);
}

bool	pipe_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (input[paren->i] == '|' && input[paren->i + 1] != '|')
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "pipe without preceding commands");
			free_stack(token);
			return (false);
		}
		paren->i++;
		paren->expecting_commands = true;
		paren->has_commands = false;
		return (true);
	}
	return (false);
}

bool	op_paren(char *input, t_open_paren *paren, t_token *token)
{
	if (ft_is_logical_op(input[paren->i], input[paren->i + 1]))
	{
		if (!paren->has_commands)
		{
			report_error(ERR_SYNTAX, "operator without preceding command");
			free_stack(token);
			return (false);
		}
		paren->i += 2;
		paren->expecting_commands = true;
		paren->has_commands = false;
		return (true);
	}
	return (false);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_1.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_2.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_utils_2.c                              :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/04 02:26:37 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/12 16:57:15 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	validate_redirect_in_paren(char *input, t_open_paren *paren, int end,
	t_token *token)
{
	if (ft_is_redirection(input[paren->i]))
	{
		if (paren->i + 1 < end && input[paren->i] == input[paren->i + 1])
			paren->i += 2;
		else
			paren->i++;
		while (paren->i < end && ft_isspace(input[paren->i]))
			paren->i++;
		if (paren->i >= end || !is_valid_command_char(input[paren->i]))
		{
			report_error(ERR_SYNTAX, "redirection without filenamd");
			free_stack(token);
			return (false);
		}
		while (paren->i < end && is_valid_command_char(input[paren->i]))
			paren->i++;
	}
	return (true);
}

bool	validate_paren_content_utils(t_open_paren *paren, t_token *token)
{
	if (paren->expecting_commands && !paren->has_commands)
	{
		report_error(ERR_SYNTAX, "missing command after operator");
		free_stack(token);
		return (false);
	}
	return (true);
}

bool	check_closed_paren(char *input, int i, t_token *token)
{
	if (!ft_isspace(input[i + 1]) && !is_valid_close_paren(input[i + 1])
		&& !ft_is_redirection(input[i + 1]) && !ft_is_wildcard(input[i + 1]))
	{
		report_error(ERR_SYNTAX, "invalid token after ')'");
		return (free_stack(token), false);
	}
	if (ft_is_redirection_op(input[i], input[i + 1]))
		return (true);
	if (ft_is_wildcard(input[i + 1]) && !ft_isspace(input[i + 1]))
	{
		report_error(ERR_SYNTAX, "missing space after ')'");
		return (free_stack(token), false);
	}
	return (true);
}

bool	process_close_paren(char *input, int i, t_token *token,
	t_paren *command)
{
	if (is_empty(token))
	{
		report_error(ERR_UNEXPECTED_TOKEN, ")");
		return (free_stack(token), false);
	}
	if (!command->has_content)
	{
		report_error(ERR_SYNTAX, "empty parenthesis");
		return (free_stack(token), false);
	}
	if (input[i + 1])
	{
		if (is_command_or_arg_char(input[i + 1]))
		{
			report_error(ERR_SYNTAX, "missing operator or space after ')'");
			return (free_stack(token), false);
		}
		if (!check_closed_paren(input, i, token))
			return (false);
	}
	else if (!check_next_token(token->next))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_utils_2.c ###


### START OF FILE: ./src/parse/validation/parenthesis/parenthesis_validation.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parenthesis_validation.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: codespace <codespace@student.42.fr>        +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/23 17:59:54 by ldurmish          #+#    #+#             */
/*   Updated: 2025/04/07 15:42:09 by codespace        ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

void	process_quotes(char c, t_quotes *quote)
{
	if (c == '"' && !quote->in_single_quotes)
		quote->in_double_quotes = !quote->in_double_quotes;
	else if (c == '\'' && !quote->in_double_quotes)
		quote->in_single_quotes = !quote->in_single_quotes;
}

bool	parenthesis(t_token *token, char *input, t_paren *commands)
{
	int			i;

	i = 0;
	while (input[i] != '\0')
	{
		process_quotes(input[i], &commands->quote);
		if (!check_parenthesis(token, input, i, commands))
			return (false);
		i++;
	}
	return (true);
}

bool	parenthesis_utils(t_token *tokenize)
{
	char		*input;
	t_token		*stack;
	t_paren		commands;

	stack = tokenize;
	commands = (t_paren){false, false, '\0', false, 0, false, (t_quotes){false, false}};
	initialize_stack(stack);
	while (stack && stack->value)
	{
		input = stack->value;
		if (stack->single_quotes == 1)
			return (true);
		else if (stack->double_quotes == 1)
			return (true);
		if (!parenthesis(stack, input, &commands))
			return (false);
		stack = stack->next;
	}
	if (!is_empty(stack))
		return (report_error(ERR_UNEXPECTED_TOKEN, ")"),
			free_stack(stack), false);
	free_stack(stack);
	free(stack);
	return (true);
}

bool	check_count_paren(t_token *tokenize)
{
	int		paren_count;

	paren_count = count_parenthesis(tokenize);
	if (paren_count != 0)
	{
		if (paren_count > 0)
			report_error(ERR_UNEXPECTED_TOKEN, ")");
		else
			report_error(ERR_UNEXPECTED_TOKEN, "(");
		return (false);
	}
	if (!parenthesis_utils(tokenize))
		return (false);
	return (true);
}

bool	validation_parenthesis(t_token *tokenize)
{
	if (!tokenize)
		return (true);
	if (!check_count_paren(tokenize))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/parenthesis/parenthesis_validation.c ###


### START OF FILE: ./src/parse/validation/pipes/pipes_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   pipes_utils.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/13 00:23:14 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/15 18:52:41 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	is_operator_token(t_token *prev)
{
	if (!prev)
		return (false);
	return (prev->type == TOKEN_REDIRECT_IN || prev->type == TOKEN_REDIRECT_OUT
		|| prev->type == TOKEN_APPEND || prev->type == TOKEN_HEREDOC
		|| prev->type == TOKEN_AND || prev->type == TOKEN_OR
		|| prev->type == TOKEN_PIPE);
}

bool	has_whitespace_between(t_token *first, t_token *second)
{
	t_token		*curr;

	curr = first->next;
	while (curr && curr != second)
	{
		if (curr->type == TOKEN_WORD && is_only_whitespaces(curr->value))
			return (true);
		curr = curr->next;
	}
	return (false);
}

bool	is_only_whitespaces(char *str)
{
	int			i;

	i = 0;
	if (!str)
		return (false);
	while (str[i] != '\0')
	{
		if (!ft_isspace(str[i]))
			return (false);
		i++;
	}
	return (true);
}

bool	return_pipes_mssg(bool *expecting_cmd)
{
	if (*expecting_cmd)
	{
		report_error(ERR_SYNTAX, "missing command after pipes");
		return (false);
	}
	return (true);
}

bool	check_redirection_before_pipe(t_token *curr, t_token *head)
{
	t_token		*check;
	t_token		*last_redir;
	bool		has_filename;

	check = head;
	while (check != curr)
	{
		if ((check->type == TOKEN_APPEND || check->type == TOKEN_REDIRECT_OUT)
			&& check->next == curr)
			return (true);
		check = check->next;
	}
	check = head;
	last_redir = NULL;
	has_filename = false;
	while (check != curr)
	{
		if (check->type == TOKEN_APPEND || check->type == TOKEN_REDIRECT_IN
			|| check->type == TOKEN_REDIRECT_OUT
			|| check->type == TOKEN_HEREDOC)
		{
			if (check->next == curr)
			{
				last_redir = NULL;
			}
			last_redir = check;
			has_filename = false;
		}
		else if (last_redir && check->type == TOKEN_WORD
			&& !is_only_whitespaces(check->value))
			has_filename = true;
		check = check->next;
	}
	if (last_redir && !has_filename)
		return (report_error(ERR_SYNTAX, "missing filename before pipes"),
			false);
	return (true);
}

### END OF FILE: ./src/parse/validation/pipes/pipes_utils.c ###


### START OF FILE: ./src/parse/validation/pipes/validation_pipes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_pipes.c                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/12 19:22:21 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:31:46 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_pipe_followed_by_logical(t_token *curr)
{
	t_token		*next;

	next = curr->next;
	while (next && next->type == TOKEN_WORD && is_only_whitespaces(next->value))
		next = next->next;
	if (next && (next->type == TOKEN_AND || next->type == TOKEN_OR))
	{
		if (next->type == TOKEN_AND && ft_strcmp(next->value, "&&") == 0)
			report_error(ERR_SYNTAX, "invalid operator sequence '|&&'");
		else if (next->type == TOKEN_OR && ft_strcmp(next->value, "||") == 0)
			report_error(ERR_SYNTAX, "invalid opeartor sequence '|||'");
		else
			report_error(ERR_SYNTAX, "invalid operator sequence");
		return (false);
	}
	return (true);
}

bool	check_operator_before_pipe(t_token *prev, t_token *curr)
{
	t_token		*check;
	bool		has_word;

	if (!is_operator_token(prev))
		return (true);
	if (prev->type == TOKEN_REDIRECT_OUT && ft_strcmp(prev->value, ">") == 0
		&& !has_whitespace_between(prev, curr))
		return (true);
	if (prev->type == TOKEN_APPEND && ft_strcmp(prev->value, ">>") == 0
		&& !has_whitespace_between(prev, curr))
		return (true);
	check = prev->next;
	has_word = false;
	while (check && check != curr)
	{
		if (check->type == TOKEN_WORD && !is_only_whitespaces(check->value))
		{
			has_word = true;
			break ;
		}
		check = check->next;
	}
	if (!has_word)
		return (report_error(ERR_SYNTAX, "token '|'"), false);
	return (true);
}

bool	validate_pipe_position(t_token *prev, t_token *curr, t_token *head)
{
	t_token		*next;

	if (!check_redirection_before_pipe(curr, head))
		return (false);
	if (curr->next == NULL)
	{
		report_error(ERR_UNEXPECTED_TOKEN, "'|'");
		return (false);
	}
	if (!check_pipe_followed_by_logical(curr))
		return (false);
	next = curr->next;
	while (next && next->type == TOKEN_WORD && is_only_whitespaces(next->value))
		next = next->next;
	if (next && next->type == TOKEN_PIPE)
		return (report_error(ERR_UNEXPECTED_TOKEN, "'|'"), false);
	if (!check_operator_before_pipe(prev, curr))
		return (false);
	return (true);
}

bool	has_expecting_command(t_token *curr, bool *expecting_command)
{
	t_token		*next;

	if (curr->type == TOKEN_WORD && is_only_whitespaces(curr->value))
		return (true);
	else if (curr->type == TOKEN_WORD && !is_only_whitespaces(curr->value))
		*expecting_command = false;
	else if (curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_REDIRECT_OUT
		|| curr->type == TOKEN_APPEND || curr->type == TOKEN_HEREDOC)
	{
		next = curr->next;
		if (!next)
			return (report_error(ERR_SYNTAX, "newline"), false);
		while (next && next->type == TOKEN_WORD
			&& is_only_whitespaces(next->value))
			next = next->next;
		if (next->type == TOKEN_WORD && !is_only_whitespaces(next->value))
			*expecting_command = false;
	}
	else if (curr->type == TOKEN_AND || curr->type == TOKEN_OR
		|| curr->type == TOKEN_PIPE)
	{
		report_error(ERR_SYNTAX, "missing command");
		return (false);
	}
	return (true);
}

bool	pipes(t_token *tokenize)
{
	t_pipe		pipe;

	pipe = (t_pipe){tokenize, NULL, tokenize, false};
	while (pipe.curr)
	{
		if (pipe.curr->type == TOKEN_WORD
			&& is_only_whitespaces(pipe.curr->value))
		{
			pipe.prev = pipe.curr;
			pipe.curr = pipe.curr->next;
			continue ;
		}
		if (pipe.curr->type == TOKEN_PIPE)
		{
			if (!validate_pipe_position(pipe.prev, pipe.curr, pipe.head))
				return (false);
			pipe.expecting_command = true;
		}
		else if (pipe.expecting_command
			&& !has_expecting_command(pipe.curr, &pipe.expecting_command))
			return (false);
		pipe.prev = pipe.curr;
		pipe.curr = pipe.curr->next;
	}
	return (return_pipes_mssg(&pipe.expecting_command));
}

### END OF FILE: ./src/parse/validation/pipes/validation_pipes.c ###


### START OF FILE: ./src/parse/validation/quotes/validation_quotes.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation_quotes.c                                :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 09:57:00 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/03 12:04:07 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

static bool	check_quotes(t_quotes *quote)
{
	if (quote->in_double_quotes || quote->in_single_quotes)
	{
		report_error(ERR_SYNTAX, "Unmtached %c quote detected");
		return (false);
	}
	return (true);
}

bool	validation_quotes(t_token *tokens)
{
	t_token		*curr;
	t_quotes	quote;
	int			i;
	char		*value;

	curr = tokens;
	quote = (t_quotes){false, false};
	while (curr)
	{
		if (curr->type == TOKEN_WORD)
		{
			value = curr->value;
			i = 0;
			while (value && value[i])
			{
				process_quotes(value[i], &quote);
				i++;
			}
		}
		curr = curr->next;
	}
	if (!check_quotes(&quote))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/quotes/validation_quotes.c ###


### START OF FILE: ./src/parse/validation/redirections/redirections_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   redirections_utils.c                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/25 17:12:46 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:23:31 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_redirection(char c)
{
	return (c == '<' || c == '>');
}

bool	ft_is_redirection_op(char curr, char next)
{
	return ((curr == '>' && curr == '>') || (curr == '<' && next == '<'));
}

bool	check_after_redirection(t_token **curr)
{
	if (((*curr)->type == TOKEN_REDIRECT_OUT || (*curr)->type == TOKEN_APPEND
			|| (*curr)->type == TOKEN_REDIRECT_IN
			|| (*curr)->type == TOKEN_HEREDOC) && (*curr)->next
		&& ((*curr)->next->type == TOKEN_OR
			|| (*curr)->next->type == TOKEN_AND))
		return (report_error(ERR_UNEXPECTED_TOKEN, (*curr)->next->value),
			false);
	return (true);
}

bool	validate_next_redirect(t_token **next, t_token **curr)
{
	while (*next && (*next)->type == TOKEN_WHITESPACE)
		*next = (*next)->next;
	if (!*next || ((*next)->type != TOKEN_WORD
			&& (*next)->type != TOKEN_PROCESSED))
	{
		if (!*next)
			report_error(ERR_UNEXPECTED_TOKEN, "newline");
		else
			report_error(ERR_UNEXPECTED_TOKEN, (*curr)->value);
		return (false);
	}
	return (true);
}

### END OF FILE: ./src/parse/validation/redirections/redirections_utils.c ###


### START OF FILE: ./src/parse/validation/redirections/validate_redirection.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validate_redirection.c                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/15 13:11:15 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 15:22:54 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	check_redirection(t_token **next)
{
	if (*next && ((*next)->type == TOKEN_APPEND
			|| (*next)->type == TOKEN_REDIRECT_IN
			|| (*next)->type == TOKEN_HEREDOC
			|| (*next)->type == TOKEN_REDIRECT_OUT))
	{
		report_error(ERR_UNEXPECTED_TOKEN, (*next)->value);
		return (false);
	}
	else if (*next && ((*next)->type == TOKEN_AND || (*next)->type == TOKEN_OR))
	{
		report_error(ERR_UNEXPECTED_TOKEN, (*next)->value);
		return (false);
	}
	return (true);
}

bool	check_adjacent_redirection(t_token **curr)
{
	if ((*curr)->type == TOKEN_REDIRECT_IN && (*curr)->next
		&& (*curr)->next->type == TOKEN_REDIRECT_OUT)
	{
		(*curr)->type = TOKEN_READWRITE;
		free((*curr)->value);
		(*curr)->value = ft_strdup("<>");
		(*curr)->next->type = TOKEN_PROCESSED;
		return (true);
	}
	return (true);
}

bool	validate_redirection_spaces(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr != NULL)
	{
		if (curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_APPEND
			|| curr->type == TOKEN_REDIRECT_OUT || curr->type == TOKEN_HEREDOC)
		{
			next = curr->next;
			if (next && next->type == TOKEN_WHITESPACE)
			{
				next = next->next;
				if (!check_redirection(&next))
					return (false);
			}
		}
		if (!check_after_redirection(&curr))
			return (false);
		curr = curr->next;
	}
	return (true);
}

bool	validate_redirection_combinations(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr && curr->next)
	{
		if (curr->type == TOKEN_HEREDOC || curr->type == TOKEN_REDIRECT_OUT
			|| curr->type == TOKEN_APPEND || curr->type == TOKEN_REDIRECT_OUT)
		{
			next = curr->next;
			while (next && next->type == TOKEN_WHITESPACE)
				next = next->next;
			if (next && (next->type == TOKEN_REDIRECT_OUT
					|| next->type == TOKEN_APPEND
					|| next->type == TOKEN_REDIRECT_IN
					|| next->type == TOKEN_HEREDOC))
			{
				report_error(ERR_UNEXPECTED_TOKEN, next->value);
				return (false);
			}
		}
		curr = curr->next;
	}
	return (validate_redirection_spaces(tokenize));
}

bool	validate_redirection(t_token *tokenize)
{
	t_token		*curr;
	t_token		*next;

	curr = tokenize;
	while (curr != NULL)
	{
		if (curr->type == TOKEN_PROCESSED)
		{
			curr = curr->next;
			continue ;
		}
		if (curr->type == TOKEN_APPEND || curr->type == TOKEN_REDIRECT_IN
			|| curr->type == TOKEN_REDIRECT_OUT || curr->type == TOKEN_HEREDOC)
		{
			if (!check_adjacent_redirection(&curr))
				return (false);
			next = curr->next;
			if (!validate_next_redirect(&next, &curr))
				return (true);
		}
		curr = curr->next;
	}
	return (validate_redirection_combinations(tokenize));
}

### END OF FILE: ./src/parse/validation/redirections/validate_redirection.c ###


### START OF FILE: ./src/parse/validation/validation.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   validation.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/02/15 16:01:41 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/19 14:52:05 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../include/minishell.h"

bool	validation_utils(t_token *tokenize)
{
	if (!pipes(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validate_redirection(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	return (true);
}

bool	validation(t_token *tokenize)
{
	if (!validate_logical_op(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validate_commands(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_parenthesis(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_quotes(tokenize))
	{
		free_tokens(tokenize);
		return (false);
	}
	if (!validation_utils(tokenize))
		return (false);
	return (true);
}

### END OF FILE: ./src/parse/validation/validation.c ###


### START OF FILE: ./src/parse/validation/wildcards/wildcards_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   wildcards_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/03 20:29:29 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/03 20:31:18 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../../../include/minishell.h"

bool	ft_is_wildcard(char c)
{
	return (c == '*' || c == '?');
}

### END OF FILE: ./src/parse/validation/wildcards/wildcards_utils.c ###


### START OF FILE: ./src/tree/parse_commands.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_commands.c                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/22 17:53:52 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/24 00:08:51 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*init_command_node(t_token *start, int word_count)
{
	t_ast		*node;

	node = create_ast_node(AST_COMMAND, start);
	if (!node)
		return (NULL);
	node->cmd = create_command_struct();
	if (!node->cmd)
	{
		free(node);
		return (NULL);
	}
	node->cmd->args = malloc(sizeof(char *) * (word_count + 1));
	if (!node->cmd->args)
	{
		free(node->cmd);
		free(node);
		return (NULL);
	}
	return (node);
}

t_ast	*create_command_node(t_token *start, int word_count)
{
	t_ast		*node;
	t_token		*curr;
	int			i;

	node = init_command_node(start, word_count);
	if (!node)
		return (NULL);
	curr = start;
	i = 0;
	while (i < word_count)
	{
		skip_tree_whitespaces(&curr);
		if (curr && curr->type == TOKEN_WORD)
		{
			node->cmd->args[i] = ft_strdup(curr->value);
			curr = curr->next;
			i++;
		}
		else
			break ;
	}
	node->cmd->args[i] = NULL;
	return (node);
}

### END OF FILE: ./src/tree/parse_commands.c ###


### START OF FILE: ./src/tree/parse_redir.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   parse_redir.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/21 22:06:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 22:15:23 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast_type	get_redir_type(t_token *tokens)
{
	if (!tokens)
		return (0);
	if (tokens->type == TOKEN_APPEND)
		return (AST_REDIR_APPEND);
	else if (tokens->type == TOKEN_HEREDOC)
		return (AST_REDIR_HERDOC);
	else if (tokens->type == TOKEN_REDIRECT_IN)
		return (AST_REDIR_IN);
	else if (tokens->type == TOKEN_REDIRECT_OUT)
		return (AST_REDIR_OUT);
	return (0);
}

t_ast	*create_redir(t_token **token, t_ast *cmd_node)
{
	t_token		*curr;
	t_ast		*node;

	curr = *token;
	if (!curr)
		return (NULL);
	node = create_ast_node(get_redir_type(curr), curr);
	if (!node)
		return (NULL);
	node->operator_type = curr->type;
	node->left = cmd_node;
	if (curr->next)
		curr = curr->next;
	else
		return (node);
	skip_tree_whitespaces(&curr);
	*token = curr;
	return (node);
}

t_ast	*create_right_node(t_token **token)
{
	t_ast		*right_node;
	t_token		*curr;

	curr = *token;
	right_node = create_ast_node(AST_COMMAND, curr);
	if (!right_node)
		return (NULL);
	right_node->cmd = create_command_struct();
	if (!right_node)
	{
		free(right_node);
		return (NULL);
	}
	right_node->cmd->args = malloc(sizeof(char *) * 2);
	if (!right_node->cmd->args)
	{
		free(right_node);
		return (NULL);
	}
	right_node->cmd->args[0] = ft_strdup(curr->value);
	right_node->cmd->args[1] = NULL;
	*token = curr->next;
	return (right_node);
}

t_ast	*parse_redirection(t_token **tokens, t_ast *cmd_node)
{
	t_ast		*node;
	t_token		*curr;

	if (!tokens || !*tokens || !cmd_node)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	if (get_redir_type(curr) == 0)
		return (NULL);
	node = create_redir(&curr, cmd_node);
	if (!node || !curr || curr->type != TOKEN_WORD)
	{
		free(node);
		return (NULL);
	}
	node->right = create_right_node(&curr);
	if (!node->right)
	{
		free(node);
		return (NULL);
	}
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	return (node);
}

### END OF FILE: ./src/tree/parse_redir.c ###


### START OF FILE: ./src/tree/tree.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/19 15:32:24 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 20:06:32 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*parse_command(t_token **tokens)
{
	t_token		*current;

	if (!tokens || !*tokens)
		return (NULL);
	current = *tokens;
	skip_tree_whitespaces(&current);
	*tokens = current;
	if (current->type == TOKEN_PAREN_OPEN)
		return (parse_subshell(tokens));
	return (parse_simple_commands(tokens));
}

t_ast	*parse_pipeline(t_token **tokens)
{
	t_ast		*left;
	t_token		*curr;

	if (!tokens || !*tokens)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	left = parse_command(tokens);
	if (!left)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	while (curr && curr->type == TOKEN_PIPE)
	{
		left = parse_pipeline_node(left, tokens);
		if (!left)
			return (NULL);
		curr = *tokens;
		skip_tree_whitespaces(&curr);
		*tokens = curr;
	}
	return (left);
}

t_ast	*init_logic_node(t_ast *left, t_token **tokens)
{
	t_ast_type	node_type;
	t_token		*curr;
	t_ast		*node;

	curr = *tokens;
	if (curr->type == TOKEN_AND)
		node_type = AST_AND;
	else if (curr->type == TOKEN_OR)
		node_type = AST_OR;
	else
		return (NULL);
	node = create_ast_node(node_type, curr);
	if (!node)
		return (free_ast(left), NULL);
	node->left = left;
	if (curr->next)
		curr = curr->next;
	else
		return (NULL);
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	node->right = parse_pipeline(tokens);
	if (!node->right)
		return (free_ast(left), NULL);
	return (node);
}

t_ast	*parse_logic_sequence(t_token **tokens)
{
	t_ast		*left;
	t_ast		*node;
	t_token		*current;

	current = *tokens;
	skip_tree_whitespaces(&current);
	*tokens = current;
	left = parse_pipeline(tokens);
	if (!left)
		return (NULL);
	current = *tokens;
	skip_tree_whitespaces(&current);
	*tokens = current;
	while (current && (current->type == TOKEN_AND || current->type == TOKEN_OR))
	{
		node = init_logic_node(left, tokens);
		if (!node)
			return (NULL);
		left = node;
		current = *tokens;
		skip_tree_whitespaces(&current);
		*tokens = current;
	}
	return (left);
}

t_ast	*parse_tokens(t_token *tokens)
{
	t_token		*curr;
	t_ast		*root;

	if (!tokens)
		return (NULL);
	curr = tokens;
	skip_tree_whitespaces(&curr);
	root = parse_command_line(&curr);
	skip_tree_whitespaces(&curr);
	if (curr && curr->type != TOKEN_EOF)
	{
		free_ast(root);
		return (NULL);
	}
	return (root);
}

### END OF FILE: ./src/tree/tree.c ###


### START OF FILE: ./src/tree/tree_utils.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree_utils.c                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/18 21:23:10 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 17:02:45 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_ast	*parse_pipeline_node(t_ast *left, t_token **tokens)
{
	t_token		*curr;
	t_ast		*node;

	curr = *tokens;
	node = create_ast_node(AST_PIPELINE, curr);
	if (!node)
	{
		free_ast(left);
		return (NULL);
	}
	node->left = left;
	if (curr->next)
		curr = curr->next;
	else
		return (node);
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	node->right = parse_command_line(tokens);
	if (!node->right)
	{
		free_ast(left);
		return (NULL);
	}
	return (node);
}

void	skip_tree_whitespaces(t_token **tokens)
{
	while (*tokens && (*tokens)->type == TOKEN_WHITESPACE)
		*tokens = (*tokens)->next;
}

t_ast	*create_ast_node(t_ast_type type, t_token *token)
{
	t_ast		*node;

	node = malloc(sizeof(t_ast));
	if (!node)
		return (NULL);
	node->type = type;
	node->left = NULL;
	node->right = NULL;
	node->cmd = NULL;
	node->operator_type = 0;
	node->token = token;
	return (node);
}

t_ast	*parse_command_line(t_token **tokens)
{
	return (parse_logic_sequence(tokens));
}

void	free_ast(t_ast *node)
{
	int			i;

	if (!node)
		return ;
	free_ast(node->left);
	free_ast(node->right);
	if (node->cmd)
	{
		if (node->cmd->args)
		{
			i = -1;
			while (node->cmd->args[++i])
				free(node->cmd->args[i]);
			free(node->cmd->args[i]);
		}
		if (node->cmd->infile)
			free(node->cmd->infile);
		if (node->cmd->outfile)
			free(node->cmd->outfile);
		if (node->cmd->heredoc_delim)
			free(node->cmd->heredoc_delim);
		free(node->cmd);
	}
}

### END OF FILE: ./src/tree/tree_utils.c ###


### START OF FILE: ./src/tree/tree_utils_1.c ###

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   tree_utils_1.c                                     :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldurmish < ldurmish@student.42wolfsburg.d  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/20 17:45:55 by ldurmish          #+#    #+#             */
/*   Updated: 2025/03/23 17:22:02 by ldurmish         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

t_commands	*create_command_struct(void)
{
	t_commands		*cmd;

	cmd = malloc(sizeof(t_commands));
	if (!cmd)
		return (NULL);
	cmd->args = NULL;
	cmd->infile = NULL;
	cmd->outfile = NULL;
	cmd->heredoc_delim = NULL;
	cmd->append = 0;
	cmd->is_builtin = 0;
	return (cmd);
}

t_ast	*init_subshell_node(t_token **tokens)
{
	t_token		*curr;
	t_ast		*node;

	if (!tokens || !*tokens)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	if (curr->type != TOKEN_PAREN_OPEN)
		return (NULL);
	node = create_ast_node(AST_SUBSHELL, curr);
	if (!node)
		return (NULL);
	*tokens = curr->next;
	skip_tree_whitespaces(tokens);
	return (node);
}

t_ast	*parse_subshell(t_token **tokens)
{
	t_ast		*node;
	t_token		*curr;

	node = init_subshell_node(tokens);
	if (!node)
		return (NULL);
	node->left = parse_command_line(tokens);
	if (!node->left)
	{
		free(node);
		return (NULL);
	}
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	if (!curr || curr->type != TOKEN_PAREN_CLOSE)
	{
		free_ast(node);
		return (NULL);
	}
	*tokens = curr->next;
	return (node);
}

t_ast	*parse_command_words(t_token **tokens)
{
	t_ast		*cmd_node;
	t_token		*curr;
	t_token		*start;
	int			word_count;

	if (!tokens || !*tokens)
		return (NULL);
	curr = *tokens;
	skip_tree_whitespaces(&curr);
	*tokens = curr;
	start = curr;
	word_count = 0;
	while (curr && curr->type == TOKEN_WORD)
	{
		word_count++;
		curr = curr->next;
		skip_tree_whitespaces(&curr);
	}
	if (word_count == 0)
		return (NULL);
	cmd_node = create_command_node(start, word_count);
	if (!cmd_node)
		return (NULL);
	*tokens = curr;
	return (cmd_node);
}

t_ast	*parse_simple_commands(t_token **tokens)
{
	t_ast		*redir_node;
	t_ast		*cmd_node;
	t_token		*curr;

	cmd_node = parse_command_words(tokens);
	if (!cmd_node)
		return (NULL);
	curr = *tokens;
	while (curr && (curr->type == TOKEN_APPEND
			|| curr->type == TOKEN_REDIRECT_IN || curr->type == TOKEN_HEREDOC
			|| curr->type == TOKEN_REDIRECT_OUT))
	{
		redir_node = parse_redirection(tokens, cmd_node);
		if (!redir_node)
		{
			free_ast(cmd_node);
			return (NULL);
		}
		cmd_node = redir_node;
		curr = *tokens;
		skip_tree_whitespaces(&curr);
		*tokens = curr;
	}
	return (cmd_node);
}

### END OF FILE: ./src/tree/tree_utils_1.c ###
